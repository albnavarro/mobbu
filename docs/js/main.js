"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/highlight.js/lib/core.js
  var require_core = __commonJS({
    "node_modules/highlight.js/lib/core.js"(exports, module) {
      function deepFreeze(obj) {
        if (obj instanceof Map) {
          obj.clear = obj.delete = obj.set = function() {
            throw new Error("map is read-only");
          };
        } else if (obj instanceof Set) {
          obj.add = obj.clear = obj.delete = function() {
            throw new Error("set is read-only");
          };
        }
        Object.freeze(obj);
        Object.getOwnPropertyNames(obj).forEach((name) => {
          const prop = obj[name];
          const type = typeof prop;
          if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
            deepFreeze(prop);
          }
        });
        return obj;
      }
      var Response = class {
        /**
         * @param {CompiledMode} mode
         */
        constructor(mode) {
          if (mode.data === void 0) mode.data = {};
          this.data = mode.data;
          this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      };
      function escapeHTML(value) {
        return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function inherit$1(original, ...objects) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key in original) {
          result[key] = original[key];
        }
        objects.forEach(function(obj) {
          for (const key in obj) {
            result[key] = obj[key];
          }
        });
        return (
          /** @type {T} */
          result
        );
      }
      var SPAN_CLOSE = "</span>";
      var emitsWrappingTags = (node) => {
        return !!node.scope;
      };
      var scopeToCSSClass = (name, { prefix }) => {
        if (name.startsWith("language:")) {
          return name.replace("language:", "language-");
        }
        if (name.includes(".")) {
          const pieces = name.split(".");
          return [
            `${prefix}${pieces.shift()}`,
            ...pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`)
          ].join(" ");
        }
        return `${prefix}${name}`;
      };
      var HTMLRenderer = class {
        /**
         * Creates a new HTMLRenderer
         *
         * @param {Tree} parseTree - the parse tree (must support `walk` API)
         * @param {{classPrefix: string}} options
         */
        constructor(parseTree, options) {
          this.buffer = "";
          this.classPrefix = options.classPrefix;
          parseTree.walk(this);
        }
        /**
         * Adds texts to the output stream
         *
         * @param {string} text */
        addText(text) {
          this.buffer += escapeHTML(text);
        }
        /**
         * Adds a node open to the output stream (if needed)
         *
         * @param {Node} node */
        openNode(node) {
          if (!emitsWrappingTags(node)) return;
          const className = scopeToCSSClass(
            node.scope,
            { prefix: this.classPrefix }
          );
          this.span(className);
        }
        /**
         * Adds a node close to the output stream (if needed)
         *
         * @param {Node} node */
        closeNode(node) {
          if (!emitsWrappingTags(node)) return;
          this.buffer += SPAN_CLOSE;
        }
        /**
         * returns the accumulated buffer
        */
        value() {
          return this.buffer;
        }
        // helpers
        /**
         * Builds a span element
         *
         * @param {string} className */
        span(className) {
          this.buffer += `<span class="${className}">`;
        }
      };
      var newNode = (opts = {}) => {
        const result = { children: [] };
        Object.assign(result, opts);
        return result;
      };
      var TokenTree = class _TokenTree {
        constructor() {
          this.rootNode = newNode();
          this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        /** @param {Node} node */
        add(node) {
          this.top.children.push(node);
        }
        /** @param {string} scope */
        openNode(scope) {
          const node = newNode({ scope });
          this.add(node);
          this.stack.push(node);
        }
        closeNode() {
          if (this.stack.length > 1) {
            return this.stack.pop();
          }
          return void 0;
        }
        closeAllNodes() {
          while (this.closeNode()) ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        /**
         * @typedef { import("./html_renderer").Renderer } Renderer
         * @param {Renderer} builder
         */
        walk(builder) {
          return this.constructor._walk(builder, this.rootNode);
        }
        /**
         * @param {Renderer} builder
         * @param {Node} node
         */
        static _walk(builder, node) {
          if (typeof node === "string") {
            builder.addText(node);
          } else if (node.children) {
            builder.openNode(node);
            node.children.forEach((child) => this._walk(builder, child));
            builder.closeNode(node);
          }
          return builder;
        }
        /**
         * @param {Node} node
         */
        static _collapse(node) {
          if (typeof node === "string") return;
          if (!node.children) return;
          if (node.children.every((el) => typeof el === "string")) {
            node.children = [node.children.join("")];
          } else {
            node.children.forEach((child) => {
              _TokenTree._collapse(child);
            });
          }
        }
      };
      var TokenTreeEmitter = class extends TokenTree {
        /**
         * @param {*} options
         */
        constructor(options) {
          super();
          this.options = options;
        }
        /**
         * @param {string} text
         */
        addText(text) {
          if (text === "") {
            return;
          }
          this.add(text);
        }
        /** @param {string} scope */
        startScope(scope) {
          this.openNode(scope);
        }
        endScope() {
          this.closeNode();
        }
        /**
         * @param {Emitter & {root: DataNode}} emitter
         * @param {string} name
         */
        __addSublanguage(emitter, name) {
          const node = emitter.root;
          if (name) node.scope = `language:${name}`;
          this.add(node);
        }
        toHTML() {
          const renderer = new HTMLRenderer(this, this.options);
          return renderer.value();
        }
        finalize() {
          this.closeAllNodes();
          return true;
        }
      };
      function source(re) {
        if (!re) return null;
        if (typeof re === "string") return re;
        return re.source;
      }
      function lookahead(re) {
        return concat("(?=", re, ")");
      }
      function anyNumberOfTimes(re) {
        return concat("(?:", re, ")*");
      }
      function optional(re) {
        return concat("(?:", re, ")?");
      }
      function concat(...args) {
        const joined = args.map((x) => source(x)).join("");
        return joined;
      }
      function stripOptionsFromArgs(args) {
        const opts = args[args.length - 1];
        if (typeof opts === "object" && opts.constructor === Object) {
          args.splice(args.length - 1, 1);
          return opts;
        } else {
          return {};
        }
      }
      function either(...args) {
        const opts = stripOptionsFromArgs(args);
        const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
        return joined;
      }
      function countMatchGroups(re) {
        return new RegExp(re.toString() + "|").exec("").length - 1;
      }
      function startsWith(re, lexeme) {
        const match = re && re.exec(lexeme);
        return match && match.index === 0;
      }
      var BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function _rewriteBackreferences(regexps, { joinWith }) {
        let numCaptures = 0;
        return regexps.map((regex) => {
          numCaptures += 1;
          const offset2 = numCaptures;
          let re = source(regex);
          let out = "";
          while (re.length > 0) {
            const match = BACKREF_RE.exec(re);
            if (!match) {
              out += re;
              break;
            }
            out += re.substring(0, match.index);
            re = re.substring(match.index + match[0].length);
            if (match[0][0] === "\\" && match[1]) {
              out += "\\" + String(Number(match[1]) + offset2);
            } else {
              out += match[0];
              if (match[0] === "(") {
                numCaptures++;
              }
            }
          }
          return out;
        }).map((re) => `(${re})`).join(joinWith);
      }
      var MATCH_NOTHING_RE = /\b\B/;
      var IDENT_RE2 = "[a-zA-Z]\\w*";
      var UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
      var NUMBER_RE = "\\b\\d+(\\.\\d+)?";
      var C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
      var BINARY_NUMBER_RE = "\\b(0b[01]+)";
      var RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
      var SHEBANG = (opts = {}) => {
        const beginShebang = /^#![ ]*\//;
        if (opts.binary) {
          opts.begin = concat(
            beginShebang,
            /.*\b/,
            opts.binary,
            /\b.*/
          );
        }
        return inherit$1({
          scope: "meta",
          begin: beginShebang,
          end: /$/,
          relevance: 0,
          /** @type {ModeCallback} */
          "on:begin": (m, resp) => {
            if (m.index !== 0) resp.ignoreMatch();
          }
        }, opts);
      };
      var BACKSLASH_ESCAPE = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      };
      var APOS_STRING_MODE = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      };
      var QUOTE_STRING_MODE = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      };
      var PHRASAL_WORDS_MODE = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      };
      var COMMENT = function(begin, end, modeOptions = {}) {
        const mode = inherit$1(
          {
            scope: "comment",
            begin,
            end,
            contains: []
          },
          modeOptions
        );
        mode.contains.push({
          scope: "doctag",
          // hack to avoid the space from being included. the space is necessary to
          // match here to prevent the plain text rule below from gobbling up doctags
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const ENGLISH_WORD = either(
          // list of common 1 and 2 letter words in English
          "I",
          "a",
          "is",
          "so",
          "us",
          "to",
          "at",
          "if",
          "in",
          "it",
          "on",
          // note: this is not an exhaustive list of contractions, just popular ones
          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
          // contractions - can't we'd they're let's, etc
          /[A-Za-z]+[-][a-z]+/,
          // `no-way`, etc.
          /[A-Za-z][a-z]{2,}/
          // allow capitalized words at beginning of sentences
        );
        mode.contains.push(
          {
            // TODO: how to include ", (, ) without breaking grammars that use these for
            // comment delimiters?
            // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
            // ---
            // this tries to find sequences of 3 english words in a row (without any
            // "programming" type syntax) this gives us a strong signal that we've
            // TRULY found a comment - vs perhaps scanning with the wrong language.
            // It's possible to find something that LOOKS like the start of the
            // comment - but then if there is no readable text - good chance it is a
            // false match and not a comment.
            //
            // for a visual example please see:
            // https://github.com/highlightjs/highlight.js/issues/2827
            begin: concat(
              /[ ]+/,
              // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
              "(",
              ENGLISH_WORD,
              /[.]?[:]?([.][ ]|[ ])/,
              "){3}"
            )
            // look for 3 words in a row
          }
        );
        return mode;
      };
      var C_LINE_COMMENT_MODE = COMMENT("//", "$");
      var C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
      var HASH_COMMENT_MODE = COMMENT("#", "$");
      var NUMBER_MODE = {
        scope: "number",
        begin: NUMBER_RE,
        relevance: 0
      };
      var C_NUMBER_MODE = {
        scope: "number",
        begin: C_NUMBER_RE,
        relevance: 0
      };
      var BINARY_NUMBER_MODE = {
        scope: "number",
        begin: BINARY_NUMBER_RE,
        relevance: 0
      };
      var REGEXP_MODE = {
        scope: "regexp",
        begin: /\/(?=[^/\n]*\/)/,
        end: /\/[gimuy]*/,
        contains: [
          BACKSLASH_ESCAPE,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [BACKSLASH_ESCAPE]
          }
        ]
      };
      var TITLE_MODE = {
        scope: "title",
        begin: IDENT_RE2,
        relevance: 0
      };
      var UNDERSCORE_TITLE_MODE = {
        scope: "title",
        begin: UNDERSCORE_IDENT_RE,
        relevance: 0
      };
      var METHOD_GUARD = {
        // excludes method names from keyword processing
        begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
        relevance: 0
      };
      var END_SAME_AS_BEGIN = function(mode) {
        return Object.assign(
          mode,
          {
            /** @type {ModeCallback} */
            "on:begin": (m, resp) => {
              resp.data._beginMatch = m[1];
            },
            /** @type {ModeCallback} */
            "on:end": (m, resp) => {
              if (resp.data._beginMatch !== m[1]) resp.ignoreMatch();
            }
          }
        );
      };
      var MODES = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        APOS_STRING_MODE,
        BACKSLASH_ESCAPE,
        BINARY_NUMBER_MODE,
        BINARY_NUMBER_RE,
        COMMENT,
        C_BLOCK_COMMENT_MODE,
        C_LINE_COMMENT_MODE,
        C_NUMBER_MODE,
        C_NUMBER_RE,
        END_SAME_AS_BEGIN,
        HASH_COMMENT_MODE,
        IDENT_RE: IDENT_RE2,
        MATCH_NOTHING_RE,
        METHOD_GUARD,
        NUMBER_MODE,
        NUMBER_RE,
        PHRASAL_WORDS_MODE,
        QUOTE_STRING_MODE,
        REGEXP_MODE,
        RE_STARTERS_RE,
        SHEBANG,
        TITLE_MODE,
        UNDERSCORE_IDENT_RE,
        UNDERSCORE_TITLE_MODE
      });
      function skipIfHasPrecedingDot(match, response) {
        const before = match.input[match.index - 1];
        if (before === ".") {
          response.ignoreMatch();
        }
      }
      function scopeClassName(mode, _parent) {
        if (mode.className !== void 0) {
          mode.scope = mode.className;
          delete mode.className;
        }
      }
      function beginKeywords(mode, parent) {
        if (!parent) return;
        if (!mode.beginKeywords) return;
        mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
        mode.__beforeBegin = skipIfHasPrecedingDot;
        mode.keywords = mode.keywords || mode.beginKeywords;
        delete mode.beginKeywords;
        if (mode.relevance === void 0) mode.relevance = 0;
      }
      function compileIllegal(mode, _parent) {
        if (!Array.isArray(mode.illegal)) return;
        mode.illegal = either(...mode.illegal);
      }
      function compileMatch(mode, _parent) {
        if (!mode.match) return;
        if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");
        mode.begin = mode.match;
        delete mode.match;
      }
      function compileRelevance(mode, _parent) {
        if (mode.relevance === void 0) mode.relevance = 1;
      }
      var beforeMatchExt = (mode, parent) => {
        if (!mode.beforeMatch) return;
        if (mode.starts) throw new Error("beforeMatch cannot be used with starts");
        const originalMode = Object.assign({}, mode);
        Object.keys(mode).forEach((key) => {
          delete mode[key];
        });
        mode.keywords = originalMode.keywords;
        mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
        mode.starts = {
          relevance: 0,
          contains: [
            Object.assign(originalMode, { endsParent: true })
          ]
        };
        mode.relevance = 0;
        delete originalMode.beforeMatch;
      };
      var COMMON_KEYWORDS = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        // common variable name
        "list",
        // common variable name
        "value"
        // common variable name
      ];
      var DEFAULT_KEYWORD_SCOPE = "keyword";
      function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
        const compiledKeywords = /* @__PURE__ */ Object.create(null);
        if (typeof rawKeywords === "string") {
          compileList(scopeName, rawKeywords.split(" "));
        } else if (Array.isArray(rawKeywords)) {
          compileList(scopeName, rawKeywords);
        } else {
          Object.keys(rawKeywords).forEach(function(scopeName2) {
            Object.assign(
              compiledKeywords,
              compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
            );
          });
        }
        return compiledKeywords;
        function compileList(scopeName2, keywordList) {
          if (caseInsensitive) {
            keywordList = keywordList.map((x) => x.toLowerCase());
          }
          keywordList.forEach(function(keyword) {
            const pair = keyword.split("|");
            compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
          });
        }
      }
      function scoreForKeyword(keyword, providedScore) {
        if (providedScore) {
          return Number(providedScore);
        }
        return commonKeyword(keyword) ? 0 : 1;
      }
      function commonKeyword(keyword) {
        return COMMON_KEYWORDS.includes(keyword.toLowerCase());
      }
      var seenDeprecations = {};
      var error = (message) => {
        console.error(message);
      };
      var warn = (message, ...args) => {
        console.log(`WARN: ${message}`, ...args);
      };
      var deprecated = (version2, message) => {
        if (seenDeprecations[`${version2}/${message}`]) return;
        console.log(`Deprecated as of ${version2}. ${message}`);
        seenDeprecations[`${version2}/${message}`] = true;
      };
      var MultiClassError = new Error();
      function remapScopeNames(mode, regexes, { key }) {
        let offset2 = 0;
        const scopeNames = mode[key];
        const emit = {};
        const positions = {};
        for (let i = 1; i <= regexes.length; i++) {
          positions[i + offset2] = scopeNames[i];
          emit[i + offset2] = true;
          offset2 += countMatchGroups(regexes[i - 1]);
        }
        mode[key] = positions;
        mode[key]._emit = emit;
        mode[key]._multi = true;
      }
      function beginMultiClass(mode) {
        if (!Array.isArray(mode.begin)) return;
        if (mode.skip || mode.excludeBegin || mode.returnBegin) {
          error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
          throw MultiClassError;
        }
        if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
          error("beginScope must be object");
          throw MultiClassError;
        }
        remapScopeNames(mode, mode.begin, { key: "beginScope" });
        mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
      }
      function endMultiClass(mode) {
        if (!Array.isArray(mode.end)) return;
        if (mode.skip || mode.excludeEnd || mode.returnEnd) {
          error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
          throw MultiClassError;
        }
        if (typeof mode.endScope !== "object" || mode.endScope === null) {
          error("endScope must be object");
          throw MultiClassError;
        }
        remapScopeNames(mode, mode.end, { key: "endScope" });
        mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
      }
      function scopeSugar(mode) {
        if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
          mode.beginScope = mode.scope;
          delete mode.scope;
        }
      }
      function MultiClass(mode) {
        scopeSugar(mode);
        if (typeof mode.beginScope === "string") {
          mode.beginScope = { _wrap: mode.beginScope };
        }
        if (typeof mode.endScope === "string") {
          mode.endScope = { _wrap: mode.endScope };
        }
        beginMultiClass(mode);
        endMultiClass(mode);
      }
      function compileLanguage(language) {
        function langRe(value, global) {
          return new RegExp(
            source(value),
            "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global ? "g" : "")
          );
        }
        class MultiRegex {
          constructor() {
            this.matchIndexes = {};
            this.regexes = [];
            this.matchAt = 1;
            this.position = 0;
          }
          // @ts-ignore
          addRule(re, opts) {
            opts.position = this.position++;
            this.matchIndexes[this.matchAt] = opts;
            this.regexes.push([opts, re]);
            this.matchAt += countMatchGroups(re) + 1;
          }
          compile() {
            if (this.regexes.length === 0) {
              this.exec = () => null;
            }
            const terminators = this.regexes.map((el) => el[1]);
            this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
            this.lastIndex = 0;
          }
          /** @param {string} s */
          exec(s) {
            this.matcherRe.lastIndex = this.lastIndex;
            const match = this.matcherRe.exec(s);
            if (!match) {
              return null;
            }
            const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
            const matchData = this.matchIndexes[i];
            match.splice(0, i);
            return Object.assign(match, matchData);
          }
        }
        class ResumableMultiRegex {
          constructor() {
            this.rules = [];
            this.multiRegexes = [];
            this.count = 0;
            this.lastIndex = 0;
            this.regexIndex = 0;
          }
          // @ts-ignore
          getMatcher(index) {
            if (this.multiRegexes[index]) return this.multiRegexes[index];
            const matcher = new MultiRegex();
            this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
            matcher.compile();
            this.multiRegexes[index] = matcher;
            return matcher;
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          // @ts-ignore
          addRule(re, opts) {
            this.rules.push([re, opts]);
            if (opts.type === "begin") this.count++;
          }
          /** @param {string} s */
          exec(s) {
            const m = this.getMatcher(this.regexIndex);
            m.lastIndex = this.lastIndex;
            let result = m.exec(s);
            if (this.resumingScanAtSamePosition()) {
              if (result && result.index === this.lastIndex) ;
              else {
                const m2 = this.getMatcher(0);
                m2.lastIndex = this.lastIndex + 1;
                result = m2.exec(s);
              }
            }
            if (result) {
              this.regexIndex += result.position + 1;
              if (this.regexIndex === this.count) {
                this.considerAll();
              }
            }
            return result;
          }
        }
        function buildModeRegex(mode) {
          const mm = new ResumableMultiRegex();
          mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
          if (mode.terminatorEnd) {
            mm.addRule(mode.terminatorEnd, { type: "end" });
          }
          if (mode.illegal) {
            mm.addRule(mode.illegal, { type: "illegal" });
          }
          return mm;
        }
        function compileMode(mode, parent) {
          const cmode = (
            /** @type CompiledMode */
            mode
          );
          if (mode.isCompiled) return cmode;
          [
            scopeClassName,
            // do this early so compiler extensions generally don't have to worry about
            // the distinction between match/begin
            compileMatch,
            MultiClass,
            beforeMatchExt
          ].forEach((ext) => ext(mode, parent));
          language.compilerExtensions.forEach((ext) => ext(mode, parent));
          mode.__beforeBegin = null;
          [
            beginKeywords,
            // do this later so compiler extensions that come earlier have access to the
            // raw array if they wanted to perhaps manipulate it, etc.
            compileIllegal,
            // default to 1 relevance if not specified
            compileRelevance
          ].forEach((ext) => ext(mode, parent));
          mode.isCompiled = true;
          let keywordPattern = null;
          if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
            mode.keywords = Object.assign({}, mode.keywords);
            keywordPattern = mode.keywords.$pattern;
            delete mode.keywords.$pattern;
          }
          keywordPattern = keywordPattern || /\w+/;
          if (mode.keywords) {
            mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
          }
          cmode.keywordPatternRe = langRe(keywordPattern, true);
          if (parent) {
            if (!mode.begin) mode.begin = /\B|\b/;
            cmode.beginRe = langRe(cmode.begin);
            if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
            if (mode.end) cmode.endRe = langRe(cmode.end);
            cmode.terminatorEnd = source(cmode.end) || "";
            if (mode.endsWithParent && parent.terminatorEnd) {
              cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
            }
          }
          if (mode.illegal) cmode.illegalRe = langRe(
            /** @type {RegExp | string} */
            mode.illegal
          );
          if (!mode.contains) mode.contains = [];
          mode.contains = [].concat(...mode.contains.map(function(c) {
            return expandOrCloneMode(c === "self" ? mode : c);
          }));
          mode.contains.forEach(function(c) {
            compileMode(
              /** @type Mode */
              c,
              cmode
            );
          });
          if (mode.starts) {
            compileMode(mode.starts, parent);
          }
          cmode.matcher = buildModeRegex(cmode);
          return cmode;
        }
        if (!language.compilerExtensions) language.compilerExtensions = [];
        if (language.contains && language.contains.includes("self")) {
          throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        }
        language.classNameAliases = inherit$1(language.classNameAliases || {});
        return compileMode(
          /** @type Mode */
          language
        );
      }
      function dependencyOnParent(mode) {
        if (!mode) return false;
        return mode.endsWithParent || dependencyOnParent(mode.starts);
      }
      function expandOrCloneMode(mode) {
        if (mode.variants && !mode.cachedVariants) {
          mode.cachedVariants = mode.variants.map(function(variant) {
            return inherit$1(mode, { variants: null }, variant);
          });
        }
        if (mode.cachedVariants) {
          return mode.cachedVariants;
        }
        if (dependencyOnParent(mode)) {
          return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
        }
        if (Object.isFrozen(mode)) {
          return inherit$1(mode);
        }
        return mode;
      }
      var version = "11.11.1";
      var HTMLInjectionError = class extends Error {
        constructor(reason, html) {
          super(reason);
          this.name = "HTMLInjectionError";
          this.html = html;
        }
      };
      var escape = escapeHTML;
      var inherit = inherit$1;
      var NO_MATCH = Symbol("nomatch");
      var MAX_KEYWORD_HITS = 7;
      var HLJS = function(hljs) {
        const languages = /* @__PURE__ */ Object.create(null);
        const aliases = /* @__PURE__ */ Object.create(null);
        const plugins = [];
        let SAFE_MODE = true;
        const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
        const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
        let options = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          // beta configuration options, subject to change, welcome to discuss
          // https://github.com/highlightjs/highlight.js/issues/1086
          __emitter: TokenTreeEmitter
        };
        function shouldNotHighlight(languageName) {
          return options.noHighlightRe.test(languageName);
        }
        function blockLanguage(block) {
          let classes = block.className + " ";
          classes += block.parentNode ? block.parentNode.className : "";
          const match = options.languageDetectRe.exec(classes);
          if (match) {
            const language = getLanguage(match[1]);
            if (!language) {
              warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
              warn("Falling back to no-highlight mode for this block.", block);
            }
            return language ? match[1] : "no-highlight";
          }
          return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
        }
        function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
          let code = "";
          let languageName = "";
          if (typeof optionsOrCode === "object") {
            code = codeOrLanguageName;
            ignoreIllegals = optionsOrCode.ignoreIllegals;
            languageName = optionsOrCode.language;
          } else {
            deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
            deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
            languageName = codeOrLanguageName;
            code = optionsOrCode;
          }
          if (ignoreIllegals === void 0) {
            ignoreIllegals = true;
          }
          const context = {
            code,
            language: languageName
          };
          fire4("before:highlight", context);
          const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
          result.code = context.code;
          fire4("after:highlight", result);
          return result;
        }
        function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
          const keywordHits = /* @__PURE__ */ Object.create(null);
          function keywordData(mode, matchText) {
            return mode.keywords[matchText];
          }
          function processKeywords() {
            if (!top.keywords) {
              emitter.addText(modeBuffer);
              return;
            }
            let lastIndex = 0;
            top.keywordPatternRe.lastIndex = 0;
            let match = top.keywordPatternRe.exec(modeBuffer);
            let buf = "";
            while (match) {
              buf += modeBuffer.substring(lastIndex, match.index);
              const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
              const data = keywordData(top, word);
              if (data) {
                const [kind, keywordRelevance] = data;
                emitter.addText(buf);
                buf = "";
                keywordHits[word] = (keywordHits[word] || 0) + 1;
                if (keywordHits[word] <= MAX_KEYWORD_HITS) relevance += keywordRelevance;
                if (kind.startsWith("_")) {
                  buf += match[0];
                } else {
                  const cssClass = language.classNameAliases[kind] || kind;
                  emitKeyword(match[0], cssClass);
                }
              } else {
                buf += match[0];
              }
              lastIndex = top.keywordPatternRe.lastIndex;
              match = top.keywordPatternRe.exec(modeBuffer);
            }
            buf += modeBuffer.substring(lastIndex);
            emitter.addText(buf);
          }
          function processSubLanguage() {
            if (modeBuffer === "") return;
            let result2 = null;
            if (typeof top.subLanguage === "string") {
              if (!languages[top.subLanguage]) {
                emitter.addText(modeBuffer);
                return;
              }
              result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
              continuations[top.subLanguage] = /** @type {CompiledMode} */
              result2._top;
            } else {
              result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
            }
            if (top.relevance > 0) {
              relevance += result2.relevance;
            }
            emitter.__addSublanguage(result2._emitter, result2.language);
          }
          function processBuffer() {
            if (top.subLanguage != null) {
              processSubLanguage();
            } else {
              processKeywords();
            }
            modeBuffer = "";
          }
          function emitKeyword(keyword, scope) {
            if (keyword === "") return;
            emitter.startScope(scope);
            emitter.addText(keyword);
            emitter.endScope();
          }
          function emitMultiClass(scope, match) {
            let i = 1;
            const max2 = match.length - 1;
            while (i <= max2) {
              if (!scope._emit[i]) {
                i++;
                continue;
              }
              const klass = language.classNameAliases[scope[i]] || scope[i];
              const text = match[i];
              if (klass) {
                emitKeyword(text, klass);
              } else {
                modeBuffer = text;
                processKeywords();
                modeBuffer = "";
              }
              i++;
            }
          }
          function startNewMode(mode, match) {
            if (mode.scope && typeof mode.scope === "string") {
              emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
            }
            if (mode.beginScope) {
              if (mode.beginScope._wrap) {
                emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
                modeBuffer = "";
              } else if (mode.beginScope._multi) {
                emitMultiClass(mode.beginScope, match);
                modeBuffer = "";
              }
            }
            top = Object.create(mode, { parent: { value: top } });
            return top;
          }
          function endOfMode(mode, match, matchPlusRemainder) {
            let matched = startsWith(mode.endRe, matchPlusRemainder);
            if (matched) {
              if (mode["on:end"]) {
                const resp = new Response(mode);
                mode["on:end"](match, resp);
                if (resp.isMatchIgnored) matched = false;
              }
              if (matched) {
                while (mode.endsParent && mode.parent) {
                  mode = mode.parent;
                }
                return mode;
              }
            }
            if (mode.endsWithParent) {
              return endOfMode(mode.parent, match, matchPlusRemainder);
            }
          }
          function doIgnore(lexeme) {
            if (top.matcher.regexIndex === 0) {
              modeBuffer += lexeme[0];
              return 1;
            } else {
              resumeScanAtSamePosition = true;
              return 0;
            }
          }
          function doBeginMatch(match) {
            const lexeme = match[0];
            const newMode = match.rule;
            const resp = new Response(newMode);
            const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
            for (const cb of beforeCallbacks) {
              if (!cb) continue;
              cb(match, resp);
              if (resp.isMatchIgnored) return doIgnore(lexeme);
            }
            if (newMode.skip) {
              modeBuffer += lexeme;
            } else {
              if (newMode.excludeBegin) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (!newMode.returnBegin && !newMode.excludeBegin) {
                modeBuffer = lexeme;
              }
            }
            startNewMode(newMode, match);
            return newMode.returnBegin ? 0 : lexeme.length;
          }
          function doEndMatch(match) {
            const lexeme = match[0];
            const matchPlusRemainder = codeToHighlight.substring(match.index);
            const endMode = endOfMode(top, match, matchPlusRemainder);
            if (!endMode) {
              return NO_MATCH;
            }
            const origin = top;
            if (top.endScope && top.endScope._wrap) {
              processBuffer();
              emitKeyword(lexeme, top.endScope._wrap);
            } else if (top.endScope && top.endScope._multi) {
              processBuffer();
              emitMultiClass(top.endScope, match);
            } else if (origin.skip) {
              modeBuffer += lexeme;
            } else {
              if (!(origin.returnEnd || origin.excludeEnd)) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (origin.excludeEnd) {
                modeBuffer = lexeme;
              }
            }
            do {
              if (top.scope) {
                emitter.closeNode();
              }
              if (!top.skip && !top.subLanguage) {
                relevance += top.relevance;
              }
              top = top.parent;
            } while (top !== endMode.parent);
            if (endMode.starts) {
              startNewMode(endMode.starts, match);
            }
            return origin.returnEnd ? 0 : lexeme.length;
          }
          function processContinuations() {
            const list = [];
            for (let current = top; current !== language; current = current.parent) {
              if (current.scope) {
                list.unshift(current.scope);
              }
            }
            list.forEach((item) => emitter.openNode(item));
          }
          let lastMatch = {};
          function processLexeme(textBeforeMatch, match) {
            const lexeme = match && match[0];
            modeBuffer += textBeforeMatch;
            if (lexeme == null) {
              processBuffer();
              return 0;
            }
            if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
              modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
              if (!SAFE_MODE) {
                const err = new Error(`0 width match regex (${languageName})`);
                err.languageName = languageName;
                err.badRule = lastMatch.rule;
                throw err;
              }
              return 1;
            }
            lastMatch = match;
            if (match.type === "begin") {
              return doBeginMatch(match);
            } else if (match.type === "illegal" && !ignoreIllegals) {
              const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
              err.mode = top;
              throw err;
            } else if (match.type === "end") {
              const processed = doEndMatch(match);
              if (processed !== NO_MATCH) {
                return processed;
              }
            }
            if (match.type === "illegal" && lexeme === "") {
              modeBuffer += "\n";
              return 1;
            }
            if (iterations > 1e5 && iterations > match.index * 3) {
              const err = new Error("potential infinite loop, way more iterations than matches");
              throw err;
            }
            modeBuffer += lexeme;
            return lexeme.length;
          }
          const language = getLanguage(languageName);
          if (!language) {
            error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
            throw new Error('Unknown language: "' + languageName + '"');
          }
          const md = compileLanguage(language);
          let result = "";
          let top = continuation || md;
          const continuations = {};
          const emitter = new options.__emitter(options);
          processContinuations();
          let modeBuffer = "";
          let relevance = 0;
          let index = 0;
          let iterations = 0;
          let resumeScanAtSamePosition = false;
          try {
            if (!language.__emitTokens) {
              top.matcher.considerAll();
              for (; ; ) {
                iterations++;
                if (resumeScanAtSamePosition) {
                  resumeScanAtSamePosition = false;
                } else {
                  top.matcher.considerAll();
                }
                top.matcher.lastIndex = index;
                const match = top.matcher.exec(codeToHighlight);
                if (!match) break;
                const beforeMatch = codeToHighlight.substring(index, match.index);
                const processedCount = processLexeme(beforeMatch, match);
                index = match.index + processedCount;
              }
              processLexeme(codeToHighlight.substring(index));
            } else {
              language.__emitTokens(codeToHighlight, emitter);
            }
            emitter.finalize();
            result = emitter.toHTML();
            return {
              language: languageName,
              value: result,
              relevance,
              illegal: false,
              _emitter: emitter,
              _top: top
            };
          } catch (err) {
            if (err.message && err.message.includes("Illegal")) {
              return {
                language: languageName,
                value: escape(codeToHighlight),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: err.message,
                  index,
                  context: codeToHighlight.slice(index - 100, index + 100),
                  mode: err.mode,
                  resultSoFar: result
                },
                _emitter: emitter
              };
            } else if (SAFE_MODE) {
              return {
                language: languageName,
                value: escape(codeToHighlight),
                illegal: false,
                relevance: 0,
                errorRaised: err,
                _emitter: emitter,
                _top: top
              };
            } else {
              throw err;
            }
          }
        }
        function justTextHighlightResult(code) {
          const result = {
            value: escape(code),
            illegal: false,
            relevance: 0,
            _top: PLAINTEXT_LANGUAGE,
            _emitter: new options.__emitter(options)
          };
          result._emitter.addText(code);
          return result;
        }
        function highlightAuto(code, languageSubset) {
          languageSubset = languageSubset || options.languages || Object.keys(languages);
          const plaintext = justTextHighlightResult(code);
          const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
            (name) => _highlight(name, code, false)
          );
          results.unshift(plaintext);
          const sorted = results.sort((a, b) => {
            if (a.relevance !== b.relevance) return b.relevance - a.relevance;
            if (a.language && b.language) {
              if (getLanguage(a.language).supersetOf === b.language) {
                return 1;
              } else if (getLanguage(b.language).supersetOf === a.language) {
                return -1;
              }
            }
            return 0;
          });
          const [best, secondBest] = sorted;
          const result = best;
          result.secondBest = secondBest;
          return result;
        }
        function updateClassName(element, currentLang, resultLang) {
          const language = currentLang && aliases[currentLang] || resultLang;
          element.classList.add("hljs");
          element.classList.add(`language-${language}`);
        }
        function highlightElement(element) {
          let node = null;
          const language = blockLanguage(element);
          if (shouldNotHighlight(language)) return;
          fire4(
            "before:highlightElement",
            { el: element, language }
          );
          if (element.dataset.highlighted) {
            console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", element);
            return;
          }
          if (element.children.length > 0) {
            if (!options.ignoreUnescapedHTML) {
              console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
              console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
              console.warn("The element with unescaped HTML:");
              console.warn(element);
            }
            if (options.throwUnescapedHTML) {
              const err = new HTMLInjectionError(
                "One of your code blocks includes unescaped HTML.",
                element.innerHTML
              );
              throw err;
            }
          }
          node = element;
          const text = node.textContent;
          const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
          element.innerHTML = result.value;
          element.dataset.highlighted = "yes";
          updateClassName(element, language, result.language);
          element.result = {
            language: result.language,
            // TODO: remove with version 11.0
            re: result.relevance,
            relevance: result.relevance
          };
          if (result.secondBest) {
            element.secondBest = {
              language: result.secondBest.language,
              relevance: result.secondBest.relevance
            };
          }
          fire4("after:highlightElement", { el: element, result, text });
        }
        function configure(userOptions) {
          options = inherit(options, userOptions);
        }
        const initHighlighting = () => {
          highlightAll();
          deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        };
        function initHighlightingOnLoad() {
          highlightAll();
          deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        }
        let wantsHighlight = false;
        function highlightAll() {
          function boot() {
            highlightAll();
          }
          if (document.readyState === "loading") {
            if (!wantsHighlight) {
              window.addEventListener("DOMContentLoaded", boot, false);
            }
            wantsHighlight = true;
            return;
          }
          const blocks = document.querySelectorAll(options.cssSelector);
          blocks.forEach(highlightElement);
        }
        function registerLanguage(languageName, languageDefinition) {
          let lang = null;
          try {
            lang = languageDefinition(hljs);
          } catch (error$1) {
            error("Language definition for '{}' could not be registered.".replace("{}", languageName));
            if (!SAFE_MODE) {
              throw error$1;
            } else {
              error(error$1);
            }
            lang = PLAINTEXT_LANGUAGE;
          }
          if (!lang.name) lang.name = languageName;
          languages[languageName] = lang;
          lang.rawDefinition = languageDefinition.bind(null, hljs);
          if (lang.aliases) {
            registerAliases(lang.aliases, { languageName });
          }
        }
        function unregisterLanguage(languageName) {
          delete languages[languageName];
          for (const alias of Object.keys(aliases)) {
            if (aliases[alias] === languageName) {
              delete aliases[alias];
            }
          }
        }
        function listLanguages() {
          return Object.keys(languages);
        }
        function getLanguage(name) {
          name = (name || "").toLowerCase();
          return languages[name] || languages[aliases[name]];
        }
        function registerAliases(aliasList, { languageName }) {
          if (typeof aliasList === "string") {
            aliasList = [aliasList];
          }
          aliasList.forEach((alias) => {
            aliases[alias.toLowerCase()] = languageName;
          });
        }
        function autoDetection(name) {
          const lang = getLanguage(name);
          return lang && !lang.disableAutodetect;
        }
        function upgradePluginAPI(plugin) {
          if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
            plugin["before:highlightElement"] = (data) => {
              plugin["before:highlightBlock"](
                Object.assign({ block: data.el }, data)
              );
            };
          }
          if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
            plugin["after:highlightElement"] = (data) => {
              plugin["after:highlightBlock"](
                Object.assign({ block: data.el }, data)
              );
            };
          }
        }
        function addPlugin(plugin) {
          upgradePluginAPI(plugin);
          plugins.push(plugin);
        }
        function removePlugin(plugin) {
          const index = plugins.indexOf(plugin);
          if (index !== -1) {
            plugins.splice(index, 1);
          }
        }
        function fire4(event, args) {
          const cb = event;
          plugins.forEach(function(plugin) {
            if (plugin[cb]) {
              plugin[cb](args);
            }
          });
        }
        function deprecateHighlightBlock(el) {
          deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
          deprecated("10.7.0", "Please use highlightElement now.");
          return highlightElement(el);
        }
        Object.assign(hljs, {
          highlight: highlight2,
          highlightAuto,
          highlightAll,
          highlightElement,
          // TODO: Remove with v12 API
          highlightBlock: deprecateHighlightBlock,
          configure,
          initHighlighting,
          initHighlightingOnLoad,
          registerLanguage,
          unregisterLanguage,
          listLanguages,
          getLanguage,
          registerAliases,
          autoDetection,
          inherit,
          addPlugin,
          removePlugin
        });
        hljs.debugMode = function() {
          SAFE_MODE = false;
        };
        hljs.safeMode = function() {
          SAFE_MODE = true;
        };
        hljs.versionString = version;
        hljs.regex = {
          concat,
          lookahead,
          either,
          optional,
          anyNumberOfTimes
        };
        for (const key in MODES) {
          if (typeof MODES[key] === "object") {
            deepFreeze(MODES[key]);
          }
        }
        Object.assign(hljs, MODES);
        return hljs;
      };
      var highlight = HLJS({});
      highlight.newInstance = () => HLJS({});
      module.exports = highlight;
      highlight.HighlightJS = highlight;
      highlight.default = highlight;
    }
  });

  // src/js/mob/mob-core/modules.js
  var modules_exports = {};
  __export(modules_exports, {
    ANIMATION_STOP_REJECT: () => ANIMATION_STOP_REJECT,
    checkType: () => checkType,
    createStore: () => createStore,
    getFps: () => getFps,
    getInstantFps: () => getInstantFps,
    getTime: () => getTime,
    getTypeName: () => getTypeName,
    getUnivoqueId: () => getUnivoqueId,
    mustMakeSomething: () => mustMakeSomething,
    normalizeWheel: () => normalizeWheel,
    shouldMakeSomething: () => shouldMakeSomething,
    store: () => store,
    useCache: () => useCache,
    useDebounce: () => debounceFuncion,
    useFps: () => useFps,
    useFrame: () => useFrame,
    useFrameIndex: () => useFrameIndex,
    useLoad: () => useLoad,
    useMouseClick: () => useMouseClick,
    useMouseDown: () => useMouseDown,
    useMouseMove: () => useMouseMove,
    useMouseUp: () => useMouseUp,
    useMouseWheel: () => useMouseWheel,
    useNextFrame: () => useNextFrame,
    useNextLoop: () => useNextLoop,
    useNextTick: () => useNextTick,
    usePointerDown: () => usePointerDown,
    usePointerLeave: () => usePointerLeave,
    usePointerMove: () => usePointerMove,
    usePointerOut: () => usePointerOut,
    usePointerOver: () => usePointerOver,
    usePointerUp: () => usePointerUp,
    useResize: () => useResize,
    useScroll: () => useScroll,
    useScrollEnd: () => useScrollEnd,
    useScrollImmediate: () => useScrollImmediate,
    useScrollStart: () => useScrollStart,
    useScrollThrottle: () => useScrollThrottle,
    useTouchEnd: () => useTouchEnd,
    useTouchMove: () => useTouchMove,
    useTouchStart: () => useTouchStart,
    useVisibilityChange: () => useVisibilityChange
  });

  // src/js/mob/mob-core/utils/index.js
  function outerHeight(element) {
    if (!element) return 0;
    let height = element.offsetHeight;
    const style = getComputedStyle(element);
    height += Number.parseInt(style.marginTop) + Number.parseInt(style.marginBottom);
    return height;
  }
  function outerWidth(element) {
    if (!element) return 0;
    let width = element.offsetWidth;
    const style = getComputedStyle(element);
    width += Number.parseInt(style.marginLeft) + Number.parseInt(style.marginRight);
    return width;
  }
  function offset(element) {
    if (!element)
      return {
        top: 0,
        left: 0
      };
    const rect = element.getBoundingClientRect();
    const offset2 = {
      top: rect.top + window.scrollY,
      left: rect.left + window.scrollY
    };
    return offset2;
  }
  function position(element) {
    if (!element)
      return {
        bottom: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        width: 0,
        x: 0,
        y: 0
      };
    const rect = element.getBoundingClientRect();
    return rect;
  }
  function isDescendant(parent, child) {
    let node = child?.parentNode;
    while (node) {
      if (node === parent) return true;
      node = node?.parentNode;
    }
    return false;
  }
  function getTranslateValues(element) {
    const style = globalThis.getComputedStyle(element);
    const matrix = (
      // @ts-ignore
      style["transform"] || style.mozTransform
    );
    if (matrix === "none" || matrix === void 0) {
      return {
        x: 0,
        y: 0,
        z: 0
      };
    }
    const matrixType = matrix.includes("3d") ? "3d" : "2d";
    const matrixValues = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
    if (matrixType === "2d") {
      return {
        x: matrixValues[4],
        y: matrixValues[5],
        z: 0
      };
    }
    if (matrixType === "3d") {
      return {
        x: matrixValues[12],
        y: matrixValues[13],
        z: matrixValues[14]
      };
    }
  }
  function isNode(element) {
    return typeof Node === "object" ? element instanceof Node : element && typeof element === "object" && typeof element.nodeType === "number" && typeof element.nodeName === "string";
  }
  var getUnivoqueId = () => {
    return `_${Math.random().toString(36).slice(2, 9)}`;
  };
  function isVisibleInViewportSmart(element) {
    var rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.bottom <= window.innerHeight;
  }
  var clamp = (num, lower, upper) => {
    return Math.min(Math.max(num, lower), upper);
  };

  // src/js/mob/mob-core/utils/next-tick.js
  var setTimeOutQueque = /* @__PURE__ */ new Set();
  var useNextLoop = (fn) => {
    setTimeOutQueque.add(fn);
    if (setTimeOutQueque.size === 1) {
      setTimeout(() => {
        setTimeOutQueque.forEach((fn2) => {
          fn2();
        });
        setTimeOutQueque.clear();
      });
    }
  };

  // src/js/mob/mob-core/store/store-type.js
  var TYPE_IS_ANY = "ANY";
  var UNTYPED = "UNTYPED";
  var STRING = "STRING";
  var NUMBER = "NUMBER";
  var OBJECT = "OBJECT";
  var FUNCTION = "FUNCTION";
  var ARRAY = "ARRAY";
  var BOOLEAN = "BOOLEAN";
  var ELEMENT = "ELEMENT";
  var HTMLELEMENT = "HTMLELEMENT";
  var NODELIST = "NODELIST";
  var SET = "SET";
  var MAP = "MAP";
  var storeType = {
    isString: (value) => Object.prototype.toString.call(value) === "[object String]",
    isNumber: (value) => Object.prototype.toString.call(value) === "[object Number]" && Number.isFinite(value),
    isObject: (value) => Object.prototype.toString.call(value) === "[object Object]",
    isFunction: (value) => Object.prototype.toString.call(value) === "[object Function]",
    isArray: (value) => Object.prototype.toString.call(value) === "[object Array]",
    isBoolean: (value) => Object.prototype.toString.call(value) === "[object Boolean]",
    isElement: (value) => value instanceof Element || value instanceof Document,
    isHTMLElement: (value) => value instanceof HTMLElement,
    isSet: (value) => value instanceof Set,
    isMap: (value) => value instanceof Map,
    isNodeList: (value) => Object.prototype.isPrototypeOf.call(NodeList.prototype, value)
  };
  var getTypeName = (type) => {
    switch (type) {
      case String:
      case STRING: {
        return "String";
      }
      case Number:
      case NUMBER: {
        return "Number";
      }
      case Object:
      case OBJECT: {
        return "Object";
      }
      case Function:
      case FUNCTION: {
        return "Function";
      }
      case Array:
      case ARRAY: {
        return "Array";
      }
      case Boolean:
      case BOOLEAN: {
        return "Boolean";
      }
      case Element:
      case ELEMENT: {
        return "Element";
      }
      case HTMLElement:
      case HTMLELEMENT: {
        return "HTMLElement";
      }
      case NodeList:
      case NODELIST: {
        return "NodeList";
      }
      case Set:
      case SET: {
        return "Set";
      }
      case Map:
      case MAP: {
        return "Map";
      }
      case TYPE_IS_ANY: {
        return TYPE_IS_ANY;
      }
      default: {
        return UNTYPED;
      }
    }
  };
  var checkType = (type, value) => {
    switch (type) {
      case String:
      case STRING: {
        return storeType.isString(value);
      }
      case Number:
      case NUMBER: {
        return storeType.isNumber(value);
      }
      case Object:
      case OBJECT: {
        return storeType.isObject(value);
      }
      case Function:
      case FUNCTION: {
        return storeType.isFunction(value);
      }
      case Array:
      case ARRAY: {
        return storeType.isArray(value);
      }
      case Boolean:
      case BOOLEAN: {
        return storeType.isBoolean(value);
      }
      case Element:
      case ELEMENT: {
        return storeType.isElement(value);
      }
      case HTMLElement:
      case HTMLELEMENT: {
        return storeType.isHTMLElement(value);
      }
      case NodeList:
      case NODELIST: {
        return storeType.isNodeList(value);
      }
      case Set:
      case SET: {
        return storeType.isSet(value);
      }
      case Map:
      case MAP: {
        return storeType.isMap(value);
      }
      case TYPE_IS_ANY: {
        return true;
      }
      default: {
        return true;
      }
    }
  };

  // src/js/mob/mob-core/store/check-equality.js
  var mapsAreEqual = (m1, m2) => m1.size === m2.size && [...m1.keys()].every((key) => m1.get(key) === m2.get(key));
  var setsAreEqual = (a, b) => a.size === b.size && [...a].every((value) => b.has(value));
  var arrayAreEquals = (a, b) => {
    if (a.length !== b.length) return false;
    const elements = /* @__PURE__ */ new Set([...a, ...b]);
    for (const x of elements) {
      const count1 = a.filter((e) => e === x).length;
      const count2 = b.filter((e) => e === x).length;
      if (count1 !== count2) return false;
    }
    return true;
  };
  var objectAreEqual = (obj1, obj2, checkDataOrder = false) => {
    const checkDataOrderParanoic = false;
    if (obj1 === null || obj2 === null) {
      return obj1 === obj2;
    }
    let _obj1 = obj1;
    let _obj2 = obj2;
    if (!checkDataOrder) {
      if (Array.isArray(obj1)) {
        _obj1 = [...obj1].sort();
      }
      if (Array.isArray(obj2)) {
        _obj2 = [...obj2].sort();
      }
    }
    if (typeof _obj1 !== "object" || typeof _obj2 !== "object") {
      return _obj1 === _obj2;
    }
    const obj1Props = Object.getOwnPropertyNames(_obj1);
    const obj2Props = Object.getOwnPropertyNames(_obj2);
    if (obj1Props.length !== obj2Props.length) {
      return false;
    }
    if (checkDataOrderParanoic && checkDataOrder) {
      const propOrder = obj1Props.toString() === obj2Props.toString();
      if (!propOrder) {
        return false;
      }
    }
    for (const prop of obj1Props) {
      const val1 = _obj1[prop];
      const val2 = _obj2[prop];
      if (typeof val1 === "object" && typeof val2 === "object") {
        if (objectAreEqual(val1, val2, checkDataOrder)) {
          continue;
        } else {
          return false;
        }
      }
      if (val1 !== val2) {
        return false;
      }
    }
    return true;
  };
  var checkEquality = (type, oldValue, newValue) => {
    switch (type) {
      case TYPE_IS_ANY: {
        return objectAreEqual(oldValue, newValue);
      }
      case ARRAY:
      case Array: {
        return arrayAreEquals(oldValue, newValue);
      }
      case SET:
      case Set: {
        return setsAreEqual(oldValue, newValue);
      }
      case MAP:
      case Map: {
        return mapsAreEqual(oldValue, newValue);
      }
      default: {
        return oldValue === newValue;
      }
    }
  };

  // src/js/mob/mob-core/store/constant.js
  var STORE_SET = "SET";
  var STORE_UPDATE = "UPDATE";

  // src/js/mob/mob-core/store/current-key.js
  var current_key_exports = {};
  __export(current_key_exports, {
    extractKeysFromArray: () => extractKeysFromArray,
    extractkeyFromProp: () => extractkeyFromProp,
    getCurrentDependencies: () => getCurrentDependencies,
    getFirstCurrentDependencies: () => getFirstCurrentDependencies,
    initializeCurrentDependencies: () => initializeCurrentDependencies,
    setCurrentDependencies: () => setCurrentDependencies
  });
  var current_computed_keys = [];
  var active = false;
  var initializeCurrentDependencies = () => {
    active = true;
    current_computed_keys.length = 0;
  };
  var getCurrentDependencies = () => {
    active = false;
    return [...current_computed_keys];
  };
  var getFirstCurrentDependencies = () => {
    active = false;
    const copy = [...current_computed_keys];
    return copy?.[0] ?? "missing_prop";
  };
  var setCurrentDependencies = (key) => {
    if (!active || !key) return;
    if (current_computed_keys.includes(key)) return;
    current_computed_keys = [...current_computed_keys, key];
  };
  var extractkeyFromProp = (prop) => {
    const isString = checkType(String, prop);
    if (isString) return (
      /** @type {string} */
      prop
    );
    initializeCurrentDependencies();
    prop();
    return getFirstCurrentDependencies();
  };
  var extractKeysFromArray = (keys) => {
    return keys.map((key) => {
      const isString = checkType(String, key);
      if (isString) return (
        /** @type {string} */
        key
      );
      initializeCurrentDependencies();
      key();
      return getFirstCurrentDependencies();
    });
  };

  // src/js/mob/mob-core/store/fire-queque.js
  var waitMap = /* @__PURE__ */ new Map();
  var runCallbackQueqe = ({
    callBackWatcher,
    prop,
    newValue,
    oldValue,
    validationValue,
    instanceId
  }) => {
    for (const { prop: currentProp, fn, wait } of callBackWatcher.values()) {
      if (currentProp === prop && !wait) {
        fn(newValue, oldValue, validationValue);
      }
      if (instanceId && currentProp === prop && wait) {
        const queueByInstanceId = waitMap.get(instanceId) ?? /** @type{Map<string, any>} */
        /* @__PURE__ */ new Map();
        const shouldWait = queueByInstanceId.has(prop);
        queueByInstanceId.set(prop, newValue);
        if (shouldWait) return;
        waitMap.set(instanceId, queueByInstanceId);
        useNextLoop(() => {
          const propsPerIdNow = waitMap.get(instanceId);
          const valueNow = propsPerIdNow?.get(prop);
          if (valueNow !== void 0 || valueNow !== null) {
            fn(valueNow, oldValue, validationValue);
          }
          propsPerIdNow?.delete(prop);
          if (propsPerIdNow?.size === 0) {
            waitMap.delete(instanceId);
          }
        });
      }
    }
  };
  var runCallbackQueqeAsync = async ({
    callBackWatcher,
    prop,
    newValue,
    oldValue,
    validationValue
  }) => {
    for (const { prop: currentProp, fn } of callBackWatcher.values()) {
      if (currentProp === prop) await fn(newValue, oldValue, validationValue);
    }
  };

  // src/js/mob/mob-core/store/log-style.js
  var logStyle = "padding: 10px;";
  var getLogStyle = () => logStyle;

  // src/js/mob/mob-core/store/strategy.js
  var useStoreCopy = false;

  // src/js/mob/mob-core/store/store-map.js
  var storeMap = /* @__PURE__ */ new Map();
  var getStateFromMainMap = (id) => {
    if (useStoreCopy) {
      const valueNow = storeMap.get(id);
      return valueNow ? { ...valueNow } : void 0;
    }
    return storeMap.get(id);
  };
  var updateMainMap = (id, state) => {
    storeMap.set(id, state);
  };
  var removeStateFromMainMap = (id) => {
    storeMap.delete(id);
  };

  // src/js/mob/mob-core/store/store-warining.js
  var storeDepthWarning = (data, style) => {
    console.warn(
      `%c MobStore supports an object with a depth of up to 2 levels, set 'Any' type to use obj as value, the input object has ${data} level`,
      style
    );
  };
  var storeSetWarning = (prop, style) => {
    console.warn(
      `%c MobStore, trying to execute set() method: store.${prop} not exist`,
      style
    );
  };
  var storeSetPropValWarning = (prop, val2, style) => {
    console.warn(
      `%c trying to execute setProp method on '${prop}' propierties: setProp methods doesn't allow objects as value, ${JSON.stringify(
        val2
      )} is an Object, use 'Any' type for custom object`,
      style
    );
  };
  var storeSetPropPropWarning = (prop, style) => {
    console.warn(
      `%c trying to execute setProp method on '${prop}' propierties: '${JSON.stringify(
        prop
      )}' is an objects`,
      style
    );
  };
  var storeSetPropTypeWarning = (prop, val2, type, style) => {
    console.warn(
      `%c trying to execute setProp method on '${prop}' propierties: ${val2} is not a ${getTypeName(
        type
      )}`,
      style
    );
  };
  var storeSetObjectValWarning = (prop, val2, style) => {
    console.warn(
      `%c trying to execute setObj method on '${prop}' propierties: setObj methods allow only objects as value, ${val2} is not an Object`,
      style
    );
  };
  var storeSetObjectPropWarning = (prop, style) => {
    console.warn(
      `%c trying to execute setObj data method on '${prop}' propierties: store propierties '${prop}' is not an object`,
      style
    );
  };
  var storeSetObjKeysWarning = (key, prop, style) => {
    console.warn(
      `%c trying to execute setObj data method: one of these keys '${key}' not exist in store.${prop}`,
      style
    );
  };
  var storeSetObjDepthWarning = (prop, val2, style) => {
    console.warn(
      `%c trying to execute setObj data method on '${prop}' propierties: '${JSON.stringify(
        val2
      )}' have a depth > 1, nested obj is not allowed`,
      style
    );
  };
  var storeSetObjTypeWarning = (prop, subProp, subVal, type, style) => {
    console.warn(
      `%c trying to execute setObj data method on ${prop}.${subProp} propierties: ${subVal} is not a ${getTypeName(
        type
      )}`,
      style
    );
  };
  var storeGetPropWarning = (prop, style) => {
    console.warn(
      `%c trying to execute get data method: store.${prop} not exist`,
      style
    );
  };
  var storeEmitWarning = (prop, style) => {
    console.warn(
      `%c trying to execute set data method: store.${prop} not exist`,
      style
    );
  };
  var storeComputedKeyUsedWarning = (keys, style) => {
    console.warn(
      `%c one of the keys [${keys}] is already used as a computed target, or there is a circular dependencies`,
      style
    );
  };
  var storeWatchWarning = (prop, style) => {
    console.warn(
      `%c MobStore error: the property ${prop} to watch doesn't exist in store`,
      style
    );
  };
  var storeObjectIsNotAnyWarning = (style, CUSTOM_OBJECT) => {
    console.warn(
      `%c Validation Object error: validation function return undefined or have you used Object instead '${CUSTOM_OBJECT}' ?`,
      style
    );
  };

  // src/js/mob/mob-core/store/store-utils.js
  var maxDepth = (object) => {
    if (!storeType.isObject(object)) return 0;
    const values = Object.values(object);
    if (values.length === 0) return 1;
    return Math.max(...values.map((value) => maxDepth(value))) + 1;
  };
  var getDataRecursive = (data, shouldRecursive = true) => {
    return Object.entries(data).reduce((p, c) => {
      const [key, value] = c;
      const functionResult = storeType.isFunction(value) ? (
        /** @type {Function} */
        value()
      ) : {};
      if (storeType.isObject(value) && shouldRecursive) {
        return {
          ...p,
          [key]: getDataRecursive(
            /** @type {import('./type.js').MobStoreParams} */
            value,
            false
          )
        };
      }
      if (storeType.isFunction(value) && storeType.isObject(functionResult) && "value" in functionResult && ("validate" in functionResult || "type" in functionResult || "skipEqual" in functionResult)) {
        return { ...p, [key]: functionResult.value };
      }
      return { ...p, [key]: value };
    }, {});
  };
  var getPropRecursive = (data, prop, fallback, shouldRecursive = true) => {
    return Object.entries(data).reduce((p, c) => {
      const [key, value] = c;
      const functionResult = storeType.isFunction(value) ? (
        /** @type {Function} */
        value()
      ) : {};
      if (storeType.isObject(value) && shouldRecursive) {
        return {
          ...p,
          [key]: getPropRecursive(
            /** @type {import('./type.js').MobStoreParams} */
            value,
            prop,
            fallback,
            false
          )
        };
      }
      if (storeType.isFunction(value) && storeType.isObject(functionResult) && "value" in functionResult && prop in functionResult) {
        const propParsed = storeType.isString(functionResult[prop]) ? functionResult[prop].toUpperCase() : functionResult[prop];
        return { ...p, [key]: propParsed };
      }
      return { ...p, [key]: fallback };
    }, {});
  };
  var inizializeStoreData = ({ data, depth, logStyle: logStyle2 }) => {
    if (depth > 2) {
      storeDepthWarning(depth, logStyle2);
      return {};
    }
    return getDataRecursive(data);
  };
  var inizializeSpecificProp = ({
    data,
    prop,
    depth,
    logStyle: logStyle2,
    fallback
  }) => {
    if (depth > 2) {
      storeDepthWarning(depth, logStyle2);
      return {};
    }
    return getPropRecursive(data, prop, fallback);
  };
  var cloneValueOrGet = ({ value }) => {
    if (checkType(Map, value)) {
      return new Map(value);
    }
    if (checkType(Set, value)) {
      return new Set(value);
    }
    if (checkType(Object, value)) {
      return { ...value };
    }
    if (checkType(Array, value)) {
      return [...value];
    }
    return value;
  };
  var checkIfPropIsComputed = ({ instanceId, prop }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return false;
    const { callBackComputed } = state;
    const isComputed = [...callBackComputed].some(
      ({ prop: currentProp }) => prop === currentProp
    );
    if (isComputed) {
      console.warn(
        `${prop} is used as computed, explicit set is disallowed.`
      );
    }
    return isComputed;
  };

  // src/js/mob/mob-core/store/store-set.js
  var setProp = ({
    instanceId,
    state,
    prop,
    val: val2,
    fireCallback = true,
    useStrict = true
  }) => {
    const {
      type,
      fnTransformation,
      store: store2,
      fnValidate,
      strict,
      validationStatusObject,
      skipEqual,
      callBackWatcher,
      bindInstanceBy
    } = state;
    const logStyle2 = getLogStyle();
    const isCustomObject = type[prop] === TYPE_IS_ANY;
    if (storeType.isObject(val2) && !isCustomObject) {
      storeSetPropValWarning(prop, val2, logStyle2);
      return;
    }
    if (storeType.isObject(store2[prop]) && !isCustomObject) {
      storeSetPropPropWarning(prop, logStyle2);
      return;
    }
    const oldVal = store2[prop];
    const valueTransformed = (
      /** @type{{[key:string]: ((current: any, previous: any) => any)}} */
      fnTransformation[prop]?.(val2, oldVal) ?? val2
    );
    const isValidType = checkType(type[prop], valueTransformed);
    if (!isValidType) {
      storeSetPropTypeWarning(prop, valueTransformed, type[prop], logStyle2);
      return;
    }
    const isValidated = (
      /** @type {Object<string, function>} */
      fnValidate[prop]?.(valueTransformed, oldVal)
    );
    if (strict[prop] && !isValidated && useStrict) return;
    validationStatusObject[prop] = isValidated;
    const isEqual = skipEqual[prop] ? checkEquality(type[prop], oldVal, valueTransformed) : false;
    if (isEqual) return;
    store2[prop] = valueTransformed;
    if (fireCallback) {
      runCallbackQueqe({
        callBackWatcher,
        prop,
        newValue: valueTransformed,
        oldValue: oldVal,
        validationValue: validationStatusObject[prop],
        instanceId
      });
      addToComputedWaitLsit({ instanceId, prop });
      bindInstanceBy.forEach((id) => {
        addToComputedWaitLsit({ instanceId: id, prop });
      });
    }
    return {
      ...state,
      store: store2,
      validationStatusObject
    };
  };
  var setObj = ({
    instanceId,
    state,
    prop,
    val: val2,
    fireCallback = true,
    useStrict = true
  }) => {
    const {
      store: store2,
      type,
      strict,
      fnTransformation,
      fnValidate,
      validationStatusObject,
      skipEqual,
      callBackWatcher,
      bindInstanceBy
    } = state;
    const logStyle2 = getLogStyle();
    if (!storeType.isObject(val2)) {
      storeSetObjectValWarning(prop, val2, logStyle2);
      return;
    }
    if (!storeType.isObject(store2[prop])) {
      storeSetObjectPropWarning(prop, logStyle2);
      return;
    }
    const valKeys = Object.keys(val2);
    const propKeys = Object.keys(store2[prop]);
    const hasKeys = valKeys.every((item) => propKeys.includes(item));
    if (!hasKeys) {
      storeSetObjKeysWarning(valKeys, prop, logStyle2);
      return;
    }
    const valueTransformed = Object.entries(val2).map((item) => {
      const [subProp, subVal] = item;
      const subValOld = store2[prop][subProp];
      return {
        [subProp]: fnTransformation[prop][subProp]?.(subVal, subValOld) ?? subVal
      };
    }).reduce((previous, current) => ({ ...previous, ...current }));
    const isValidType = Object.entries(valueTransformed).map((item) => {
      const [subProp, subVal] = item;
      const typeResponse = checkType(type[prop][subProp], subVal);
      if (!typeResponse) {
        storeSetObjTypeWarning(
          prop,
          subProp,
          subVal,
          type[prop][subProp],
          logStyle2
        );
      }
      return typeResponse;
    }).every((item) => item === true);
    if (!isValidType) {
      return;
    }
    const strictObjectResult = Object.entries(valueTransformed).map((item) => {
      const [subProp, subVal] = item;
      const subValOld = store2[prop][subProp];
      return strict[prop][subProp] && useStrict ? {
        strictCheck: fnValidate[prop][subProp]?.(
          subVal,
          subValOld
        ),
        item
      } : { strictCheck: true, item };
    }).filter(({ strictCheck }) => strictCheck === true);
    const allStrictFail = strictObjectResult.length === 0;
    if (allStrictFail) return;
    const newValParsedByStrict = Object.fromEntries(
      strictObjectResult.map(({ item }) => item).map(([key, val3]) => [key, val3])
    );
    Object.entries(newValParsedByStrict).forEach((item) => {
      const [subProp, subVal] = item;
      const subValOld = store2[prop][subProp];
      const validateResult = fnValidate[prop][subProp]?.(subVal, subValOld);
      if (validateResult === void 0) {
        storeObjectIsNotAnyWarning(logStyle2, TYPE_IS_ANY);
      }
      validationStatusObject[prop][subProp] = validateResult;
    });
    const oldObjectValues = store2[prop];
    const newObjectValues = {
      ...store2[prop],
      ...newValParsedByStrict
    };
    const shouldSkipEqual = Object.keys(newValParsedByStrict).every(
      (subProp) => skipEqual[prop][subProp] === true
    );
    const prevValueIsEqualNew = shouldSkipEqual ? Object.entries(newObjectValues).every(([key, value]) => {
      const isCustomObject = type[prop][key] === TYPE_IS_ANY;
      const dataDepth = maxDepth(value);
      if (dataDepth > 1 && !isCustomObject) {
        storeSetObjDepthWarning(prop, valueTransformed, logStyle2);
        return;
      }
      return checkEquality(
        type[prop][key],
        oldObjectValues[key],
        value
      );
    }) : false;
    if (prevValueIsEqualNew) return;
    store2[prop] = newObjectValues;
    if (fireCallback) {
      runCallbackQueqe({
        callBackWatcher,
        prop,
        newValue: store2[prop],
        oldValue: oldObjectValues,
        validationValue: validationStatusObject[prop],
        instanceId
      });
      addToComputedWaitLsit({ instanceId, prop });
      bindInstanceBy.forEach((id) => {
        addToComputedWaitLsit({ instanceId: id, prop });
      });
    }
    return {
      ...state,
      store: store2,
      validationStatusObject
    };
  };
  var storeSetAction = ({
    instanceId,
    state,
    prop,
    value,
    fireCallback = true,
    clone = false,
    useStrict = true,
    action: action2
  }) => {
    const { store: store2, type } = state;
    if (!store2) return;
    const logStyle2 = getLogStyle();
    if (!(prop in store2)) {
      storeSetWarning(prop, logStyle2);
      return;
    }
    const previousValue = clone ? cloneValueOrGet({ value: store2[prop] }) : store2[prop];
    const valueParsed = action2 === STORE_UPDATE ? value(previousValue) : value;
    const isCustomObject = type[prop] === TYPE_IS_ANY;
    return storeType.isObject(previousValue) && !isCustomObject ? setObj({
      instanceId,
      state,
      prop,
      val: valueParsed,
      fireCallback,
      useStrict
    }) : setProp({
      instanceId,
      state,
      prop,
      val: valueParsed,
      fireCallback,
      useStrict
    });
  };
  var storeSetEntryPoint = ({
    instanceId,
    prop,
    value,
    fireCallback,
    clone,
    action: action2
  }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const newState = storeSetAction({
      instanceId,
      state,
      prop,
      value,
      fireCallback,
      clone,
      action: action2
    });
    if (!newState) return;
    updateMainMap(instanceId, newState);
  };
  var storeQuickSetEntrypoint = ({ instanceId, prop, value }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { store: store2, callBackWatcher } = state;
    const oldVal = store2[prop];
    store2[prop] = value;
    runCallbackQueqe({
      callBackWatcher,
      prop,
      newValue: value,
      oldValue: oldVal,
      validationValue: true,
      instanceId
    });
    updateMainMap(instanceId, { ...state, store: store2 });
  };
  var mergeStoreFromBindInstance = ({ store: store2, bindInstance }) => {
    return bindInstance.reduce((previous, current) => {
      const currentState = getStateFromMainMap(current);
      if (!currentState) return previous;
      const { store: currentStore } = currentState;
      return { ...previous, ...currentStore };
    }, store2);
  };
  var fireComputed = (instanceId) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { computedPropsQueque, callBackComputed, store: store2, bindInstance } = state;
    const computedFiltered = [...callBackComputed ?? []].filter(
      ({ keys }) => {
        return [...computedPropsQueque].find((current) => {
          return keys.includes(current);
        });
      }
    );
    const storeMerged = mergeStoreFromBindInstance({ store: store2, bindInstance });
    const computedValues = computedFiltered.map(({ prop, keys, fn }) => {
      const valuesToObject = keys.map((item) => {
        return { [item]: storeMerged[item] };
      }).reduce((previous, current) => {
        return { ...previous, ...current };
      }, {});
      return {
        prop,
        value: fn(valuesToObject)
      };
    });
    updateMainMap(instanceId, {
      ...state,
      computedPropsQueque: /* @__PURE__ */ new Set(),
      computedRunning: false
    });
    computedValues.forEach(({ prop, value }) => {
      storeSetEntryPoint({
        instanceId,
        prop,
        value,
        action: STORE_SET
      });
    });
  };
  var addToComputedWaitLsit = ({ instanceId, prop }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { callBackComputed, computedPropsQueque, computedRunning } = state;
    if (!callBackComputed || callBackComputed.size === 0) return;
    computedPropsQueque.add(prop);
    updateMainMap(instanceId, {
      ...state,
      computedPropsQueque
    });
    if (!computedRunning) {
      const state4 = getStateFromMainMap(instanceId);
      if (!state4) return;
      updateMainMap(instanceId, { ...state4, computedRunning: true });
      useNextLoop(() => fireComputed(instanceId));
    }
  };
  var storeComputedAction = ({ instanceId, prop, keys, fn }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { callBackComputed } = state;
    const hasCircularDependecies = [...callBackComputed].reduce(
      (previous, { prop: currentProp, keys: currentKeys }) => {
        return currentKeys.includes(prop) && keys.includes(currentProp) && !previous;
      },
      false
    );
    if (keys.includes(prop) || hasCircularDependecies) {
      storeComputedKeyUsedWarning(keys, getLogStyle());
      return;
    }
    callBackComputed.add({
      prop,
      keys,
      fn
    });
    updateMainMap(instanceId, {
      ...state,
      callBackComputed
    });
  };
  var initializeCompuntedProp = ({
    instanceId,
    prop,
    keys,
    callback: callback2
  }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { store: store2, bindInstance } = state;
    const storeMerged = mergeStoreFromBindInstance({ store: store2, bindInstance });
    const valuesObject = keys.map((key) => {
      if (key in storeMerged) return { [key]: storeMerged[key] };
      return;
    }).filter((item) => item !== void 0).reduce((previous, current) => {
      return { ...previous, ...current };
    }, {});
    const value = callback2(valuesObject);
    storeSetEntryPoint({
      instanceId,
      prop,
      value,
      fireCallback: false,
      clone: false,
      action: STORE_SET
    });
  };
  var storeComputedEntryPoint = ({
    instanceId,
    prop,
    keys,
    callback: callback2
  }) => {
    const keysDetected = keys.length === 0 ? (() => {
      initializeCurrentDependencies();
      callback2({});
      return getCurrentDependencies();
    })() : keys;
    initializeCompuntedProp({
      instanceId,
      prop,
      keys: keysDetected,
      callback: callback2
    });
    storeComputedAction({
      instanceId,
      prop,
      keys: keysDetected,
      fn: callback2
    });
  };

  // src/js/mob/mob-core/store/initial-validation.js
  var inizializeValidation = (initialState) => {
    const { store: store2 } = initialState;
    const validationStatusObject = Object.entries(store2).reduce(
      (previous, current) => {
        const [key, value] = current;
        return storeType.isObject(value) ? { ...previous, [key]: {} } : previous;
      },
      {}
    );
    return { ...initialState, validationStatusObject };
  };
  var inizializeAllProps = (instanceId, initialState) => {
    const { store: store2 } = initialState;
    Object.entries(store2).forEach((item) => {
      const [prop, value] = item;
      const state = getStateFromMainMap(instanceId);
      if (!state) return;
      const newState = storeSetAction({
        instanceId,
        state,
        prop,
        value,
        fireCallback: false,
        useStrict: false,
        action: STORE_SET
      });
      if (!newState) return;
      updateMainMap(instanceId, newState);
    });
  };

  // src/js/mob/mob-core/store/watch.js
  var storeWatchAction = ({ state, prop, callback: callback2, wait }) => {
    const { store: store2, callBackWatcher } = state;
    const logStyle2 = getLogStyle();
    if (!store2)
      return {
        state: void 0,
        unsubscribeId: ""
      };
    if (!(prop in store2)) {
      storeWatchWarning(prop, logStyle2);
      return {
        state: void 0,
        unsubscribeId: ""
      };
    }
    const id = getUnivoqueId();
    callBackWatcher.set(id, { fn: callback2, prop, wait });
    return {
      state: { ...state, callBackWatcher },
      unsubscribeId: id
    };
  };
  var unsubScribeWatch = ({ instanceId, unsubscribeId }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { callBackWatcher } = state;
    if (!callBackWatcher) return;
    callBackWatcher.delete(unsubscribeId);
    updateMainMap(instanceId, { ...state, callBackWatcher });
  };
  var watchMobStore = ({ instanceId, prop, callback: callback2, wait }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return () => {
    };
    const { state: newState, unsubscribeId } = storeWatchAction({
      state,
      prop,
      callback: callback2,
      wait
    });
    if (!newState) return () => {
    };
    updateMainMap(instanceId, newState);
    return () => {
      unsubScribeWatch({ instanceId, unsubscribeId });
    };
  };
  var watchEntryPoint = ({ instanceId, prop, callback: callback2, wait }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return () => {
    };
    const { bindInstance, unsubscribeBindInstance } = state;
    if (!bindInstance || bindInstance.length === 0) {
      return watchMobStore({ instanceId, prop, callback: callback2, wait });
    }
    const currentBindId = [instanceId, ...bindInstance].find((id) => {
      const store2 = storeMap.get(id)?.store;
      return store2 && prop in store2;
    }) ?? "";
    const unsubscribe3 = watchMobStore({
      instanceId: currentBindId,
      prop,
      callback: callback2,
      wait
    });
    updateMainMap(instanceId, {
      ...state,
      unsubscribeBindInstance: [...unsubscribeBindInstance, unsubscribe3]
    });
    return unsubscribe3;
  };

  // src/js/mob/mob-core/store/inizialize-instance.js
  var inizializeInstance = (data) => {
    const dataDepth = maxDepth(data);
    return {
      callBackWatcher: /* @__PURE__ */ new Map(),
      callBackComputed: /* @__PURE__ */ new Set(),
      computedPropsQueque: /* @__PURE__ */ new Set(),
      validationStatusObject: {},
      dataDepth,
      computedRunning: false,
      store: inizializeStoreData({
        data,
        depth: dataDepth,
        logStyle: getLogStyle()
      }),
      type: inizializeSpecificProp({
        data,
        prop: "type",
        depth: dataDepth,
        logStyle: getLogStyle(),
        fallback: UNTYPED
      }),
      fnTransformation: inizializeSpecificProp({
        data,
        prop: "transform",
        depth: dataDepth,
        logStyle: getLogStyle(),
        fallback: (value) => value
      }),
      fnValidate: inizializeSpecificProp({
        data,
        prop: "validate",
        depth: dataDepth,
        logStyle: getLogStyle(),
        fallback: () => true
      }),
      strict: inizializeSpecificProp({
        data,
        prop: "strict",
        depth: dataDepth,
        logStyle: getLogStyle(),
        fallback: false
      }),
      skipEqual: inizializeSpecificProp({
        data,
        prop: "skipEqual",
        depth: dataDepth,
        logStyle: getLogStyle(),
        fallback: true
      }),
      proxiObject: void 0,
      bindInstance: [],
      bindInstanceBy: [],
      unsubscribeBindInstance: []
    };
  };

  // src/js/mob/mob-core/store/store-get.js
  var storeGet = (instanceId) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return {};
    const { store: store2 } = state;
    return store2 ?? {};
  };
  var storeGetEntryPoint = (instanceId) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return {};
    const { bindInstance } = state;
    if (!bindInstance || bindInstance.length === 0) {
      return storeGet(instanceId);
    }
    return [...bindInstance, instanceId].map((id) => storeGet(id)).reduce((previous, current) => ({ ...previous, ...current }), {});
  };
  var storeGetProp = ({ instanceId, prop }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const store2 = state?.store;
    if (store2 && prop in store2) {
      return store2[prop];
    } else {
      storeGetPropWarning(prop, getLogStyle());
      return;
    }
  };
  var storeGetPropEntryPoint = ({ instanceId, prop }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { bindInstance } = state;
    if (!bindInstance || bindInstance.length === 0) {
      return storeGetProp({ instanceId, prop });
    }
    const currentBindId = [instanceId, ...bindInstance].find((id) => {
      const store2 = storeMap.get(id)?.store;
      return store2 && prop in store2;
    }) ?? "";
    return storeGetProp({ instanceId: currentBindId, prop });
  };

  // src/js/mob/mob-core/store/store-emit.js
  var storeEmit = ({ instanceId, prop }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { store: store2, callBackWatcher, validationStatusObject, bindInstanceBy } = state;
    if (!store2) return;
    if (prop in store2) {
      runCallbackQueqe({
        callBackWatcher,
        prop,
        newValue: store2[prop],
        oldValue: store2[prop],
        validationValue: validationStatusObject[prop],
        instanceId
      });
      addToComputedWaitLsit({ instanceId, prop });
      bindInstanceBy.forEach((id) => {
        addToComputedWaitLsit({ instanceId: id, prop });
      });
    } else {
      storeEmitWarning(prop, getLogStyle());
    }
  };
  var storeEmitEntryPoint = ({ instanceId, prop }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { bindInstance } = state;
    if (!bindInstance || bindInstance.length === 0) {
      storeEmit({ instanceId, prop });
      return;
    }
    const currentBindId = [instanceId, ...bindInstance].find((id) => {
      const store2 = storeMap.get(id)?.store;
      return store2 && prop in store2;
    }) ?? "";
    storeEmit({ instanceId: currentBindId, prop });
  };
  var storeEmitAsync = async ({ instanceId, prop }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return new Promise((resolve) => resolve(""));
    const { store: store2, callBackWatcher, validationStatusObject, bindInstanceBy } = state;
    if (!store2) return { success: false };
    if (prop in store2) {
      await runCallbackQueqeAsync({
        callBackWatcher,
        prop,
        newValue: store2[prop],
        oldValue: store2[prop],
        validationValue: validationStatusObject[prop],
        instanceId
      });
      addToComputedWaitLsit({ instanceId, prop });
      bindInstanceBy.forEach((id) => {
        addToComputedWaitLsit({ instanceId: id, prop });
      });
      return { success: true };
    } else {
      storeEmitWarning(prop, getLogStyle());
      return { success: false };
    }
  };
  var storeEmitAsyncEntryPoint = async ({ instanceId, prop }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return new Promise((resolve) => resolve(""));
    const { bindInstance } = state;
    if (!bindInstance || bindInstance.length === 0) {
      return storeEmitAsync({ instanceId, prop });
    }
    const currentBindId = [instanceId, ...bindInstance].find((id) => {
      const store2 = storeMap.get(id)?.store;
      return store2 && prop in store2;
    }) ?? "";
    return storeEmitAsync({
      instanceId: currentBindId,
      prop
    });
  };

  // src/js/mob/mob-core/store/store-debug.js
  var storeGetValidationEntryPoint = ({ instanceId }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { validationStatusObject } = state;
    return validationStatusObject;
  };
  var storeDebugStoreEntryPoint = ({ instanceId }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { store: store2 } = state;
    console.log(store2);
  };
  var storeDebugValidateEntryPoint = ({ instanceId }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { validationStatusObject } = state;
    console.log(validationStatusObject);
  };
  var storeDebugEntryPoint = ({ instanceId }) => {
    const state = getStateFromMainMap(instanceId);
    console.log(state);
  };

  // src/js/mob/mob-core/store/proxi.js
  var getProxiEntryPoint = ({ instanceId }) => {
    const state = storeMap.get(instanceId);
    if (!state) return {};
    const { bindInstance, proxiObject: previousProxiObject } = state;
    if (previousProxiObject) {
      return previousProxiObject;
    }
    const store2 = state?.store;
    const selfProxi = new Proxy(store2, {
      set(target, prop, value) {
        if (prop in target) {
          const isComputed = checkIfPropIsComputed({ instanceId, prop });
          if (isComputed) return false;
          storeSetEntryPoint({
            instanceId,
            prop,
            value,
            fireCallback: true,
            clone: false,
            action: STORE_SET
          });
          return true;
        }
        return false;
      },
      get(target, prop) {
        if (!(prop in target)) {
          return false;
        }
        setCurrentDependencies(prop);
        return target[prop];
      }
    });
    if (!bindInstance || bindInstance.length === 0) {
      updateMainMap(instanceId, {
        ...state,
        proxiObject: selfProxi
      });
      return selfProxi;
    }
    const bindedProxi = bindInstance.map((id) => {
      const state4 = storeMap.get(id);
      const store3 = state4?.store ?? {};
      return new Proxy(store3, {
        set() {
          return false;
        },
        get(target, prop) {
          if (!(prop in target)) {
            return false;
          }
          setCurrentDependencies(prop);
          return target[prop];
        }
      });
    });
    const bindedProxiArray = new Proxy([selfProxi, ...bindedProxi], {
      set(proxies, prop, value) {
        const currentProxi = proxies.find((proxi) => prop in proxi);
        if (!currentProxi) return false;
        Reflect.set(currentProxi, prop, value);
        return true;
      },
      get(proxies, prop) {
        const currentProxi = proxies.find((proxi) => prop in proxi);
        if (!currentProxi) return false;
        return Reflect.get(currentProxi, prop);
      }
    });
    updateMainMap(instanceId, {
      ...state,
      proxiObject: bindedProxiArray
    });
    return bindedProxiArray;
  };

  // src/js/mob/mob-core/store/bind-store.js
  var addSelfIdToBindInstanceBy = ({ selfId, bindId }) => {
    const state = getStateFromMainMap(bindId);
    if (!state) return;
    const { bindInstanceBy } = state;
    const bindInstanceByUpdated = [...bindInstanceBy, selfId];
    updateMainMap(bindId, {
      ...state,
      bindInstanceBy: bindInstanceByUpdated
    });
  };
  var removeSelfIdToBindInstanceBy = ({ selfId, bindId }) => {
    const state = getStateFromMainMap(bindId);
    if (!state) return;
    const { bindInstanceBy } = state;
    const bindInstanceByUpdated = bindInstanceBy.filter((id) => id !== selfId);
    updateMainMap(bindId, {
      ...state,
      bindInstanceBy: bindInstanceByUpdated
    });
  };
  var bindStoreEntryPoint = ({ value, instanceId }) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    const { bindInstance } = state;
    if (!bindInstance) return;
    const ids = checkType(Array, value) ? (
      // @ts-ignore
      value.map(
        (store2) => store2.getId()
      )
    ) : (
      // @ts-ignore
      [value.getId()]
    );
    const bindInstanceUpdated = [...bindInstance, ...ids];
    updateMainMap(instanceId, {
      ...state,
      bindInstance: bindInstanceUpdated
    });
    ids.forEach((id) => {
      addSelfIdToBindInstanceBy({ selfId: instanceId, bindId: id });
    });
  };

  // src/js/mob/mob-core/store/destroy.js
  var destroyStoreEntryPoint = (instanceId) => {
    const state = getStateFromMainMap(instanceId);
    if (!state) return;
    state.callBackWatcher.clear();
    state.callBackComputed.clear();
    state.computedPropsQueque.clear();
    state.store = {};
    state.proxiObject = null;
    const { unsubscribeBindInstance, bindInstance } = state;
    unsubscribeBindInstance.forEach((unsubscribe3) => {
      unsubscribe3?.();
    });
    bindInstance.forEach((id) => {
      removeSelfIdToBindInstanceBy({ selfId: instanceId, bindId: id });
    });
    removeStateFromMainMap(instanceId);
  };

  // src/js/mob/mob-core/store/index.js
  var mobStore = (data = {}) => {
    const instanceId = getUnivoqueId();
    const initialState = inizializeInstance(data);
    const stateUpdated = inizializeValidation(initialState);
    updateMainMap(instanceId, stateUpdated);
    inizializeAllProps(instanceId, initialState);
    return {
      getId: () => instanceId,
      bindStore: (value) => {
        bindStoreEntryPoint({ value, instanceId });
      },
      get: () => {
        return storeGetEntryPoint(instanceId);
      },
      getProp: (prop) => {
        return storeGetPropEntryPoint({ instanceId, prop });
      },
      set: (prop, value, { emit = true } = {}) => {
        const propParsed = extractkeyFromProp(prop);
        const isComputed = checkIfPropIsComputed({
          instanceId,
          prop: propParsed
        });
        if (isComputed) return;
        storeSetEntryPoint({
          instanceId,
          prop: propParsed,
          value,
          fireCallback: emit ?? true,
          clone: false,
          action: STORE_SET
        });
      },
      update: (prop, value, { emit = true, clone = false } = {}) => {
        const propParsed = extractkeyFromProp(prop);
        const isComputed = checkIfPropIsComputed({
          instanceId,
          prop: propParsed
        });
        if (isComputed) return;
        storeSetEntryPoint({
          instanceId,
          prop: propParsed,
          value,
          fireCallback: emit ?? true,
          clone,
          action: STORE_UPDATE
        });
      },
      getProxi: () => {
        return getProxiEntryPoint({ instanceId });
      },
      quickSetProp: (prop, value) => {
        const isComputed = checkIfPropIsComputed({ instanceId, prop });
        if (isComputed) return;
        storeQuickSetEntrypoint({ instanceId, prop, value });
      },
      watch: (prop, callback2, { wait = false, immediate = false } = {}) => {
        const propParsed = extractkeyFromProp(prop);
        const unwatch = watchEntryPoint({
          instanceId,
          prop: propParsed,
          callback: callback2,
          wait
        });
        if (immediate) {
          useNextLoop(() => {
            storeEmitEntryPoint({ instanceId, prop: propParsed });
          });
        }
        return unwatch;
      },
      computed: (prop, callback2, keys = []) => {
        const propParsed = extractkeyFromProp(prop);
        const keysParsed = extractKeysFromArray(keys);
        storeComputedEntryPoint({
          instanceId,
          prop: propParsed,
          keys: keysParsed,
          callback: callback2
        });
        useNextLoop(() => {
          storeEmitEntryPoint({ instanceId, prop: propParsed });
        });
      },
      emit: (prop) => {
        const propParsed = extractkeyFromProp(prop);
        storeEmitEntryPoint({ instanceId, prop: propParsed });
      },
      emitAsync: async (prop) => {
        const propParsed = extractkeyFromProp(prop);
        return storeEmitAsyncEntryPoint({ instanceId, prop: propParsed });
      },
      getValidation: () => {
        return storeGetValidationEntryPoint({ instanceId });
      },
      debug: () => {
        storeDebugEntryPoint({ instanceId });
      },
      debugStore: () => {
        storeDebugStoreEntryPoint({ instanceId });
      },
      debugValidate: () => {
        storeDebugValidateEntryPoint({ instanceId });
      },
      destroy: () => {
        destroyStoreEntryPoint(instanceId);
      }
    };
  };

  // src/js/mob/mob-core/events/event-store.js
  var eventStore = mobStore(
    /** @type {MobStoreParams<import('./type').EventStore>} */
    {
      /**
       * Use passive event.
       */
      usePassive: () => ({
        value: false,
        type: Boolean
      }),
      /**
       * Frame Event
       */
      currentFrame: () => ({
        value: 0,
        type: Number
      }),
      /**
       * Initial fps value
       */
      instantFps: () => ({
        value: 60,
        type: Number
      }),
      /**
       * Trigger nexFrame
       */
      requestFrame: () => ({
        value: () => {
        },
        type: Function
      }),
      /**
       * Send nextTick on next loop
       */
      deferredNextTick: () => ({
        value: true,
        type: Boolean
      }),
      /**
       * Throttle scroll value
       */
      throttle: () => ({
        value: 60,
        type: Number
      }),
      /**
       * Mouse wheell spinY max value ( 2.5 | -2.5 )
       */
      spinYMaxValue: () => ({
        value: 2.5,
        type: Number
      }),
      /**
       * Mouse wheell spinX max value ( 2.5 | -2.5 )
       */
      spinXMaxValue: () => ({
        value: 2.5,
        type: Number
      })
    }
  );

  // src/js/mob/mob-core/events/load-utils/handle-load.js
  var initialized = false;
  var callbacks = /* @__PURE__ */ new Map();
  function handler() {
    if (callbacks.size === 0) {
      globalThis.removeEventListener("DOMContentLoaded", handler);
      initialized = false;
      return;
    }
    for (const value of callbacks.values()) {
      value();
    }
    callbacks.clear();
  }
  function init() {
    if (initialized) return;
    initialized = true;
    globalThis.addEventListener("DOMContentLoaded", handler, {
      passive: false
    });
  }
  var addCallback = (cb) => {
    const id = getUnivoqueId();
    callbacks.set(id, cb);
    if (typeof globalThis !== "undefined") {
      init();
    }
    return () => callbacks.delete(id);
  };
  var handleLoad = /* @__PURE__ */ (() => addCallback)();

  // src/js/mob/mob-core/events/mouse-utils/normalize-whell.js
  var PIXEL_STEP = 10;
  var LINE_HEIGHT = 40;
  var PAGE_HEIGHT = 800;
  function normalizeWheel(event) {
    let sX = 0, sY = 0, pX = 0, pY = 0;
    if ("detail" in event) {
      sY = event.detail;
    }
    if ("wheelDelta" in event) {
      sY = -event.wheelDelta / 120;
    }
    if ("wheelDeltaY" in event) {
      sY = -event.wheelDeltaY / 120;
    }
    if ("wheelDeltaX" in event) {
      sX = -event.wheelDeltaX / 120;
    }
    if ("axis" in event && event.axis === event.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ("deltaY" in event) {
      pY = event.deltaY;
    }
    if ("deltaX" in event) {
      pX = event.deltaX;
    }
    if ((pX || pY) && event.deltaMode) {
      if (event.deltaMode == 1) {
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return { spinX: sX, spinY: sY, pixelX: pX, pixelY: pY };
  }

  // src/js/mob/mob-core/events/mouse-utils/handle-mouse.js
  function getPageData({ type, event }) {
    const touchEvent = (
      /** @type {TouchEvent} */
      event
    );
    if (type === "touchend" && "changedTouches" in event) {
      return touchEvent.changedTouches[0];
    }
    return "touches" in touchEvent ? touchEvent.touches[0] : event;
  }
  function getClientData({ type, event }) {
    const touchEvent = (
      /** @type {TouchEvent} */
      event
    );
    if (type === "touchend" && "changedTouches" in event) {
      return touchEvent.changedTouches[0];
    }
    return "touches" in touchEvent ? touchEvent.touches[0] : event;
  }
  function handleMouse(eventType) {
    let initialized7 = false;
    const callbacks9 = /* @__PURE__ */ new Map();
    let { usePassive } = eventStore.get();
    eventStore.watch("usePassive", () => {
      globalThis.removeEventListener(eventType, handler7);
      initialized7 = false;
      init8();
    });
    function handler7(event) {
      if (callbacks9.size === 0) {
        globalThis.removeEventListener(eventType, handler7);
        initialized7 = false;
        return;
      }
      const type = (
        /** @type {import('./type.js').MouseEventType} */
        event.type
      );
      const { pageX, pageY } = getPageData({ type, event });
      const { clientX, clientY } = getClientData({ type, event });
      const target = event.target;
      const mouseData = {
        page: {
          x: pageX,
          y: pageY
        },
        client: {
          x: clientX,
          y: clientY
        },
        target,
        type,
        preventDefault: () => usePassive ? () => {
        } : event.preventDefault()
      };
      if (type === "wheel") {
        const spinYMaxValue = eventStore.getProp("spinYMaxValue");
        const spinXMaxValue = eventStore.getProp("spinXMaxValue");
        const { spinX, spinY, pixelX, pixelY } = normalizeWheel(event);
        Object.assign(mouseData, {
          spinX: clamp(spinX, -spinXMaxValue, spinXMaxValue),
          spinY: clamp(spinY, -spinYMaxValue, spinYMaxValue),
          pixelX,
          pixelY
        });
      }
      for (const value of callbacks9.values()) {
        value(mouseData);
      }
    }
    function init8() {
      if (initialized7) return;
      initialized7 = true;
      usePassive = eventStore.getProp("usePassive");
      globalThis.addEventListener(eventType, handler7, {
        passive: usePassive
      });
    }
    const addCb6 = (cb) => {
      const id = getUnivoqueId();
      callbacks9.set(id, cb);
      if (typeof globalThis !== "undefined") {
        init8();
      }
      return () => callbacks9.delete(id);
    };
    return addCb6;
  }
  var handleMouseClick = handleMouse("click");
  var handleMouseDown = handleMouse("mousedown");
  var handleTouchStart = handleMouse("touchstart");
  var handleMouseMove = handleMouse("mousemove");
  var handleTouchMove = handleMouse("touchmove");
  var handleMouseUp = handleMouse("mouseup");
  var handleTouchEnd = handleMouse("touchend");
  var handleMouseWheel = handleMouse("wheel");

  // src/js/mob/mob-core/events/raf-utils/handle-cache.js
  var cacheCoutner = 0;
  var subscriberMap = /* @__PURE__ */ new Map();
  var add = (el = {}, fn = () => {
  }) => {
    const id = getUnivoqueId();
    subscriberMap.set(id, {
      el,
      fn,
      data: /* @__PURE__ */ new Map(),
      freeze: {
        active: false,
        atFrame: 0
      }
    });
    return {
      id,
      unsubscribe: () => {
        if (subscriberMap.has(id)) {
          const item = subscriberMap.get(id);
          if (!item) return;
          const frameToSubstract = item.data.size;
          subscriberMap.delete(id);
          if (!frameToSubstract) return;
          cacheCoutner = cacheCoutner - frameToSubstract;
        }
      }
    };
  };
  var update = ({ id, callBackObject, frame }) => {
    if (!subscriberMap.has(id)) return;
    const { currentFrame: currentFrame2 } = eventStore.get();
    const item = subscriberMap.get(id);
    if (!item?.data) return;
    const { data } = item;
    if (data.has(frame + currentFrame2)) return;
    data.set(frame + currentFrame2, callBackObject);
    cacheCoutner++;
  };
  var remove = (id) => {
    if (subscriberMap.has(id)) subscriberMap.delete(id);
  };
  var freeze = (id) => {
    const item = subscriberMap.get(id);
    if (!item) return;
    if (item.freeze.active) return;
    const { currentFrame: currentFrame2 } = eventStore.get();
    item.freeze = {
      active: true,
      atFrame: currentFrame2
    };
  };
  var unFreeze = ({ id, update: update3 = true }) => {
    const item = subscriberMap.get(id);
    if (!item) return;
    if (!item.freeze.active) return;
    if (!update3) {
      item.freeze = {
        active: false,
        atFrame: 0
      };
      return;
    }
    const { currentFrame: currentFrame2 } = eventStore.get();
    const { atFrame } = item.freeze;
    const newEntries = [];
    for (const [frame, value] of item.data) {
      const delta = frame + currentFrame2 - atFrame;
      item.data.delete(frame);
      newEntries.push({ frame: delta, value });
    }
    newEntries.forEach(({ frame, value }) => {
      item.data.set(frame, value);
    });
    newEntries.length = 0;
    item.freeze = {
      active: false,
      atFrame: 0
    };
  };
  var clean = (id) => {
    const el = subscriberMap.get(id);
    if (!el) return;
    const frameToSubstract = el.data.size;
    cacheCoutner = cacheCoutner - frameToSubstract;
    el.data.clear();
  };
  var get = (id) => {
    return subscriberMap.get(id) ?? {};
  };
  var fire = (frameCounter) => {
    for (const value of subscriberMap.values()) {
      const { data, fn, el, freeze: freeze2 } = value;
      if (freeze2.active) return;
      const callBackObject = data.get(frameCounter);
      if (callBackObject) {
        fn(callBackObject, el);
        data.delete(frameCounter);
        cacheCoutner--;
      }
    }
  };
  var fireObject = ({ id, obj = {} }) => {
    if (!subscriberMap.has(id)) return;
    const item = subscriberMap.get(id);
    if (!item) return;
    const { el, fn, freeze: freeze2 } = item;
    if (freeze2.active) return;
    fn(obj, el);
  };
  var getCacheCounter = () => cacheCoutner;
  var updateFrameId = (maxFramecounter) => {
    for (const [key, value] of subscriberMap) {
      const { data, fn, el, freeze: freeze2 } = value;
      const newMap = /* @__PURE__ */ new Map();
      for (const [frame, object] of data) {
        newMap.set(frame - maxFramecounter, object);
        data.delete(frame);
      }
      subscriberMap.set(key, { data: newMap, fn, el, freeze: freeze2 });
    }
  };
  var handleCache = /* @__PURE__ */ (() => {
    return {
      add,
      get,
      update,
      remove,
      clean,
      fire,
      fireObject,
      getCacheCounter,
      updateFrameId,
      freeze,
      unFreeze
    };
  })();

  // src/js/mob/mob-core/events/visibility-change/handle-visibility-change.js
  var initialized2 = false;
  var callbacks2 = /* @__PURE__ */ new Map();
  function handler2() {
    if (callbacks2.size === 0) {
      globalThis.removeEventListener("visibilitychange", handler2);
      initialized2 = false;
      return;
    }
    const visibilityData = {
      visibilityState: document.visibilityState
    };
    for (const value of callbacks2.values()) {
      value(visibilityData);
    }
  }
  function init2() {
    if (initialized2) return;
    initialized2 = true;
    globalThis.addEventListener("visibilitychange", handler2, {
      passive: false
    });
  }
  var addCb = (cb) => {
    const id = getUnivoqueId();
    callbacks2.set(id, cb);
    if (typeof globalThis !== "undefined") {
      init2();
    }
    return () => callbacks2.delete(id);
  };
  var handleVisibilityChange = /* @__PURE__ */ (() => addCb)();

  // src/js/mob/mob-core/events/raf-utils/handle-next-tick.js
  var callbacks3 = [];
  var add2 = (cb = () => {
  }, priority = 100) => {
    callbacks3.push({ cb, priority });
  };
  var fire2 = ({ time: time2, fps: fps2 }) => {
    if (callbacks3.length === 0) return;
    callbacks3.sort((a, b) => a.priority - b.priority);
    callbacks3.forEach(({ cb }) => cb({ time: time2, fps: fps2 }));
    callbacks3.length = 0;
  };
  var handleNextTick = /* @__PURE__ */ (() => {
    return { add: add2, fire: fire2 };
  })();

  // src/js/mob/mob-core/events/raf-utils/handle-next-frame.js
  var callbacks4 = [];
  var add3 = (callBack) => {
    callbacks4.push(callBack);
  };
  var get2 = () => {
    const callBackArray = [...callbacks4];
    callbacks4.length = 0;
    return callBackArray;
  };
  var handleNextFrame = /* @__PURE__ */ (() => {
    return { add: add3, get: get2 };
  })();

  // src/js/mob/mob-core/events/raf-utils/handle-frame-index.js
  var indexCallbackMap = /* @__PURE__ */ new Map();
  var updateKeys = (currentFrameLimit2) => {
    const oldMapToArray = [...indexCallbackMap.entries()];
    indexCallbackMap.clear();
    oldMapToArray.forEach(([index, value]) => {
      indexCallbackMap.set(index - currentFrameLimit2, value);
    });
  };
  var fire3 = ({ currentFrame: currentFrame2, time: time2, fps: fps2 }) => {
    const callabacks = indexCallbackMap.get(currentFrame2) ?? [];
    if (!callabacks || callabacks.length === 0) return;
    callabacks.forEach((item) => item({ time: time2, fps: fps2 }));
    indexCallbackMap.delete(currentFrame2);
  };
  var add4 = (callback2, index) => {
    const frameIndex = index + eventStore.getProp("currentFrame");
    const callabacks = indexCallbackMap.get(frameIndex) ?? [];
    indexCallbackMap.set(frameIndex, [...callabacks, callback2]);
    eventStore.emit("requestFrame");
  };
  var getAmountOfFrameToFire = () => {
    return indexCallbackMap.size;
  };
  var handleFrameIndex = /* @__PURE__ */ (() => {
    return {
      add: add4,
      fire: fire3,
      updateKeys,
      getAmountOfFrameToFire
    };
  })();

  // src/js/mob/mob-core/events/error-handler/catch-animation-reject.js
  var ANIMATION_STOP_REJECT = "animationStop";
  var catchAnimationReject = () => {
    globalThis.addEventListener("unhandledrejection", (e) => {
      if (e.reason === ANIMATION_STOP_REJECT) e.preventDefault();
    });
  };

  // src/js/mob/mob-core/events/raf-utils/load-fps.js
  var loadFpsIsReady = false;
  var loadFps = (duration2 = 30) => {
    if (loadFpsIsReady) {
      const { instantFps } = eventStore.get();
      return new Promise((resolve) => {
        resolve({ averageFPS: instantFps });
      });
    }
    return new Promise((resolve) => {
      const frameTimes = [];
      const maxFrames = 25;
      let frameCursor = 0;
      let numFrames = 0;
      let totalFPS = 0;
      let then = 0;
      let frameCounter = 0;
      const render2 = (now) => {
        now *= 1e-3;
        if (then === 0) {
          then = now;
          requestAnimationFrame(render2);
          return;
        }
        const deltaTime = now - then;
        then = now;
        const rawFps = Number.isFinite(1 / deltaTime) ? 1 / deltaTime : 60;
        const fps2 = Math.max(rawFps, 60);
        totalFPS += fps2 - (frameTimes[frameCursor] || 0);
        frameTimes[frameCursor++] = fps2;
        numFrames = Math.max(numFrames, frameCursor);
        frameCursor %= maxFrames;
        const averageFPS = Math.round(totalFPS / numFrames);
        frameCounter++;
        if (frameCounter >= duration2) {
          eventStore.quickSetProp("instantFps", averageFPS);
          loadFpsIsReady = true;
          resolve({ averageFPS });
          return;
        }
        requestAnimationFrame(render2);
      };
      requestAnimationFrame(render2);
    });
  };

  // src/js/mob/mob-core/events/raf-utils/time.js
  var getTime = () => {
    return typeof globalThis === "undefined" ? Date.now() : globalThis.performance.now();
  };
  var defaultTimestep = 1 / 60 * 1e3;

  // src/js/mob/mob-core/events/raf-utils/handle-frame.js
  loadFps();
  var currentFrameLimit = 1e7;
  var firstRunDuration = 2e3;
  var frameIsRuning = false;
  var callback = [];
  var time = getTime();
  var startTime = 0;
  var rawTime = 0;
  var timeElapsed = 0;
  var lastTime = 0;
  var timeLost = 0;
  var isStopped = false;
  var fps = 60;
  var maxFps = fps;
  var frames = 0;
  var fpsPrevTime = 0;
  var currentFrame = 0;
  var mustMakeSomethingIsActive = false;
  var shouldMakeSomethingIsActive = false;
  var mustMakeSomethingCheck = () => fps < maxFps / 5 * 3;
  var shouldMakeSomethingCheck = () => fps < maxFps / 5 * 4;
  var mustMakeSomethingStart = () => {
    if (!mustMakeSomethingCheck() || mustMakeSomethingIsActive) return;
    mustMakeSomethingIsActive = true;
    setTimeout(() => {
      mustMakeSomethingIsActive = false;
    }, 4e3);
  };
  var shouldMakeSomethingStart = () => {
    if (!shouldMakeSomethingCheck() || shouldMakeSomethingIsActive) return;
    shouldMakeSomethingIsActive = true;
    setTimeout(() => {
      shouldMakeSomethingIsActive = false;
    }, 4e3);
  };
  handleVisibilityChange(({ visibilityState }) => {
    isStopped = visibilityState === "visible";
  });
  catchAnimationReject();
  eventStore.watch("requestFrame", () => {
    initFrame();
  });
  var nextTickFn = () => {
    if (currentFrame === currentFrameLimit) {
      currentFrame = 0;
      eventStore.quickSetProp("currentFrame", currentFrame);
      handleFrameIndex.updateKeys(currentFrameLimit);
      handleCache.updateFrameId(currentFrameLimit);
    }
    handleNextTick.fire({ time, fps });
    callback = [...callback, ...handleNextFrame.get()];
    frameIsRuning = false;
    if (callback.length > 0 || handleFrameIndex.getAmountOfFrameToFire() > 0 || handleCache.getCacheCounter() > 0 || time < firstRunDuration) {
      initFrame();
    } else {
      isStopped = true;
      currentFrame = 0;
      lastTime = time;
      eventStore.quickSetProp("currentFrame", currentFrame);
    }
  };
  var render = (timestamp) => {
    time = timestamp;
    timeElapsed = time - rawTime;
    if (isStopped) startTime += timeElapsed;
    rawTime += timeElapsed;
    time = Math.round(rawTime - startTime);
    const frameDuration = Math.round(1e3 / fps);
    timeLost = Math.abs(time - lastTime - frameDuration);
    const timeToSubsctract = timeLost > 100 ? timeLost : 0;
    time = time - timeToSubsctract;
    lastTime = time;
    if (isStopped) {
      fpsPrevTime = time;
      frames = 0;
      fps = eventStore.getProp("instantFps");
    } else {
      frames++;
    }
    if (time > fpsPrevTime + 1e3 && !isStopped) {
      fps = time > firstRunDuration ? Math.round(frames * 1e3 / (time - fpsPrevTime)) : eventStore.getProp("instantFps");
      fpsPrevTime = time;
      frames = 0;
      fps = fps < 30 ? eventStore.getProp("instantFps") : fps;
    }
    if (fps > maxFps) maxFps = fps;
    mustMakeSomethingStart();
    shouldMakeSomethingStart();
    callback.forEach((item) => item({ time, fps }));
    handleFrameIndex.fire({ currentFrame, time, fps });
    handleCache.fire(currentFrame);
    currentFrame++;
    eventStore.quickSetProp("currentFrame", currentFrame);
    callback.length = 0;
    isStopped = false;
    const deferredNextTick = eventStore.getProp("deferredNextTick");
    if (deferredNextTick) {
      useNextLoop(() => nextTickFn());
    } else {
      nextTickFn();
    }
  };
  var initFrame = () => {
    if (frameIsRuning) return;
    if (typeof globalThis === "undefined") {
      setTimeout(() => render(getTime()), defaultTimestep);
    } else {
      requestAnimationFrame(render);
    }
    frameIsRuning = true;
  };
  var handleFrame = /* @__PURE__ */ (() => {
    const getFps2 = () => fps;
    const mustMakeSomething2 = () => mustMakeSomethingIsActive;
    const shouldMakeSomething2 = () => shouldMakeSomethingIsActive;
    const add5 = (cb) => {
      callback.push(cb);
      initFrame();
    };
    const addMultiple = (arr = []) => {
      callback = [...callback, ...arr];
      initFrame();
    };
    return {
      add: add5,
      addMultiple,
      getFps: getFps2,
      mustMakeSomething: mustMakeSomething2,
      shouldMakeSomething: shouldMakeSomething2
    };
  })();

  // src/js/mob/mob-core/events/debounce.js
  var debounceFuncion = function debounce(fn, time2 = 200) {
    let timeout;
    return function() {
      const functionCall = () => Reflect.apply(fn, this, arguments);
      clearTimeout(timeout);
      timeout = setTimeout(functionCall, time2);
    };
  };

  // src/js/mob/mob-core/events/resize-utils/handle-resize.js
  var initialized3 = false;
  var callbacks5 = /* @__PURE__ */ new Map();
  var debouceFunctionReference = () => {
  };
  var previousWindowHeight = window.innerHeight;
  var previousWindowWidth = window.innerWidth;
  function handler3() {
    if (callbacks5.size === 0) {
      window.removeEventListener("resize", debouceFunctionReference);
      initialized3 = false;
      return;
    }
    const windowsHeight = window.innerHeight;
    const windowsWidth = window.innerWidth;
    const verticalResize = windowsHeight !== previousWindowHeight;
    const horizontalResize = windowsWidth !== previousWindowWidth;
    previousWindowHeight = windowsHeight;
    previousWindowWidth = windowsWidth;
    const resizeData = {
      scrollY: window.scrollY,
      windowsHeight,
      windowsWidth,
      documentHeight: document.documentElement.scrollHeight,
      verticalResize,
      horizontalResize
    };
    for (const value of callbacks5.values()) {
      value(resizeData);
    }
  }
  function init3() {
    if (initialized3) return;
    initialized3 = true;
    debouceFunctionReference = debounceFuncion(() => handler3());
    window.addEventListener("resize", debouceFunctionReference, {
      passive: false
    });
  }
  var addCb2 = (cb) => {
    const id = getUnivoqueId();
    callbacks5.set(id, cb);
    if (typeof globalThis !== "undefined") {
      init3();
    }
    return () => callbacks5.delete(id);
  };
  var handleResize = /* @__PURE__ */ (() => addCb2)();

  // src/js/mob/mob-core/events/scroll-utils/handle-scroll-immediate.js
  var initialized4 = false;
  var callbacks6 = /* @__PURE__ */ new Map();
  var UP = "UP";
  var DOWN = "DOWN";
  var prev = window.scrollY;
  var val = window.scrollY;
  var direction = DOWN;
  var scrollData = {
    scrollY: val,
    direction
  };
  function handler4() {
    if (callbacks6.size === 0) {
      window.removeEventListener("scroll", handler4);
      initialized4 = false;
      return;
    }
    prev = val;
    val = window.scrollY;
    direction = val > prev ? DOWN : UP;
    scrollData = {
      scrollY: val,
      direction
    };
    for (const value of callbacks6.values()) {
      value(scrollData);
    }
  }
  function init4() {
    if (initialized4) return;
    initialized4 = true;
    window.addEventListener("scroll", handler4, {
      passive: true
    });
  }
  var addCb3 = (cb) => {
    const id = getUnivoqueId();
    callbacks6.set(id, cb);
    if (typeof globalThis !== "undefined") {
      init4();
    }
    return () => callbacks6.delete(id);
  };
  var handleScrollImmediate = /* @__PURE__ */ (() => {
    return addCb3;
  })();

  // src/js/mob/mob-core/events/scroll-utils/handle-scroll.js
  var initialized5 = false;
  var callbacks7 = /* @__PURE__ */ new Map();
  var unsubscribe = () => {
  };
  function handler5(scrollData2) {
    if (callbacks7.size === 0) {
      unsubscribe();
      initialized5 = false;
      return;
    }
    handleFrame.add(() => {
      handleNextTick.add(() => {
        for (const value of callbacks7.values()) {
          value(scrollData2);
        }
      }, 0);
    });
  }
  function init5() {
    if (initialized5) return;
    initialized5 = true;
    unsubscribe = handleScrollImmediate(handler5);
  }
  var addCb4 = (cb) => {
    const id = getUnivoqueId();
    callbacks7.set(id, cb);
    if (typeof globalThis !== "undefined") {
      init5();
    }
    return () => callbacks7.delete(id);
  };
  var handleScroll = /* @__PURE__ */ (() => addCb4)();

  // src/js/mob/mob-core/events/throttle.js
  var throttle = (func, limit) => {
    let lastFunc;
    let lastRan;
    return function() {
      const context = this;
      const args = arguments;
      if (lastRan) {
        clearTimeout(lastFunc);
        lastFunc = setTimeout(
          function() {
            if (getTime() - lastRan >= limit) {
              func.apply(context, args);
              lastRan = getTime();
            }
          },
          limit - (getTime() - lastRan)
        );
      } else {
        func.apply(context, args);
        lastRan = getTime();
      }
    };
  };

  // src/js/mob/mob-core/events/scroll-utils/handle-scroll-throttle.js
  var initialized6 = false;
  var callbacks8 = /* @__PURE__ */ new Map();
  var throttleFunctionReference;
  var unsubscribe2 = () => {
  };
  function handler6(scrollData2) {
    if (callbacks8.size === 0) {
      unsubscribe2();
      initialized6 = false;
      return;
    }
    handleFrame.add(() => {
      handleNextTick.add(() => {
        for (const value of callbacks8.values()) {
          value(scrollData2);
        }
      }, 0);
    });
  }
  function init6() {
    if (initialized6) return;
    initialized6 = true;
    throttleFunctionReference = throttle(
      (scrollData2) => handler6(scrollData2),
      eventStore.getProp("throttle")
    );
    unsubscribe2 = handleScrollImmediate(throttleFunctionReference);
  }
  var addCb5 = (cb) => {
    const id = getUnivoqueId();
    callbacks8.set(id, cb);
    if (typeof globalThis !== "undefined") {
      init6();
    }
    return () => callbacks8.delete(id);
  };
  var handleScrollThrottle = /* @__PURE__ */ (() => addCb5)();

  // src/js/mob/mob-core/events/scroll-utils/handle-scroll-utils.js
  var unsubscribeScrollStart = () => {
  };
  var unsubscribeScrollEnd = () => {
  };
  var debouceFunctionReference2 = () => {
  };
  function handleScrollUtils(type) {
    let initialized7 = false;
    const callbacks9 = /* @__PURE__ */ new Map();
    let isScrolling = false;
    function handler7() {
      isScrolling = false;
      if (callbacks9.size === 0) {
        unsubscribeScrollEnd();
        if (type === "START") {
          unsubscribeScrollStart();
        }
        initialized7 = false;
        return;
      }
      handleFrame.add(() => {
        handleNextTick.add(() => {
          const scrollData2 = {
            scrollY: window.scrollY
          };
          if (type === "END") {
            for (const value of callbacks9.values()) {
              value(scrollData2);
            }
          }
        }, 0);
      });
    }
    function init8() {
      if (initialized7) return;
      initialized7 = true;
      debouceFunctionReference2 = debounceFuncion(() => handler7());
      unsubscribeScrollEnd = handleScrollImmediate(debouceFunctionReference2);
      if (type === "START") {
        unsubscribeScrollStart = handleScrollImmediate(({ scrollY: scrollY2 }) => {
          const scrollData2 = {
            scrollY: scrollY2
          };
          if (!isScrolling) {
            isScrolling = true;
            for (const value of callbacks9.values()) {
              value(scrollData2);
            }
          }
        });
      }
    }
    const addCb6 = (cb) => {
      const id = getUnivoqueId();
      callbacks9.set(id, cb);
      if (typeof globalThis !== "undefined") {
        init8();
      }
      return () => callbacks9.delete(id);
    };
    return addCb6;
  }
  var handleScrollStart = handleScrollUtils("START");
  var handleScrollEnd = handleScrollUtils("END");

  // src/js/mob/mob-core/events/pointer-event/handle-pointer.js
  function handlePointer(eventType) {
    let initialized7 = false;
    const callbacks9 = /* @__PURE__ */ new Map();
    function handler7(event) {
      if (callbacks9.size === 0) {
        globalThis.removeEventListener(eventType, handler7);
        initialized7 = false;
        return;
      }
      for (const value of callbacks9.values()) {
        value(event);
      }
    }
    function init8() {
      if (initialized7) return;
      initialized7 = true;
      globalThis.addEventListener(eventType, handler7);
    }
    const addCallback2 = (cb) => {
      const id = getUnivoqueId();
      callbacks9.set(id, cb);
      if (typeof globalThis !== "undefined") {
        init8();
      }
      return () => callbacks9.delete(id);
    };
    return addCallback2;
  }
  var handlePointerOver = handlePointer("pointerover");
  var handlePointerDown = handlePointer("pointerdown");
  var handlePointerMove = handlePointer("pointermove");
  var handlePointerUp = handlePointer("pointerup");
  var handlePointerOut = handlePointer("pointerout");
  var handlePointerLeave = handlePointer("pointerleave");

  // src/js/mob/mob-core/modules.js
  function createStore(data) {
    return mobStore(data);
  }
  function getInstantFps() {
    return eventStore.getProp("instantFps");
  }
  function getFps() {
    return handleFrame.getFps();
  }
  function mustMakeSomething() {
    return handleFrame.mustMakeSomething();
  }
  function shouldMakeSomething() {
    return handleFrame.shouldMakeSomething();
  }
  function useFrame(callback2 = () => {
  }) {
    return handleFrame.add(callback2);
  }
  function useNextTick(callback2 = () => {
  }) {
    return handleNextTick.add(callback2);
  }
  function useNextFrame(callback2 = () => {
  }) {
    return handleNextFrame.add(callback2);
  }
  function useFrameIndex(callback2 = () => {
  }, frame = 0) {
    return handleFrameIndex.add(callback2, frame);
  }
  async function useFps(callback2 = () => {
  }) {
    const obj = await loadFps();
    callback2(obj);
    return obj;
  }
  function useLoad(callback2 = () => {
  }) {
    return handleLoad(callback2);
  }
  var useCache = handleCache;
  function useResize(callback2 = () => {
  }) {
    return handleResize(callback2);
  }
  function useVisibilityChange(callback2 = () => {
  }) {
    return handleVisibilityChange(callback2);
  }
  function useMouseClick(callback2 = () => {
  }) {
    return handleMouseClick(callback2);
  }
  function useMouseDown(callback2 = () => {
  }) {
    return handleMouseDown(callback2);
  }
  function useTouchStart(callback2 = () => {
  }) {
    return handleTouchStart(callback2);
  }
  function useMouseMove(callback2 = () => {
  }) {
    return handleMouseMove(callback2);
  }
  function useTouchMove(callback2 = () => {
  }) {
    return handleTouchMove(callback2);
  }
  function useMouseUp(callback2 = () => {
  }) {
    return handleMouseUp(callback2);
  }
  function useTouchEnd(callback2 = () => {
  }) {
    return handleTouchEnd(callback2);
  }
  function useMouseWheel(callback2 = () => {
  }) {
    return handleMouseWheel(callback2);
  }
  function useScroll(callback2 = () => {
  }) {
    return handleScroll(callback2);
  }
  function useScrollImmediate(callback2 = () => {
  }) {
    return handleScrollImmediate(callback2);
  }
  function useScrollThrottle(callback2 = () => {
  }) {
    return handleScrollThrottle(callback2);
  }
  function useScrollStart(callback2 = () => {
  }) {
    return handleScrollStart(callback2);
  }
  function useScrollEnd(callback2 = () => {
  }) {
    return handleScrollEnd(callback2);
  }
  function usePointerOver(callback2 = () => {
  }) {
    return handlePointerOver(callback2);
  }
  function usePointerDown(callback2 = () => {
  }) {
    return handlePointerDown(callback2);
  }
  function usePointerMove(callback2 = () => {
  }) {
    return handlePointerMove(callback2);
  }
  function usePointerUp(callback2 = () => {
  }) {
    return handlePointerUp(callback2);
  }
  function usePointerOut(callback2 = () => {
  }) {
    return handlePointerOut(callback2);
  }
  function usePointerLeave(callback2 = () => {
  }) {
    return handlePointerLeave(callback2);
  }
  var store = eventStore;

  // src/js/mob/mob-js/modules.js
  var modules_exports2 = {};
  __export(modules_exports2, {
    afterRouteChange: () => afterRouteChange,
    beforeRouteChange: () => beforeRouteChange,
    componentMap: () => componentMap,
    createComponent: () => createComponent,
    eventDelegationMap: () => eventDelegationMap,
    getActiveParams: () => getActiveParams,
    getActiveRoute: () => getActiveRoute,
    getChildrenIdByName: () => getChildrenIdByName,
    getComponentNameById: () => getComponentNameById,
    getDebugMode: () => getDebugMode,
    getIdByInstanceName: () => getIdByInstanceName,
    getNumberOfActiveInvalidate: () => getNumberOfActiveInvalidate,
    getNumberOfActiveRepeater: () => getNumberOfActiveRepeater,
    getParentIdById: () => getParentIdById,
    getPropsFromParent: () => getPropsFromParent,
    getRoot: () => getRoot,
    getStateById: () => getStateById,
    getStateByName: () => getStateByName,
    getTree: () => getTree,
    inizializeApp: () => inizializeApp,
    loadUrl: () => loadUrl,
    mainStore: () => mainStore,
    onRouteLoading: () => onRouteLoading,
    removeAndDestroyById: () => removeAndDestroyById,
    setStateById: () => setStateById,
    setStateByName: () => setStateByName,
    staticProps: () => staticProps,
    tempDelegateEventMap: () => tempDelegateEventMap,
    tick: () => tick,
    updateStateByName: () => updateStateByName,
    useComponent: () => useComponent,
    useMethodArrayByName: () => useMethodArrayByName,
    useMethodByName: () => useMethodByName,
    watchById: () => watchById
  });

  // src/js/mob/mob-js/main-store/constant.js
  var MAIN_STORE_ACTIVE_ROUTE = "activeRoute";
  var MAIN_STORE_ACTIVE_PARAMS = "activeParams";
  var MAIN_STORE_BEFORE_ROUTE_CHANGE = "beforeRouteChange";
  var MAIN_STORE_AFTER_ROUTE_CHANGE = "afterRouteChange";
  var MAIN_STORE_ROUTE_IS_LOADING = "routeIsLoading";
  var MAIN_STORE_ASYNC_PARSER = "repeaterParserAsync";

  // src/js/mob/mob-js/main-store/main-store.js
  var mainStore = modules_exports.createStore(
    /** @type {MobStoreParams<import('./type').MainStore>} */
    {
      [MAIN_STORE_ACTIVE_ROUTE]: () => ({
        value: { route: "", templateName: "" },
        type: "any",
        skipEqual: false
      }),
      [MAIN_STORE_ACTIVE_PARAMS]: () => ({
        value: {},
        type: "any",
        skipEqual: false
      }),
      [MAIN_STORE_BEFORE_ROUTE_CHANGE]: () => ({
        value: {
          currentRoute: "",
          currentTemplate: "",
          nextRoute: "",
          nextTemplate: ""
        },
        type: "any",
        skipEqual: false
      }),
      [MAIN_STORE_AFTER_ROUTE_CHANGE]: () => ({
        value: {
          currentRoute: "",
          currentTemplate: "",
          previousRoute: "",
          previousTemplate: ""
        },
        type: "any",
        skipEqual: false
      }),
      [MAIN_STORE_ROUTE_IS_LOADING]: () => ({
        value: false,
        type: Boolean
      }),
      [MAIN_STORE_ASYNC_PARSER]: {
        element: () => ({
          value: document.createElement("div"),
          type: HTMLElement,
          skipEqual: false
        }),
        parentId: () => ({
          value: "",
          type: String,
          skipEqual: false
        }),
        persistent: () => ({
          value: false,
          type: Boolean,
          skipEqual: false
        })
      }
    }
  );
  var resetMainStoreAsyncParser = () => {
    mainStore.set(
      MAIN_STORE_ASYNC_PARSER,
      {
        element: document.createElement("div"),
        parentId: "",
        persistent: false
      },
      { emit: false }
    );
  };

  // src/js/mob/mob-js/main-store/main-store-api.js
  var beforeRouteChange = (callback2) => {
    return mainStore.watch(
      MAIN_STORE_BEFORE_ROUTE_CHANGE,
      ({ currentRoute, currentTemplate, nextRoute, nextTemplate }) => {
        callback2({
          currentRoute,
          currentTemplate,
          nextRoute,
          nextTemplate
        });
      }
    );
  };
  var afterRouteChange = (callback2) => {
    return mainStore.watch(
      MAIN_STORE_AFTER_ROUTE_CHANGE,
      ({
        currentRoute,
        currentTemplate,
        previousRoute,
        previousTemplate
      }) => {
        callback2({
          currentRoute,
          currentTemplate,
          previousRoute,
          previousTemplate
        });
      }
    );
  };
  var onRouteLoading = (callback2) => {
    return mainStore.watch(MAIN_STORE_ROUTE_IS_LOADING, (state) => {
      callback2(state);
    });
  };
  var getActiveRoute = () => {
    const { activeRoute } = mainStore.get();
    return activeRoute;
  };
  var getActiveParams = () => {
    const { activeParams } = mainStore.get();
    return activeParams;
  };

  // src/js/mob/mob-js/component/component-map.js
  var componentMap = /* @__PURE__ */ new Map();

  // src/js/mob/mob-js/modules/repeater/repeat-id-placeholder-map.js
  var repeatIdPlaceHolderMap = /* @__PURE__ */ new Map();

  // src/js/mob/mob-js/modules/repeater/action/set-repeat-component-children.js
  var setRepeaterComponentChildren = ({ componentId, repeatId }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return;
    const { componentChildren } = item;
    repeatIdPlaceHolderMap.set(repeatId, {
      ...item,
      componentChildren: [...componentChildren, componentId]
    });
  };
  var removeRepeaterComponentChildren = ({ componentId, repeatId }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return;
    const { componentChildren } = item;
    repeatIdPlaceHolderMap.set(repeatId, {
      ...item,
      componentChildren: componentChildren.filter((id) => id !== componentId)
    });
  };
  var getRepeaterComponentChildren = ({ repeatId }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return [];
    const { componentChildren } = item;
    return componentChildren;
  };
  var repeaterhasComponentChildren = ({ repeatId }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return false;
    const { componentChildren } = item;
    return componentChildren.length > 0;
  };

  // src/js/mob/mob-js/component/weak-element-map.js
  var weakElementMap = /* @__PURE__ */ new WeakMap();
  var addElementToWeakElementMap = ({ element, id }) => {
    weakElementMap.set(element, id);
  };
  var getIdFromWeakElementMap = ({ element }) => {
    return weakElementMap.get(element);
  };

  // src/js/mob/mob-js/component/action/element.js
  var setElementById = ({
    id = "",
    newElement = document.createElement("div")
  }) => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    if (!item) return;
    componentMap.set(id, { ...item, element: newElement });
    addElementToWeakElementMap({ element: newElement, id });
  };
  var getElementById = ({ id = "" }) => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    return item?.element;
  };
  var getIdByElement = ({ element }) => {
    if (!element) return "";
    return getIdFromWeakElementMap({ element });
  };
  var getElementsByKeyAndRepeatId = ({
    keyValue = "",
    repeatId = ""
  }) => {
    if (keyValue?.length === 0) return [];
    const repeaterChildrenId = getRepeaterComponentChildren({ repeatId });
    const occurrence = repeaterChildrenId.map((id) => {
      return componentMap.get(id);
    }).filter((item) => item !== void 0);
    return occurrence.filter((item) => `${item.key}` === `${keyValue}`).map(({ element, id }) => ({
      element,
      id
    }));
  };
  var getIdsByByRepeatId = ({ id, repeatId }) => {
    if (!id || id === "") return [];
    const repeaterChildrenId = getRepeaterComponentChildren({ repeatId });
    return repeaterChildrenId.map((id2) => {
      return componentMap.get(id2);
    }).filter((item) => item !== void 0).map((item) => {
      return item.id;
    });
  };

  // src/js/mob/mob-js/constant.js
  var ATTR_IS_COMPONENT = "data-mobjs";
  var ATTR_COMPONENT_ID = "componentid";
  var ATTR_BIND_TEXT_ID = "bindtextid";
  var ATTR_BIND_OBJECT_ID = "bindobjectid";
  var ATTR_PROPS = "staticprops";
  var ATTR_BIND_PROPS = "bindprops";
  var ATTR_INSTANCENAME = "name";
  var ATTR_COMPONENT_NAME = "name";
  var ATTR_SLOT = "slot";
  var ATTR_CHILD_REPEATID = "repeaterchild";
  var ATTR_KEY = "key";
  var ATTR_CURRENT_LIST_VALUE = "currentRepeaterValue";
  var ATTR_REPEATER_PROP_BIND = "repeatPropBind";
  var ATTR_BIND_EVENTS = "bindevents";
  var ATTR_WEAK_BIND_EVENTS = "weakbindevents";
  var ATTR_BIND_EFFECT = "bindeffect";
  var ATTR_PARENT_ID = "parentid";
  var ATTR_BIND_REFS_ID = "bindrefid";
  var ATTR_BIND_REFS_NAME = "bindrefname";
  var ATTR_INVALIDATE = "invalidateid";
  var ATTR_MOBJS_REPEAT = "mobjsrepeat";
  var frameDelayAfterParse = 5;
  var DEFAULT_CURRENT_REPEATER_STATE = { current: {}, index: -1 };
  var QUEQUE_TYPE_BINDPROPS = "QUEQUE_BINDPROPS";
  var QUEQUE_TYPE_REPEATER = "QUEQUE_REPEATER";
  var QUEQUE_TYPE_INVALIDATE = "QUEQUE_INVALIDATE";

  // src/js/mob/mob-js/modules/repeater/repeat-id-host-map.js
  var repeatIdHostMap = /* @__PURE__ */ new Map();

  // src/js/mob/mob-js/modules/repeater/action/get-repeater-parent.js
  var getRepeatParent = ({ id }) => {
    if (!repeatIdPlaceHolderMap.has(id)) {
      return;
    }
    if (repeatIdHostMap.has(id)) {
      const host = repeatIdHostMap.get(id);
      host?.removeCustomComponent();
      host?.remove();
      repeatIdHostMap.delete(id);
    }
    const parent = repeatIdPlaceHolderMap.get(id);
    return parent?.element;
  };

  // src/js/mob/mob-js/component/action/repeater.js
  var setRepeaterStateById = ({ id = "", value }) => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    if (!item) return;
    componentMap.set(id, {
      ...item,
      currentRepeaterState: value
    });
  };
  var getFirstChildOfElementParentOfElement = ({ rootNode, currentNode }) => {
    if (!currentNode || !rootNode.contains(currentNode)) return;
    if (currentNode.parentElement === rootNode) return currentNode;
    return getFirstChildOfElementParentOfElement({
      rootNode,
      currentNode: currentNode.parentElement
    });
  };
  var findFirstRepeaterElementWrap = ({ rootNode, node }) => {
    if (!rootNode) return;
    return getFirstChildOfElementParentOfElement({
      rootNode,
      currentNode: node.parentElement
    });
  };
  var getRepeaterStateById = ({ id = "" }) => {
    if (!id || id === "") return DEFAULT_CURRENT_REPEATER_STATE;
    const item = componentMap.get(id);
    const currentRepeaterState = item?.currentRepeaterState;
    if (!currentRepeaterState) return DEFAULT_CURRENT_REPEATER_STATE;
    return currentRepeaterState;
  };
  var setRepeaterInnerWrap = ({ id = "", repeatId = "", element }) => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    if (!item) return;
    const repeaterParentElement = getRepeatParent({
      id: repeatId
    });
    const elementWrapper = findFirstRepeaterElementWrap({
      rootNode: (
        /** @type {HTMLElement} */
        repeaterParentElement
      ),
      node: (
        /** @type {HTMLElement} */
        element
      )
    });
    componentMap.set(id, {
      ...item,
      repeaterInnerWrap: elementWrapper
    });
  };
  var getRepeaterInnerWrap = ({ id }) => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    const repeaterInnerWrap = item?.repeaterInnerWrap;
    return repeaterInnerWrap;
  };

  // src/js/mob/mob-js/component/action/children.js
  var getChildrenIdByName = ({ id = "", componentName = "" }) => {
    if (!id || id === "") return [];
    const item = componentMap.get(id);
    const child = item?.child;
    if (!child) {
      console.warn(`getChildIdById failed no id found`);
      return [];
    }
    return child?.[componentName] ?? [];
  };
  var getOrderedChunkByCurrentRepeatValue = ({
    children,
    key,
    current,
    currentUnivoque,
    useIndex = false
  }) => {
    const currentParsed = useIndex ? current : currentUnivoque;
    const childrenRemapped = children.map((items) => {
      const { index: indexValue, current: currentValue } = getRepeaterStateById({
        id: items?.[0]
      });
      return {
        index: indexValue,
        key: currentValue?.[key],
        items
      };
    });
    const currentRemapped = currentParsed.map((item, index) => ({
      index,
      key: item?.[key]
    }));
    const orderdChildren = currentRemapped.map((currentItem) => {
      const prop = useIndex ? "index" : "key";
      return childrenRemapped.find(
        (childrenItem) => childrenItem[prop] === currentItem[prop]
      );
    }).filter((item) => item !== void 0);
    return orderdChildren.map(({ items }) => items);
  };

  // src/js/mob/mob-js/route/dom-ref/content.js
  var contentAttributeId = "";
  var DOMContentElement;
  var setContentId = ({ contentId = "" }) => {
    contentAttributeId = contentId;
  };
  var setContentElement = () => {
    DOMContentElement = document?.querySelector(contentAttributeId);
  };
  var getContentElement = () => DOMContentElement;

  // src/js/mob/mob-js/component/instance-map.js
  var instanceMap = /* @__PURE__ */ new Map();
  var addIdToInstanceMap = ({ instanceName, id }) => {
    const idCollection = instanceMap.get(instanceName) ?? [];
    instanceMap.set(instanceName, [...idCollection, id]);
  };
  var removeIdFromInstanceMap = ({ instanceName, id }) => {
    const idCollection = instanceMap.get(instanceName);
    if (!idCollection) return;
    const idCollectionFiltered = idCollection.filter((item) => item !== id);
    if (idCollectionFiltered.length === 0) {
      instanceMap.delete(instanceName);
    }
    if (idCollectionFiltered.length > 0) {
      instanceMap.set(instanceName, idCollectionFiltered);
    }
  };
  var getIdsFromInstanceMap = ({ instanceName }) => {
    return instanceMap.get(instanceName) ?? [];
  };

  // src/js/mob/mob-js/component/action/component.js
  var getComponentNameById = (id = "") => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    const component = item?.componentName;
    if (!component) {
      console.warn(`getComponentNameById failed no id found`);
      return null;
    }
    return component;
  };
  var getComponentNameByElement = (element) => {
    if (!element) return "name-not-found";
    const id = getIdFromWeakElementMap({ element }) ?? "";
    const item = componentMap.get(id);
    if (!item) return "name-not-found";
    return item.componentName;
  };
  var getIdByInstanceName = (name = "") => {
    if (!name) return;
    const idCollection = getIdsFromInstanceMap({ instanceName: name });
    return idCollection?.[0];
  };
  var getIdArrayByInstanceName = (name = "") => {
    if (!name) return [];
    return getIdsFromInstanceMap({ instanceName: name }) ?? [];
  };
  var componentIsPersistent = (id = "") => {
    if (!id || id === "") return false;
    const item = componentMap.get(id);
    const element = item?.element;
    if (!element) return false;
    const contentElement = getContentElement();
    return !contentElement?.contains(element);
  };

  // src/js/mob/mob-js/component/action/get-tree.js
  var getTreeRecursive = ({ chunk }) => {
    return chunk.reduce((previous, current) => {
      const [key, value] = current;
      const { child, componentName, instanceName } = value;
      const childrenId = new Set(Object.values(child ?? {}).flat());
      const childrenChunk = [];
      for (const item of componentMap.entries()) {
        const [key2] = item;
        if (childrenId.has(key2)) childrenChunk.push(item);
      }
      return [
        ...previous,
        {
          id: key,
          componentName,
          instanceName,
          children: getTreeRecursive({
            chunk: childrenChunk
          })
        }
      ];
    }, []);
  };
  var getTree = () => {
    const chunk = [...componentMap.entries()].filter(
      ([, value]) => !value?.parentId || value?.parentId === ""
    );
    return getTreeRecursive({ chunk });
  };

  // src/js/mob/mob-js/component/action/methods.js
  var addMethodById = ({ id, name, fn }) => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    const methods = item?.methods;
    if (!methods) return;
    if (name in methods) {
      console.warn(`Method ${name}, is already used by ${id}`);
      return;
    }
    componentMap.set(id, {
      ...item,
      methods: { ...methods, [name]: fn }
    });
  };
  var getMethodsById = ({ id }) => {
    if (!id || id === "") return {};
    const item = componentMap.get(id);
    const methods = item?.methods;
    if (!methods) return {};
    if (Object.keys(methods).length === 0) {
      console.warn(`no methods available for ${id} component`);
      return {};
    }
    return methods;
  };
  var useMethodByName = (name) => {
    const id = getIdByInstanceName(name);
    if (!id || id === "") return;
    const methods = getMethodsById({ id });
    if (Object.keys(methods).length === 0) {
      console.warn(`no methods available for ${name} component`);
      return;
    }
    return methods;
  };
  var useMethodArrayByName = (name) => {
    const ids = getIdArrayByInstanceName(name);
    return ids.map((id) => getMethodsById({ id })).filter((method) => {
      return Object.keys(method).length > 0;
    });
  };

  // src/js/mob/mob-js/parse/strategy.js
  var useQuery = false;
  var useSlotQuery = false;
  var useComponentHasNamedSlotQuery = true;
  var autoDetectParentId = true;
  var useParentIdQuery = true;
  var useRepeatWithoutSyncQuery = false;

  // src/js/mob/mob-js/query/query-all-future-component.js
  function* walkPreOrder(node) {
    if (!node) return;
    yield node;
    for (const child of node.children) {
      yield* walkPreOrder(child);
    }
  }
  function selectAll(root2, firstOccurrence) {
    const result = [];
    for (const node of walkPreOrder(root2)) {
      if (result.length > 0 && firstOccurrence) break;
      if (node?.getIsPlaceholder?.()) {
        result.push(
          /** @type {UserComponent} */
          node
        );
      }
    }
    return result;
  }
  var queryAllFutureComponent = (node, firstOccurence = true) => {
    let result = [];
    const root2 = node || document.body;
    for (const child of root2.children) {
      result = [...result, ...selectAll(child, firstOccurence)];
    }
    return result;
  };

  // src/js/mob/mob-js/modules/user-component/index.js
  var userPlaceholder = /* @__PURE__ */ new Set();
  var skipAddUserComponent = false;
  var addUserPlaceholder = (element) => {
    userPlaceholder.add(element);
  };
  var removeUserPlaceholder = (element) => {
    userPlaceholder.delete(element);
  };
  var getFirstUserChildPlaceHolder = (element) => {
    let userComponent;
    for (const item of userPlaceholder) {
      if (element?.contains(item) && item.getIsPlaceholder()) {
        userComponent = item;
        break;
      }
    }
    if (!userComponent) return [];
    userPlaceholder.delete(userComponent);
    return [userComponent];
  };
  var getAllUserChildPlaceholder = ({ element }) => {
    return [...userPlaceholder].filter((component) => {
      return element.contains(component) && element !== component && component.getIsPlaceholder?.();
    }) ?? [];
  };
  var getAllUserComponentUseNamedSlot = ({ element }) => {
    return [...userPlaceholder].filter((component) => {
      return element.contains(component) && element !== component && component.getIsPlaceholder?.() && component?.getSlotPosition?.();
    }) ?? [];
  };
  var getUserChildPlaceholderSize = () => {
    return userPlaceholder.size;
  };
  var setSkipAddUserComponent = (value) => {
    skipAddUserComponent = value;
  };
  var getSkipAddUserComponent = () => skipAddUserComponent;

  // src/js/mob/mob-js/component/utils.js
  var updateChildrenArray = ({
    currentChild,
    id = "",
    componentName = ""
  }) => {
    const childGroupByName = currentChild?.[componentName] ?? [];
    currentChild[componentName] = [...childGroupByName, id];
    return currentChild;
  };
  var removeChildFromChildrenArray = ({
    currentChild,
    id = "",
    componentName = ""
  }) => {
    const childGroupByName = currentChild?.[componentName] ?? [];
    currentChild[componentName] = childGroupByName.filter(
      (currentId) => {
        return id !== currentId;
      }
    );
    return currentChild;
  };
  var addPropsToState = ({ props, store: store2 }) => {
    Object.entries(props).forEach(([key, value]) => {
      store2.set(key, value);
    });
  };

  // src/js/mob/mob-js/component/action/parent.js
  var getParentIdById = (id = "") => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    const parentId = item?.parentId;
    if (!parentId) {
      return;
    }
    return parentId;
  };
  var addSelfIdToParentComponent = ({ id = "" }) => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    const parentId = item?.parentId;
    const componentName = item?.componentName ?? "";
    if (!parentId) return;
    const value = componentMap.get(parentId);
    if (!value) return;
    const { child } = value;
    if (!child) return;
    componentMap.set(parentId, {
      ...value,
      child: {
        ...child,
        ...updateChildrenArray({
          currentChild: child,
          id,
          componentName
        })
      }
    });
  };
  var addParentIdToFutureComponent = ({ element, id }) => {
    if (!element) return;
    if (useParentIdQuery) {
      const children = queryAllFutureComponent(element, false);
      children.forEach((child) => {
        child.setParentId(id);
      });
      return;
    }
    const childrenComponent = getAllUserChildPlaceholder({ element });
    childrenComponent.forEach((component) => {
      component.setParentId(id);
    });
  };
  var getParentIdFromWeakElementMap = ({ element }) => {
    if (!element) return;
    let parentNode = element.parentNode;
    let id;
    while (parentNode && !id) {
      id = getIdFromWeakElementMap({
        element: (
          /** @type {HTMLElement} */
          parentNode
        )
      });
      if (!id) {
        parentNode = parentNode.parentNode;
      }
    }
    return id ?? "";
  };
  var compareIdOrParentIdRecursive = ({ id, compareValue }) => {
    if (id === compareValue) return true;
    const item = componentMap.get(id);
    if (!item) return false;
    const parentId = item?.parentId ?? "";
    return compareIdOrParentIdRecursive({ id: parentId, compareValue });
  };

  // src/js/mob/mob-js/modules/bind-props/bind-props-map.js
  var bindPropsMap = /* @__PURE__ */ new Map();
  var bindComponentTobindId = /* @__PURE__ */ new Map();

  // src/js/mob/mob-js/modules/bind-props/remove-current-id-to-bind-props.js
  var removeCurrentIdToBindProps = ({ componentId }) => {
    if (!componentId) return;
    for (const [key, value] of bindPropsMap) {
      const { componentId: currentComponentId } = value;
      if (currentComponentId === componentId) {
        bindPropsMap.delete(key);
      }
    }
  };

  // src/js/mob/mob-js/component/action/watch.js
  var watchById = (id = "", prop = "", cb = () => {
  }, { wait = false } = {}) => {
    if ((!id || id === "") && (!prop || prop === "")) return;
    const item = componentMap.get(id);
    const state = item?.state;
    return state?.watch(prop, cb, { wait: wait ?? false });
  };

  // src/js/mob/mob-js/modules/static-props/index.js
  var staticPropsMap = /* @__PURE__ */ new Map();
  var setStaticProps = (props = {}) => {
    const id = modules_exports.getUnivoqueId();
    staticPropsMap.set(id, props);
    return id;
  };
  var getPropsFromParent = (id = "") => {
    const props = staticPropsMap.get(id);
    staticPropsMap.delete(id);
    return props ?? {};
  };
  var removeOrphansPropsFromParent = () => {
    staticPropsMap.clear();
  };

  // src/js/mob/mob-js/utils.js
  var staticProps = (props = {}) => {
    return `${ATTR_PROPS}="${setStaticProps(props)}"`;
  };
  var clamp2 = (num, lower, upper) => {
    return Math.min(Math.max(num, lower), upper);
  };
  var detectProp = (prop) => {
    const isString = modules_exports.checkType(String, prop);
    if (isString) return (
      /** @type {string} */
      prop
    );
    current_key_exports.initializeCurrentDependencies();
    prop();
    return current_key_exports.getFirstCurrentDependencies();
  };

  // src/js/mob/mob-js/modules/bind-object/index.js
  var bindObjectMap = /* @__PURE__ */ new Map();
  var bindObjectPlaceHolderMap = /* @__PURE__ */ new Map();
  var addBindObjectPlaceHolderMap = ({
    host,
    componentId,
    bindObjectId
  }) => {
    bindObjectPlaceHolderMap.set(host, {
      componentId,
      bindObjectId
    });
  };
  var getBindObjectKeys = (values) => {
    return values.map(
      (item) => {
        return "observe" in item ? (() => {
          return detectProp(
            /** @type{string|(() => any)} */
            item.observe
          );
        })() : (() => {
          current_key_exports.initializeCurrentDependencies();
          if ("value" in item) {
            item?.value();
          } else {
            item();
          }
          return current_key_exports.getFirstCurrentDependencies();
        })();
      }
    );
  };
  var renderBindObject = (strings, ...values) => {
    return strings.raw.reduce((accumulator, currentText, i) => {
      return values?.[i] && "value" in values[i] ? accumulator + currentText + (values?.[i]?.value?.() ?? "") : accumulator + currentText + (values?.[i]?.() ?? "");
    }, "");
  };
  var addBindObjectParent = ({ id, bindObjectId, parentElement }) => {
    const items = bindObjectMap.get(id);
    const itemsUpdated = items && items.length > 0 ? (() => {
      const itemsFiltered = items.filter(
        (item) => item.bindObjectId !== bindObjectId
      );
      return [
        ...itemsFiltered,
        { parentNode: parentElement, bindObjectId }
      ];
    })() : [{ parentNode: parentElement, bindObjectId }];
    bindObjectMap.set(id, itemsUpdated);
  };
  var removeBindObjectByBindObjectId = ({ id, bindObjectId }) => {
    const items = bindObjectMap.get(id);
    if (!items) return;
    const itemsUpdated = items.filter(
      (item) => item.bindObjectId !== bindObjectId
    );
    bindObjectMap.set(id, itemsUpdated);
  };
  var switchBindObjectMap = () => {
    [...bindObjectPlaceHolderMap].forEach(
      ([placeholder, { componentId, bindObjectId }]) => {
        const parentElement = placeholder.parentElement;
        if (!parentElement) return;
        addBindObjectParent({
          id: componentId,
          bindObjectId,
          parentElement
        });
        placeholder?.removeCustomComponent?.();
        placeholder?.remove();
      }
    );
    bindObjectPlaceHolderMap.clear();
  };
  var removeBindObjectParentById = ({ id }) => {
    bindObjectMap.delete(id);
  };
  var getParentBindObject = ({ id, bindObjectId }) => {
    const item = bindObjectMap.get(id);
    if (!item) return;
    const current = item.find((item2) => {
      return bindObjectId === item2.bindObjectId;
    });
    return current?.parentNode;
  };
  var getBindObjectParentSize = () => {
    return [...bindObjectMap].reduce(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (previous, [_, values]) => previous + values.length,
      0
    );
  };
  var createBindObjectWatcher = (id, bindObjectId, keys, render2) => {
    let watchIsRunning = false;
    let ref;
    const unsubScribeFunction = keys.map((state) => {
      return watchById(id, state, () => {
        if (watchIsRunning) return;
        watchIsRunning = true;
        modules_exports.useNextLoop(() => {
          modules_exports.useFrame(() => {
            if (!ref) {
              let refElement = getParentBindObject({
                id,
                bindObjectId
              });
              if (refElement) {
                ref = new WeakRef(refElement);
                removeBindObjectByBindObjectId({
                  id,
                  bindObjectId
                });
                refElement = null;
              }
            }
            if (ref && ref?.deref()) {
              ref.deref().textContent = "";
              ref.deref().insertAdjacentHTML("afterbegin", render2());
            }
            watchIsRunning = false;
            modules_exports.useNextTick(async () => {
              if (!ref || !ref?.deref()) {
                unsubScribeFunction.forEach((fn) => {
                  if (fn) fn();
                });
                unsubScribeFunction.length = 0;
              }
            });
          });
        });
      });
    });
  };

  // src/js/mob/mob-js/component/action/state/get-state-by-id.js
  var getStateById = (id = "") => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    const state = item?.state;
    return state?.get();
  };

  // src/js/mob/mob-js/modules/bind-text/index.js
  var bindTextMap = /* @__PURE__ */ new Map();
  var bindTextPlaceHolderMap = /* @__PURE__ */ new Map();
  var addBindTextPlaceHolderMap = ({
    host,
    componentId,
    bindTextId
  }) => {
    bindTextPlaceHolderMap.set(host, {
      componentId,
      bindTextId
    });
  };
  var arrayValuesFromProp = (value) => value.match(/(?<=\[).+?(?=])/g);
  var splitPropUntilSquare = (value) => value.split("[")?.[0];
  var parsePropValue = ({ previous, current }) => {
    const arrayValues = arrayValuesFromProp(current);
    const isArray = arrayValues && arrayValues?.length > 0;
    return isArray ? arrayValues.reduce(
      (accumulator, currentProp) => accumulator?.[currentProp],
      previous[splitPropUntilSquare(current)]
    ) : previous?.[current];
  };
  var renderBindText = (id, strings, ...values) => {
    const props = getStateById(id);
    const states = values.map((prop) => {
      const propsToArray = prop.split(".");
      return propsToArray.reduce(
        (previous, current) => {
          const finalPropValue = parsePropValue({ previous, current });
          return finalPropValue ?? previous;
        },
        props
      );
    });
    return strings.raw.reduce(
      (accumulator, currentText, i) => accumulator + currentText + (states?.[i] ?? ""),
      ""
    );
  };
  var addBindTextParent = ({ id, bindTextId, parentElement }) => {
    const items = bindTextMap.get(id);
    const itemsUpdated = items && items.length > 0 ? (() => {
      const itemsFiltered = items.filter(
        (item) => item.bindTextId !== bindTextId
      );
      return [
        ...itemsFiltered,
        { parentNode: parentElement, bindTextId }
      ];
    })() : [{ parentNode: parentElement, bindTextId }];
    bindTextMap.set(id, itemsUpdated);
  };
  var removeBindTextByBindTextId = ({ id, bindTextId }) => {
    const items = bindTextMap.get(id);
    if (!items) return;
    const itemsUpdated = items.filter((item) => item.bindTextId !== bindTextId);
    bindTextMap.set(id, itemsUpdated);
  };
  var switchBindTextMap = () => {
    [...bindTextPlaceHolderMap].forEach(
      ([placeholder, { componentId, bindTextId }]) => {
        const parentElement = placeholder.parentElement;
        if (!parentElement) return;
        addBindTextParent({
          id: componentId,
          bindTextId,
          parentElement
        });
        placeholder?.removeCustomComponent?.();
        placeholder?.remove();
      }
    );
    bindTextPlaceHolderMap.clear();
  };
  var removeBindTextParentById = ({ id }) => {
    bindTextMap.delete(id);
  };
  var getParentBindText = ({ id, bindTextId }) => {
    const item = bindTextMap.get(id);
    if (!item) return;
    const current = item.find((item2) => {
      return bindTextId === item2.bindTextId;
    });
    return current?.parentNode;
  };
  var getBindTextParentSize = () => {
    return [...bindTextMap].reduce(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (previous, [_, values]) => previous + values.length,
      0
    );
  };
  var getBindTextPlaceholderSize = () => bindTextPlaceHolderMap.size;
  var createBindTextWatcher = (id, bindTextId, render2, ...props) => {
    let watchIsRunning = false;
    let ref;
    const unsubScribeFunction = props.map((state) => {
      const propsToArray = state.split(".");
      const stateToWatch = propsToArray?.[0];
      const arrayValues = arrayValuesFromProp(stateToWatch);
      const isArray = arrayValues && arrayValues?.length > 0;
      const finalStateTowatch = isArray ? splitPropUntilSquare(stateToWatch) : stateToWatch;
      if (!finalStateTowatch) return;
      return watchById(id, finalStateTowatch, () => {
        if (watchIsRunning) return;
        watchIsRunning = true;
        modules_exports.useNextLoop(() => {
          modules_exports.useFrame(() => {
            if (!ref) {
              let refElement = getParentBindText({
                id,
                bindTextId
              });
              if (refElement) {
                ref = new WeakRef(refElement);
                removeBindTextByBindTextId({ id, bindTextId });
                refElement = null;
              }
            }
            if (ref && ref?.deref()) {
              ref.deref().textContent = "";
              ref.deref().insertAdjacentHTML("afterbegin", render2());
            }
            watchIsRunning = false;
            modules_exports.useNextTick(async () => {
              if (!ref || !ref?.deref()) {
                unsubScribeFunction.forEach((fn) => {
                  if (fn) fn();
                });
                unsubScribeFunction.length = 0;
              }
            });
          });
        });
      });
    });
  };

  // src/js/mob/mob-js/modules/invalidate/invalidate-function-map.js
  var invalidateFunctionMap = /* @__PURE__ */ new Map();

  // src/js/mob/mob-js/modules/invalidate/invalidate-id-placeholder-map.js
  var invalidateIdPlaceHolderMap = /* @__PURE__ */ new Map();

  // src/js/mob/mob-js/modules/invalidate/action/remove-invalidate-id.js
  var removeInvalidateId = ({ id }) => {
    if (invalidateFunctionMap.has(id)) {
      const value = invalidateFunctionMap.get(id);
      if (!value) return;
      value.forEach(({ invalidateId }) => {
        if (invalidateIdPlaceHolderMap.has(invalidateId)) {
          invalidateIdPlaceHolderMap.delete(invalidateId);
        }
      });
      invalidateFunctionMap.delete(id);
    }
  };

  // src/js/mob/mob-js/modules/repeater/repeat-function-map.js
  var repeatFunctionMap = /* @__PURE__ */ new Map();

  // src/js/mob/mob-js/modules/repeater/action/remove-repeater-id.js
  var removeRepeaterId = ({ id }) => {
    if (repeatFunctionMap.has(id)) {
      const value = repeatFunctionMap.get(id);
      if (!value) return;
      value.forEach(({ repeatId }) => {
        if (repeatIdPlaceHolderMap.has(repeatId)) {
          repeatIdPlaceHolderMap.delete(repeatId);
        }
      });
      repeatFunctionMap.delete(id);
    }
  };

  // src/js/mob/mob-js/component/action/remove-and-destroy/remove-itself-from-parent.js
  var removeItselfFromParent = ({ id, parentId, componentName }) => {
    if (!id) return;
    const value = componentMap.get(parentId ?? "");
    if (!value) return;
    const { child } = value;
    if (!parentId || !child) return;
    componentMap.set(parentId, {
      ...value,
      child: {
        ...child,
        ...removeChildFromChildrenArray({
          currentChild: child,
          id,
          componentName
        })
      }
    });
  };

  // src/js/mob/mob-js/component/non-persisitent-set.js
  var nonPersisitentComponentSet = /* @__PURE__ */ new Set();

  // src/js/mob/mob-js/component/action/remove-and-destroy/cancellable-component/remove-persisitent-component.js
  var removeNonPersisitentComponent = (id) => {
    nonPersisitentComponentSet.delete(id);
  };

  // src/js/mob/mob-js/component/action/remove-and-destroy/remove-and-destroy-by-id.js
  var removeAndDestroyById = ({ id = "" }) => {
    if (!id || id === "") return;
    const instanceValue = componentMap.get(id);
    if (!instanceValue) return;
    const {
      parentId,
      componentName,
      child,
      element,
      state,
      destroy: destroy3,
      parentPropsWatcher,
      componentRepeatId,
      instanceName,
      persistent
    } = instanceValue;
    Object.values(child ?? {}).flat().forEach((childId) => {
      removeAndDestroyById({ id: childId });
    });
    removeItselfFromParent({ id, parentId, componentName });
    destroy3?.();
    state.destroy();
    if (parentPropsWatcher) parentPropsWatcher.forEach((unwatch) => unwatch());
    removeInvalidateId({ id });
    removeRepeaterId({ id });
    removeBindTextParentById({ id });
    removeBindObjectParentById({ id });
    if (componentRepeatId && componentRepeatId.length > 0) {
      removeRepeaterComponentChildren({
        componentId: id,
        repeatId: componentRepeatId
      });
    }
    if (instanceName && instanceName.length > 0) {
      removeIdFromInstanceMap({ instanceName, id });
    }
    if (!persistent) {
      removeNonPersisitentComponent(id);
    }
    removeCurrentIdToBindProps({ componentId: id });
    element?.removeCustomComponent?.();
    element?.remove();
    instanceValue.methods = null;
    instanceValue.refs = null;
    instanceValue.repeaterInnerWrap = null;
    instanceValue.element = null;
    instanceValue.currentRepeaterState = null;
    instanceValue.state = null;
    componentMap.delete(id);
  };

  // src/js/mob/mob-js/component/action/state/get-state-by-name.js
  var getStateByName = (name = "") => {
    const id = getIdByInstanceName(name);
    if (!id) console.warn(`component ${name}, not found`);
    return getStateById(id);
  };

  // src/js/mob/mob-js/component/action/freeze.js
  var freezePropById = ({ id = "", prop }) => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    if (!item) return;
    const { freezedPros } = item;
    if (!freezedPros) return;
    componentMap.set(id, {
      ...item,
      freezedPros: [.../* @__PURE__ */ new Set([...freezedPros, prop])]
    });
  };
  var unFreezePropById = ({ id = "", prop }) => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    if (!item) return;
    const { freezedPros } = item;
    if (!freezedPros) return;
    componentMap.set(id, {
      ...item,
      freezedPros: freezedPros.filter((currentProp) => currentProp !== prop)
    });
  };
  var getFreezePropStatus = ({ id = "", prop }) => {
    if (!id || id === "") return false;
    const item = componentMap.get(id);
    const freezedPros = item?.freezedPros;
    if (!freezedPros) return false;
    return freezedPros.includes(prop);
  };

  // src/js/mob/mob-js/modules/repeater/action/set-parent-repeater.js
  var setParentRepeater = ({ repeatId, host }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return;
    const parent = (
      /** @type {HTMLElement} */
      host.parentNode
    );
    item.initialRenderWithoutSync.forEach((element) => {
      parent.append(element);
    });
    repeatIdPlaceHolderMap.set(repeatId, {
      ...item,
      element: parent,
      initialRenderWithoutSync: []
    });
    repeatIdHostMap.set(repeatId, host);
  };

  // src/js/mob/mob-js/web-component/repeat.js
  var defineRepeatComponent = () => {
    customElements.define(
      "mobjs-repeat",
      class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          const skip = getSkipAddUserComponent();
          if (skip) return;
          const { dataset } = this.shadowRoot?.host ?? {};
          if (dataset) {
            const host = (
              /** @type {HTMLElement} */
              this.shadowRoot?.host
            );
            const repeatId = host?.getAttribute(ATTR_MOBJS_REPEAT) ?? "";
            setParentRepeater({ repeatId, host });
          }
        }
        removeCustomComponent() {
          if (!this.shadowRoot) return;
          this.parentElement?.removeChild(this);
        }
      }
    );
  };

  // src/js/mob/mob-js/modules/invalidate/invalidate-id-host-map.js
  var invalidateIdHostMap = /* @__PURE__ */ new Map();

  // src/js/mob/mob-js/modules/invalidate/action/set-parent-invalidate.js
  var setParentInvalidate = ({ invalidateId, host }) => {
    const item = invalidateIdPlaceHolderMap.get(invalidateId);
    if (!item) return;
    const parent = (
      /** @type {HTMLElement} */
      host.parentNode
    );
    invalidateIdPlaceHolderMap.set(invalidateId, {
      ...item,
      element: parent
    });
    invalidateIdHostMap.set(invalidateId, host);
  };

  // src/js/mob/mob-js/web-component/invalidate.js
  var defineInvalidateComponent = () => {
    customElements.define(
      "mobjs-invalidate",
      class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          const { dataset } = this.shadowRoot?.host ?? {};
          if (dataset) {
            const host = (
              /** @type {HTMLElement} */
              this.shadowRoot?.host
            );
            const invalidateId = host.getAttribute(ATTR_INVALIDATE) ?? "";
            setParentInvalidate({ invalidateId, host });
          }
        }
        removeCustomComponent() {
          if (!this.shadowRoot) return;
          this.parentElement?.removeChild(this);
        }
      }
    );
  };

  // src/js/mob/mob-js/modules/slot/index.js
  var slotPlaceholder = /* @__PURE__ */ new Set();
  var addSlotPlaceholder = (slot) => {
    slotPlaceholder.add(slot);
  };
  var clearSlotPlaceHolder = () => {
    slotPlaceholder.clear();
  };
  var getUnamedPlaceholderSlot = ({ element }) => {
    return [...slotPlaceholder].find((slot) => {
      const hasSlot = !slot?.getSlotName?.() && element.contains(slot);
      if (hasSlot) slotPlaceholder.delete(slot);
      return hasSlot;
    });
  };
  var getSlotByName = ({ name, element }) => {
    return [...slotPlaceholder].find((slot) => {
      const hasSlot = slot?.getSlotName?.() === name && element.contains(slot);
      if (hasSlot) slotPlaceholder.delete(slot);
      return hasSlot;
    });
  };
  var getAllSlot = () => {
    return [...slotPlaceholder];
  };
  var getSlotPlaceholderSize = () => {
    return slotPlaceholder.size;
  };

  // src/js/mob/mob-js/web-component/slot.js
  var defineSlotComponent = () => {
    customElements.define(
      "mobjs-slot",
      class extends HTMLElement {
        /**
         * @type {string | undefined | null}
         */
        #slotName;
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          this.#slotName = "";
          this.isSlot = true;
          const { dataset } = this.shadowRoot?.host ?? {};
          if (dataset) {
            this.#slotName = this.shadowRoot?.host.getAttribute(ATTR_COMPONENT_NAME);
          }
        }
        connectedCallback() {
          const host = this.shadowRoot?.host;
          if (!host) return;
          if (!useSlotQuery) addSlotPlaceholder(host);
        }
        removeCustomComponent() {
          if (!this.shadowRoot) return;
          this.parentElement?.removeChild(this);
        }
        getSlotName() {
          return this.#slotName;
        }
      }
    );
  };

  // src/js/mob/mob-js/component/in-memory-element-set.js
  var inMemoryElementSet = /* @__PURE__ */ new Set();
  var addElementToInMemorySet = (element) => {
    inMemoryElementSet.add(element);
  };
  var getInMemorySet = () => {
    return [...inMemoryElementSet];
  };
  var cleanInMemorySet = (element) => inMemoryElementSet.delete(element);

  // src/js/mob/mob-js/web-component/user-component.js
  var defineUserComponent = (componentList) => {
    Object.entries(componentList).forEach(([key, value]) => {
      const {
        connectedCallback: _connectedCallBack,
        disconnectedCallback: _disconnectedCallback,
        adoptedCallback: _adoptedCallback,
        attributeChangedCallback: _attributeChangedCallback,
        style,
        attributeToObserve
      } = value.componentParams;
      customElements.define(
        key,
        class extends HTMLElement {
          /**
           * @type {string}
           */
          #componentname;
          /**
           * @type {string}
           */
          #componentId;
          /**
           * @type {import('../type').ComponentPropsType<
           *     import('../type').MobComponentMap,
           *     import('../type').MobComponentMap
           * >}
           */
          #params;
          /**
           * @type {boolean}
           */
          #isPlaceholder;
          /**
           * @type {string | undefined | null}
           */
          #name;
          /**
           * @type {string | undefined | null}
           */
          #staticPropsId;
          /**
           * @type {string | undefined | null}
           */
          #dynamicPropsId;
          /**
           * @type {string | undefined | null}
           */
          #bindEventsId;
          /**
           * @type {string}
           */
          #dynamicPropsFromSlotId;
          /**
           * @type {string}
           */
          #propsFromSlotId;
          /**
           * @type {string | undefined | null}
           */
          #currentRepeatValueId;
          /**
           * @type {string | undefined | null}
           */
          #slotPosition;
          /**
           * @type {string | undefined | null}
           */
          #currentKey;
          /**
           * @type {string | undefined | null}
           */
          #parentId;
          /**
           * @type {string | undefined | null}
           */
          #componentRepeatId;
          /**
           * @type {string | undefined | null}
           */
          #delegateEventId;
          /**
           * @type {string | undefined | null}
           */
          #repeatPropBind;
          /**
           * @type {string | undefined | null}
           */
          #bindRefId;
          /**
           * @type {string | undefined | null}
           */
          #bindRefName;
          static get observedAttributes() {
            return attributeToObserve;
          }
          constructor() {
            super();
            this.attachShadow({ mode: "open" });
            this.active = false;
            this.#componentId = modules_exports.getUnivoqueId();
            this.#params = {};
            this.#componentname = key;
            this.#isPlaceholder = true;
            this.isUserComponent = true;
            this.#dynamicPropsFromSlotId = "";
            this.#propsFromSlotId = "";
            const host = this.shadowRoot?.host;
            if (!host) return;
            const skip = getSkipAddUserComponent();
            if (skip && !useRepeatWithoutSyncQuery) {
              addElementToInMemorySet(
                /** @type {import('./type').UserComponent} */
                host
              );
            }
            if (skip) {
              return;
            }
            if (this.#slotPosition && !this.active) {
              this.style.visibility = "hidden";
            }
            if (!this.shadowRoot) return;
            if (style) {
              const styleTag = document.createElement("style");
              styleTag.textContent = style;
              this.shadowRoot.append(styleTag);
            }
            const slot = document.createElement("slot");
            this.shadowRoot.append(slot);
          }
          getComponentName() {
            return this.#componentname;
          }
          /**
           * @param {string} value
           */
          setId(value2) {
            this.#componentId = value2;
          }
          getId() {
            return this.#componentId;
          }
          getParentId() {
            return this.#parentId;
          }
          /**
           * @param {string} id
           */
          setParentId(id) {
            this.#parentId = id;
          }
          getIsPlaceholder() {
            return this.#isPlaceholder;
          }
          getInstanceName() {
            return this.#name;
          }
          getStaticPropsId() {
            return this.#staticPropsId;
          }
          getDynamicPropsid() {
            return this.#dynamicPropsId;
          }
          getBindEventsId() {
            return this.#bindEventsId;
          }
          getCurrentKey() {
            return this.#currentKey;
          }
          /**
           * @param {string} value
           */
          setDynamicPropsFromSlotId(value2) {
            this.#dynamicPropsFromSlotId = value2;
          }
          getDynamicPropsFromSlotId() {
            return this.#dynamicPropsFromSlotId;
          }
          /**
           * @param {string} value
           */
          setPropsFromSlotId(value2) {
            this.#propsFromSlotId = value2;
          }
          getPropsFromSlotId() {
            return this.#propsFromSlotId;
          }
          /**
           * @param {any} value
           */
          setRepeatValue(value2) {
            this.#currentRepeatValueId = value2;
          }
          getRepeatValue() {
            return this.#currentRepeatValueId;
          }
          getSlotPosition() {
            return this.#slotPosition;
          }
          getDelegateEventId() {
            return this.#delegateEventId;
          }
          getRepeaterPropBind() {
            return this.#repeatPropBind ?? void 0;
          }
          /**
           * @param {string} value
           */
          setRepeaterPropBind(value2) {
            this.#repeatPropBind = value2;
          }
          getComponentRepeatId() {
            return this.#componentRepeatId;
          }
          getBindRefId() {
            return this.#bindRefId;
          }
          getBindRefName() {
            return this.#bindRefName;
          }
          resetParams() {
            this.active = false;
            this.#componentId = "";
            this.#params = {};
          }
          /**
           * Disable placeholder state before add to DOM
           *
           * @returns Void
           */
          disablePlaceHolderState() {
            this.#isPlaceholder = false;
          }
          /**
           * Add params after web component ( not placeholder ) is added to DOM.
           *
           * @param {import('../type').ComponentPropsType<
           *     import('../type').MobComponentMap,
           *     import('../type').MobComponentMap
           * >} data
           */
          inizializeCustomComponent(data) {
            if (this.active) return;
            this.active = true;
            this.#componentId = data.id;
            this.#params = data;
            this.#isPlaceholder = false;
            _connectedCallBack?.({
              context: this,
              params: this.#params
            });
          }
          connectedCallback() {
            const skip = getSkipAddUserComponent();
            if (skip) return;
            if (this.#isPlaceholder) {
              const host = this.shadowRoot?.host;
              if (host) {
                [
                  this.#name,
                  this.#staticPropsId,
                  this.#dynamicPropsId,
                  this.#currentKey,
                  this.#bindEventsId,
                  this.#currentRepeatValueId,
                  this.#slotPosition,
                  this.#parentId,
                  this.#componentRepeatId,
                  this.#delegateEventId,
                  this.#repeatPropBind,
                  this.#bindRefId,
                  this.#bindRefName
                ] = [
                  ATTR_INSTANCENAME,
                  ATTR_PROPS,
                  ATTR_BIND_PROPS,
                  ATTR_KEY,
                  ATTR_BIND_EVENTS,
                  ATTR_CURRENT_LIST_VALUE,
                  ATTR_SLOT,
                  ATTR_PARENT_ID,
                  ATTR_CHILD_REPEATID,
                  ATTR_WEAK_BIND_EVENTS,
                  ATTR_REPEATER_PROP_BIND,
                  ATTR_BIND_REFS_ID,
                  ATTR_BIND_REFS_NAME
                ].map(
                  (attribute) => host.getAttribute(attribute) ?? ""
                );
              }
              if (!useQuery) addUserPlaceholder(host);
              return;
            }
          }
          disconnectedCallback() {
            if (!this.shadowRoot) return;
            const host = this.shadowRoot?.host;
            if (!useQuery) {
              removeUserPlaceholder(
                /** @type {import('./type').UserComponent} */
                host
              );
            }
            if (!useRepeatWithoutSyncQuery) {
              cleanInMemorySet(
                /** @type {import('./type').UserComponent} */
                host
              );
            }
            if (!this.active) return;
            _disconnectedCallback?.({
              context: this,
              params: this.#params
            });
            this.resetParams();
          }
          removeCustomComponent() {
            if (!this.shadowRoot || !this.active) return;
            this.parentElement?.removeChild(this);
          }
          adoptedCallback() {
            if (!this.shadowRoot || !this.active) return;
            _adoptedCallback?.({
              context: this,
              params: this.#params
            });
          }
          /**
           * @param {string} name
           * @param {any} oldValue
           * @param {any} newValue
           */
          attributeChangedCallback(name, oldValue, newValue) {
            if (!this.shadowRoot || !this.active) return;
            _attributeChangedCallback?.({
              name,
              oldValue,
              newValue,
              context: this,
              params: this.#params
            });
          }
        }
      );
    });
  };

  // src/js/mob/mob-js/web-component/bind-text.js
  var defineBindTextComponent = () => {
    customElements.define(
      "mobjs-bind-text",
      class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          const { dataset } = this.shadowRoot?.host ?? {};
          if (dataset) {
            const host = this.shadowRoot?.host ?? document.createElement("div");
            const componentId = host?.getAttribute(ATTR_COMPONENT_ID) ?? "";
            const bindTextId = host?.getAttribute(ATTR_BIND_TEXT_ID) ?? "";
            addBindTextPlaceHolderMap({
              host,
              componentId,
              bindTextId
            });
          }
        }
        removeCustomComponent() {
          if (!this.shadowRoot) return;
          this.parentElement?.removeChild(this);
        }
      }
    );
  };

  // src/js/mob/mob-js/web-component/bind-object.js
  var defineBindObjectComponent = () => {
    customElements.define(
      "mobjs-bind-object",
      class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          const { dataset } = this.shadowRoot?.host ?? {};
          if (dataset) {
            const host = this.shadowRoot?.host ?? document.createElement("div");
            const componentId = host?.getAttribute(ATTR_COMPONENT_ID) ?? "";
            const bindObjectId = host?.getAttribute(ATTR_BIND_OBJECT_ID) ?? "";
            addBindObjectPlaceHolderMap({
              host,
              componentId,
              bindObjectId
            });
          }
        }
        removeCustomComponent() {
          if (!this.shadowRoot) return;
          this.parentElement?.removeChild(this);
        }
      }
    );
  };

  // src/js/mob/mob-js/component/component-list.js
  var componentListMap = {};
  var getComponentList = () => {
    return componentListMap;
  };
  var availableComponent = /* @__PURE__ */ new Set();
  var setComponentList = () => {
    componentListMap = [...availableComponent.values()].reduce(
      (previous, current) => ({ ...previous, ...current }),
      {}
    );
    console.log(`component loaded:${Object.keys(componentListMap).length}`);
    defineUserComponent(componentListMap);
    defineSlotComponent();
    defineInvalidateComponent();
    defineRepeatComponent();
    defineBindTextComponent();
    defineBindObjectComponent();
  };
  var useComponent = (components) => {
    if (!components || components?.length === 0) return;
    components.forEach((component) => {
      availableComponent.add(component);
    });
  };

  // src/js/mob/mob-js/component/action/state/check-if-state-is-exportable.js
  var checkIfStateIsExportable = ({ componentName, propName }) => {
    const componentList = getComponentList();
    const exportableState = componentList?.[componentName]?.componentParams?.exportState ?? [];
    return exportableState.includes(propName);
  };

  // src/js/mob/mob-js/component/action/state/set-state-by-id.js
  var setStateById = (id = "", prop = "", value, { emit = true } = {}) => {
    if ((!id || id === "") && (!prop || prop === "") && !value) return;
    const isFreezed2 = getFreezePropStatus({ id, prop });
    if (isFreezed2) {
      return;
    }
    const item = componentMap.get(id);
    const state = item?.state;
    const componentName = item?.componentName ?? "";
    const stateIsExportable = checkIfStateIsExportable({
      componentName,
      propName: prop
    });
    if (!stateIsExportable) {
      console.warn(
        `setStateById failed ${prop} in: ${componentName} is not exportable, maybe a slot bind state that not exist here?`
      );
      return;
    }
    if (!state) {
      console.warn(`setStateById failed no id found on prop: ${prop}`);
      return;
    }
    state.set(prop, value, { emit });
  };

  // src/js/mob/mob-js/component/action/state/set-state-by-name.js
  var setStateByName = (name = "") => {
    const id = getIdByInstanceName(name);
    if (!id) console.warn(`component ${name}, not found`);
    return (prop, value, { emit = true } = {}) => setStateById(
      id,
      /** @type {string} */
      prop,
      value,
      { emit }
    );
  };

  // src/js/mob/mob-js/component/action/state/update-state-by-id.js
  var updateStateById = (id = "", prop = "", value, { emit = true, clone = false } = {}) => {
    if ((!id || id === "") && (!prop || prop === "") && !value) return;
    const isFreezed2 = getFreezePropStatus({ id, prop });
    if (isFreezed2) {
      return;
    }
    const item = componentMap.get(id);
    const state = item?.state;
    const componentName = item?.componentName ?? "";
    const stateIsExportable = checkIfStateIsExportable({
      componentName,
      propName: prop
    });
    if (!stateIsExportable) {
      console.warn(
        `updateStateById failed ${prop} in: ${componentName} is not exportable, maybe a slot bind state that not exist here?`
      );
      return;
    }
    if (!state) {
      console.warn(`updateStateById failed no id found on prop: ${prop}`);
      return;
    }
    state.update(prop, value, { emit, clone });
  };

  // src/js/mob/mob-js/component/action/state/update-state-by-name.js
  var updateStateByName = (name = "") => {
    const id = getIdByInstanceName(name);
    if (!id) console.warn(`component ${name}, not found`);
    return (prop, value, { emit = true, clone = false } = {}) => updateStateById(
      id,
      /** @type {string} */
      prop,
      /** @type {() => any} */
      value,
      {
        emit,
        clone
      }
    );
  };

  // src/js/mob/mob-js/component/create-component/index.js
  var defaultComponent = {
    scoped: false,
    maxParseIteration: 5e3,
    debug: false
  };
  var setDefaultComponent = (obj) => {
    defaultComponent = { ...defaultComponent, ...obj };
  };
  var getDefaultComponent = () => defaultComponent;
  var getDebugMode = () => {
    const { debug } = getDefaultComponent();
    return debug;
  };
  var createComponent = ({
    tag = "",
    component = () => "",
    state = {},
    bindStore,
    exportState = [],
    scoped,
    connectedCallback = () => {
    },
    disconnectedCallback = () => {
    },
    adoptedCallback = () => {
    },
    attributeToObserve = [],
    attributeChangedCallback = () => {
    },
    style = "",
    child = []
  }) => {
    useComponent(child);
    return {
      [tag]: {
        componentFunction: component,
        componentParams: {
          exportState,
          scoped,
          state,
          bindStore,
          connectedCallback,
          disconnectedCallback,
          adoptedCallback,
          attributeToObserve,
          attributeChangedCallback,
          style,
          child
        }
      }
    };
  };

  // src/js/mob/mob-js/route/route-list/index.js
  var routeList = [];
  var indexPage = "";
  var pageNotFound = "";
  var setRouteList = (list) => {
    routeList = [...list];
  };
  var getRouteByName = ({ routeName = "" }) => {
    return routeList.find(({ name }) => routeName === name);
  };
  var setIndex = ({ routeName = "" }) => {
    indexPage = routeName;
  };
  var getIndex = () => indexPage;
  var setPageNotFound = ({ routeName = "" }) => {
    pageNotFound = routeName;
  };
  var getPageNotFound = () => pageNotFound;

  // src/js/mob/mob-js/query/query-component-use-slot.js
  function selectAll2(root2) {
    const result = [];
    for (const node of walkPreOrder(root2)) {
      if (node?.isUserComponent && node?.getSlotPosition?.()) {
        result.push(
          /** @type {UserComponent} */
          node
        );
      }
    }
    return result;
  }
  var queryComponentUseSlot = (node) => {
    let result = [];
    const root2 = node || document.body;
    for (const child of root2.children) {
      result = [...result, ...selectAll2(child)];
    }
    return result;
  };

  // src/js/mob/mob-js/query/query-generic-slot.js
  function selectAll3(root2) {
    const result = [];
    for (const node of walkPreOrder(root2)) {
      if (node?.isSlot && node?.getSlotName?.()) {
        result.push(
          /** @type {SlotComponent} */
          node
        );
      }
    }
    return result;
  }
  var queryGenericSlot = (node) => {
    let result = [];
    const root2 = node || document.body;
    for (const child of root2.children) {
      result = [...result, ...selectAll3(child)];
    }
    return result;
  };

  // src/js/mob/mob-js/query/query-specific-slot.js
  function selectAll4(root2, slotName) {
    for (const node of walkPreOrder(root2)) {
      if (node?.isSlot && node?.getSlotName?.() === slotName) {
        return (
          /** @type {SlotComponent} */
          node
        );
      }
    }
    return null;
  }
  var querySecificSlot = (node, slotName) => {
    const root2 = node || document.body;
    for (const child of root2.children) {
      const result = selectAll4(child, slotName);
      if (result) return result;
    }
    return null;
  };

  // src/js/mob/mob-js/query/query-unnamed-slot.js
  function selectAll5(root2) {
    for (const node of walkPreOrder(root2)) {
      if (node?.isSlot && !node?.getSlotName?.()) {
        return (
          /** @type {SlotComponent} */
          node
        );
      }
    }
    return null;
  }
  var queryUnNamedSlot = (node) => {
    const root2 = node || document.body;
    for (const child of root2.children) {
      const result = selectAll5(child);
      if (result) return result;
    }
    return null;
  };

  // src/js/mob/mob-js/modules/repeater/repeater-value/index.js
  var currentRepeaterValueMap = /* @__PURE__ */ new Map();
  var setComponentRepeaterState = (current) => {
    const id = modules_exports.getUnivoqueId();
    currentRepeaterValueMap.set(id, current);
    return id;
  };
  var getComponentRepeaterState = (id = "") => {
    if (!id) return DEFAULT_CURRENT_REPEATER_STATE;
    const value = currentRepeaterValueMap.get(id);
    currentRepeaterValueMap.delete(id);
    return value ?? DEFAULT_CURRENT_REPEATER_STATE;
  };

  // src/js/mob/mob-js/parse/steps/constant.js
  var ELEMENT_TYPE_NODE = "node";
  var ELEMENT_TYPE_TEXT = "text";
  var ELEMENT_TYPE_MIX_NODE_TEXT = "mix";
  var ELEMENT_TYPE_NOT_VALID = "not-valid";

  // src/js/mob/mob-js/parse/steps/utils.js
  var renderHtml = String.raw;
  var getElementOrTextFromNode = (node) => {
    const childNodes = node.childNodes;
    if (childNodes.length === 0) {
      return {
        item: void 0,
        type: ELEMENT_TYPE_NOT_VALID
      };
    }
    const children = node.children;
    if (children.length === 1 && childNodes.length === 1) {
      return {
        item: node.children?.[0],
        type: ELEMENT_TYPE_NODE
      };
    }
    if (childNodes.length > 1)
      return {
        item: node.innerHTML,
        type: ELEMENT_TYPE_MIX_NODE_TEXT
      };
    const textContent = node.textContent;
    if (textContent && textContent.length > 0)
      return {
        item: textContent,
        type: ELEMENT_TYPE_TEXT
      };
    return {
      item: void 0,
      type: ELEMENT_TYPE_NOT_VALID
    };
  };
  var insertElementOrText = ({
    parent,
    itemObject,
    position: position2 = "afterend"
  }) => {
    const { item, type } = itemObject;
    if (type === ELEMENT_TYPE_NOT_VALID) return;
    if (type === ELEMENT_TYPE_MIX_NODE_TEXT) {
      parent.insertAdjacentHTML(
        position2,
        /** @type {string} */
        item
      );
      return;
    }
    if (type === ELEMENT_TYPE_NODE) {
      parent.insertAdjacentElement(
        position2,
        /** @type {Element} */
        item
      );
      return;
    }
    if (type === ELEMENT_TYPE_TEXT) {
      parent.insertAdjacentText(
        position2,
        /** @type {string} */
        item
      );
      return;
    }
    return;
  };
  var setRepeatAttribute = ({
    components,
    current,
    index,
    observe,
    repeatId,
    key
  }) => {
    components.forEach((component) => {
      if (!component.deref()?.hasAttribute(ATTR_CURRENT_LIST_VALUE)) {
        component.deref()?.setAttribute(
          ATTR_CURRENT_LIST_VALUE,
          setComponentRepeaterState({
            current,
            index
          })
        );
      }
      if (!component.deref()?.hasAttribute(ATTR_KEY)) {
        component.deref()?.setAttribute(ATTR_KEY, `${key}`);
      }
      if (!component.deref()?.hasAttribute(ATTR_REPEATER_PROP_BIND)) {
        component.deref()?.setAttribute(ATTR_REPEATER_PROP_BIND, `${observe}`);
      }
      if (!component.deref()?.hasAttribute(ATTR_CHILD_REPEATID)) {
        component.deref()?.setAttribute(ATTR_CHILD_REPEATID, `${repeatId}`);
      }
    });
  };
  var setRepeatAttributeFromInMemory = ({
    components,
    current,
    index,
    observe,
    repeatId,
    key
  }) => {
    components.forEach((component) => {
      if (component.hasAttribute(ATTR_CHILD_REPEATID)) {
        cleanInMemorySet(component);
        return;
      }
      component.setAttribute(
        ATTR_CURRENT_LIST_VALUE,
        setComponentRepeaterState({
          current,
          index
        })
      );
      component.setAttribute(ATTR_KEY, `${key}`);
      component.setAttribute(ATTR_REPEATER_PROP_BIND, `${observe}`);
      component.setAttribute(ATTR_CHILD_REPEATID, `${repeatId}`);
    });
  };

  // src/js/mob/mob-js/parse/steps/convert-to-real-element.js
  var getNewElement = ({ element, content }) => {
    const { debug } = getDefaultComponent();
    if (element.parentNode) {
      const template = document.createElement("template");
      template.innerHTML = content;
      const node = template.content.firstElementChild;
      node?.disablePlaceHolderState?.();
      if (node) element.after(node);
      if (debug)
        element.insertAdjacentHTML(
          "afterend",
          `<!--  ${element.tagName.toLowerCase()} --> `
        );
      return (
        /** @type {HTMLElement} */
        node
      );
    }
    return;
  };
  var removeOrphanSlot = ({ element }) => {
    const slots = useSlotQuery ? queryGenericSlot(element) : getAllSlot();
    slots.forEach((slot) => {
      slot?.removeCustomComponent();
      slot?.remove();
    });
  };
  var addToNamedSlot = ({ element }) => {
    const componentWithSlot = useComponentHasNamedSlotQuery ? queryComponentUseSlot(element) : getAllUserComponentUseNamedSlot({ element });
    if (componentWithSlot.length === 0) return;
    [...componentWithSlot].forEach((component) => {
      const slotName = component?.getSlotPosition();
      const slot = useSlotQuery ? querySecificSlot(element, slotName) : getSlotByName({ name: slotName, element });
      if (!slot) return { slot: null, elementMoved: null };
      slot.parentNode?.insertBefore(component, slot);
      slot?.removeCustomComponent();
      slot?.remove();
    });
  };
  var executeConversion = ({ element, content }) => {
    const prevContent = getElementOrTextFromNode(element);
    const newElement = getNewElement({ element, content });
    if (newElement) {
      const id = element.getId();
      const delegateEventId = element?.getDelegateEventId();
      const bindRefId = element?.getBindRefId();
      const bindRefName = element?.getBindRefName();
      const unNamedSlot = useSlotQuery ? queryUnNamedSlot(newElement) : getUnamedPlaceholderSlot({ element: newElement });
      if (unNamedSlot) {
        insertElementOrText({
          parent: unNamedSlot,
          itemObject: prevContent,
          position: "afterend"
        });
        unNamedSlot.remove();
      }
      if (!unNamedSlot) {
        insertElementOrText({
          parent: newElement,
          itemObject: prevContent,
          position: "afterbegin"
        });
      }
      addToNamedSlot({ element: newElement });
      removeOrphanSlot({ element: newElement });
      if (delegateEventId && delegateEventId.length > 0)
        newElement.setAttribute(ATTR_WEAK_BIND_EVENTS, delegateEventId);
      if (bindRefId && bindRefId.length > 0)
        newElement.setAttribute(ATTR_BIND_REFS_ID, bindRefId);
      if (bindRefName && bindRefName.length > 0)
        newElement.setAttribute(ATTR_BIND_REFS_NAME, bindRefName);
      const { debug } = getDefaultComponent();
      if (debug) newElement.setAttribute(ATTR_IS_COMPONENT, id ?? "");
    }
    element.remove();
    return newElement;
  };
  var convertToRealElement = ({ element, content }) => {
    return {
      newElement: executeConversion({
        element,
        content
      })
    };
  };

  // src/js/mob/mob-js/parse/utils.js
  var currentIterationCounter = 0;
  var incrementCurrentIterationCounter = () => {
    currentIterationCounter += 1;
  };
  var getCurrentIterationCounter = () => currentIterationCounter;
  var resetCurrentIterationCounter = () => {
    currentIterationCounter = 0;
  };
  var getParseSourceArray = ({ element, currentSelectors }) => {
    if (currentSelectors.length > 0) {
      const componentToParse = currentSelectors[0];
      const parseSourceArray = currentSelectors.slice(1);
      return { componentToParse, parseSourceArray };
    } else {
      const query = useQuery ? [...queryAllFutureComponent(element)] : getFirstUserChildPlaceHolder(element);
      const componentToParse = query?.[0];
      const parseSourceArray = query.slice(1);
      return { componentToParse, parseSourceArray };
    }
  };

  // src/js/mob/mob-js/component/action/remove-and-destroy/set-destroy-callback.js
  var setDestroyCallback = ({ cb = () => {
  }, id }) => {
    if (!id) return;
    const item = componentMap.get(id);
    if (!item) return;
    componentMap.set(id, { ...item, destroy: cb });
  };

  // src/js/mob/mob-js/modules/on-mount/index.js
  var onMountCallbackMap = /* @__PURE__ */ new Map();
  var addOnMoutCallback = ({ id, cb = () => {
  } }) => {
    onMountCallbackMap.set(id, cb);
  };
  var fireOnMountCallBack = async ({ id, element }) => {
    const callback2 = onMountCallbackMap.get(id);
    const destroyCallback = await callback2?.({
      element
    });
    setDestroyCallback({ cb: destroyCallback, id });
    onMountCallbackMap.delete(id);
  };

  // src/js/mob/mob-js/queque/utils.js
  function awaitNextLoop() {
    return new Promise((resolve) => modules_exports.useNextLoop(() => resolve()));
  }

  // src/js/mob/mob-js/queque/tick.js
  var queque = /* @__PURE__ */ new Map();
  var maxQueuqueSize = 1e5;
  var incrementTickQueuque = (props) => {
    if (queque.size >= maxQueuqueSize) {
      console.warn(`maximum loop event reached: (${maxQueuqueSize})`);
      return () => {
      };
    }
    const id = modules_exports.getUnivoqueId();
    queque.set(id, props);
    return () => queque.delete(id);
  };
  var queueIsResolved = () => {
    return queque.size === 0 || queque.size >= maxQueuqueSize;
  };
  var tick = async ({ debug = false, previousResolve } = {}) => {
    await awaitNextLoop();
    if (debug) {
      queque.forEach((value) => {
        console.log(value);
      });
    }
    if (queueIsResolved() && previousResolve) {
      previousResolve();
      return;
    }
    return new Promise((resolve) => {
      if (queueIsResolved()) {
        resolve();
        return;
      }
      tick({ debug, previousResolve: previousResolve ?? resolve });
    });
  };

  // src/js/mob/mob-js/modules/common-event.js
  var shouldFireEvent = true;
  var allowFireEvent = () => {
    shouldFireEvent = true;
  };
  var preventFireEvent = () => {
    shouldFireEvent = false;
  };
  var getFireEvent = () => shouldFireEvent;

  // src/js/mob/mob-js/modules/bind-events/index.js
  var bindEventMap = /* @__PURE__ */ new Map();
  var setBindEvents = (eventsData = []) => {
    const eventsDataParsed = checkType(Object, eventsData) ? [eventsData] : eventsData;
    const id = modules_exports.getUnivoqueId();
    bindEventMap.set(id, eventsDataParsed);
    return id;
  };
  var applyBindEvents = ({ element, componentId, bindEventsId }) => {
    const eventArray = bindEventMap.get(bindEventsId);
    if (!eventArray) return;
    eventArray.forEach((event) => {
      const [eventName] = Object.keys(event);
      const [callback2] = Object.values(event);
      if (!eventName || !callback2) return;
      element.addEventListener(eventName, async (e) => {
        if (!getFireEvent()) return;
        preventFireEvent();
        await tick();
        allowFireEvent();
        const currentRepeaterState = getRepeaterStateById({
          id: componentId
        });
        callback2(
          e,
          currentRepeaterState?.current,
          currentRepeaterState?.index
        );
      });
    });
    bindEventMap.delete(bindEventsId);
  };
  var removeOrphansBindEvent = () => {
    bindEventMap.clear();
  };

  // src/js/mob/mob-js/component/action/props.js
  var setDynamicPropsWatch = ({ id = "", unWatchArray = [] }) => {
    const item = componentMap.get(id);
    if (!item) return;
    const { parentPropsWatcher } = item;
    if (!parentPropsWatcher) return;
    componentMap.set(id, {
      ...item,
      parentPropsWatcher: [...parentPropsWatcher, ...unWatchArray]
    });
  };
  var unBind = ({ id = "" }) => {
    if (!id || id === "") return;
    const item = componentMap.get(id);
    const parentPropsWatcher = item?.parentPropsWatcher ?? [];
    parentPropsWatcher.forEach((unwatch) => {
      unwatch();
    });
  };

  // src/js/mob/mob-js/queque/tick-repeater.js
  var repeaterQueque = /* @__PURE__ */ new Map();
  var repeaterQuequeIsEmpty = () => repeaterQueque.size === 0;
  var maxQueuqueSize2 = 1e3;
  var incrementRepeaterTickQueuque = (props) => {
    if (repeaterQueque.size >= maxQueuqueSize2) {
      console.warn(`maximum loop event reached: (${maxQueuqueSize2})`);
      return () => {
      };
    }
    const id = modules_exports.getUnivoqueId();
    repeaterQueque.set(id, props);
    return () => repeaterQueque.delete(id);
  };
  var queueIsResolved2 = () => {
    return repeaterQueque.size === 0 || repeaterQueque.size >= maxQueuqueSize2;
  };
  var repeaterTick = async ({ debug = false, previousResolve } = {}) => {
    await awaitNextLoop();
    if (debug) {
      repeaterQueque.forEach((value) => {
        console.log(value);
      });
    }
    if (queueIsResolved2() && previousResolve) {
      previousResolve();
      return;
    }
    return new Promise((resolve) => {
      if (queueIsResolved2()) {
        resolve();
        return;
      }
      repeaterTick({ debug, previousResolve: previousResolve ?? resolve });
    });
  };

  // src/js/mob/mob-js/queque/tick-invalidate.js
  var invalidateQueque = /* @__PURE__ */ new Map();
  var invalidateQuequeIsEmpty = () => invalidateQueque.size === 0;
  var maxQueuqueSize3 = 1e3;
  var incrementInvalidateTickQueuque = (props) => {
    if (invalidateQueque.size >= maxQueuqueSize3) {
      console.warn(`maximum loop event reached: (${maxQueuqueSize3})`);
      return () => {
      };
    }
    const id = modules_exports.getUnivoqueId();
    invalidateQueque.set(id, props);
    return () => invalidateQueque.delete(id);
  };
  var queueIsResolved3 = () => {
    return invalidateQueque.size === 0 || invalidateQueque.size >= maxQueuqueSize3;
  };
  var invalidateTick = async ({
    debug = false,
    previousResolve
  } = {}) => {
    await awaitNextLoop();
    if (debug) {
      invalidateQueque.forEach((value) => {
        console.log(value);
      });
    }
    if (queueIsResolved3() && previousResolve) {
      previousResolve();
      return;
    }
    return new Promise((resolve) => {
      if (queueIsResolved3()) {
        resolve();
        return;
      }
      invalidateTick({
        debug,
        previousResolve: previousResolve ?? resolve
      });
    });
  };

  // src/js/mob/mob-js/modules/bind-props/index.js
  var setBindProps = (data) => {
    const hasProps = "props" in data;
    if (!hasProps) {
      console.warn(`bindProps not valid`);
      return;
    }
    const stateToWatch = (
      /** @type {string[] | undefined} */
      data?.observe ? (() => {
        return (
          /** @type{( string|( () => void ) )[]} */
          data.observe.map((item) => {
            return detectProp(item);
          })
        );
      })() : (() => {
        current_key_exports.initializeCurrentDependencies();
        if (modules_exports.checkType(Function, data.props)) {
          data.props({}, {}, 0);
        }
        return current_key_exports.getCurrentDependencies();
      })()
    );
    if (stateToWatch.length === 0) {
      console.warn(`bindProps not valid, no dependencies found`);
      return;
    }
    const dataUpdated = { ...data, observe: stateToWatch };
    const id = modules_exports.getUnivoqueId();
    bindPropsMap.set(id, {
      ...dataUpdated,
      componentId: "",
      propsId: id
    });
    return id;
  };
  var updateBindProp = ({
    componentId,
    observe,
    props,
    currentParentId,
    fireCallback
  }) => {
    if (!currentParentId) return;
    const parentState = getStateById(currentParentId);
    if (!parentState) return;
    const parentStateKeys = Object.keys(parentState);
    const bindArrayIsValid = observe.every(
      (state) => parentStateKeys.includes(state)
    );
    if (!bindArrayIsValid) {
      console.warn(
        `bind props error: Some prop ${JSON.stringify(observe)} doesn't exist`
      );
    }
    const componentExist = componentMap.has(componentId);
    if (!componentExist) return;
    const currentRepeaterState = getRepeaterStateById({
      id: componentId
    });
    const newProps = props?.(
      parentState,
      currentRepeaterState.current,
      currentRepeaterState?.index
    );
    if (!newProps) return;
    Object.entries(newProps).forEach(([key, value]) => {
      setStateById(componentId, key, value, { emit: fireCallback });
    });
  };
  var addCurrentIdToBindProps = ({
    propsId,
    repeatPropBind,
    componentId
  }) => {
    if (!propsId) return;
    const value = bindPropsMap.get(propsId);
    if (!value) return;
    bindPropsMap.set(propsId, { ...value, componentId });
    bindComponentTobindId.set(componentId, propsId);
    applyBindProps({
      componentId,
      repeatPropBind,
      inizilizeWatcher: false
    });
  };
  var applyBindProps = async ({
    componentId,
    repeatPropBind,
    inizilizeWatcher
  }) => {
    const moduleId = bindComponentTobindId.get(componentId);
    if (!moduleId) return;
    if (inizilizeWatcher) bindComponentTobindId.delete(componentId);
    const dynamicProps = bindPropsMap.get(moduleId);
    if (!dynamicProps) return;
    const { observe, props, parentId } = dynamicProps;
    const observeParsed = repeatPropBind && repeatPropBind?.length > 0 && !observe.includes(repeatPropBind) ? [...observe, repeatPropBind] : [...observe];
    if (!inizilizeWatcher) {
      updateBindProp({
        componentId,
        observe: observeParsed,
        props,
        currentParentId: parentId ?? "",
        fireCallback: false
      });
    }
    if (!inizilizeWatcher && !repeaterQuequeIsEmpty()) {
      await repeaterTick();
      updateBindProp({
        componentId,
        observe: observeParsed,
        props,
        currentParentId: parentId ?? "",
        fireCallback: true
      });
    }
    if (!inizilizeWatcher && !invalidateQuequeIsEmpty()) {
      await invalidateTick();
      updateBindProp({
        componentId,
        observe: observeParsed,
        props,
        currentParentId: parentId ?? "",
        fireCallback: true
      });
    }
    if (!inizilizeWatcher) return;
    let watchIsRunning = false;
    const unWatchArray = observeParsed.map((state) => {
      return watchById(parentId, state, async () => {
        await repeaterTick();
        await invalidateTick();
        if (watchIsRunning) return;
        const decrementQueue = incrementTickQueuque({
          state,
          id: componentId,
          type: QUEQUE_TYPE_BINDPROPS
        });
        watchIsRunning = true;
        modules_exports.useNextLoop(() => {
          updateBindProp({
            componentId,
            observe: observeParsed,
            props,
            currentParentId: parentId ?? "",
            fireCallback: true
          });
          watchIsRunning = false;
          decrementQueue();
        });
      });
    });
    setDynamicPropsWatch({
      id: componentId,
      unWatchArray: unWatchArray.filter((item) => item !== void 0)
    });
    if (!inizilizeWatcher) return;
    for (const [key, value] of bindPropsMap) {
      const { componentId: currentComponentId } = value;
      if (currentComponentId === componentId) {
        bindPropsMap.delete(key);
      }
    }
  };
  var removeOrphansBindProps = () => {
    bindPropsMap.clear();
    bindComponentTobindId.clear();
  };

  // src/js/mob/mob-js/component/action/remove-and-destroy/destroy-component-inside-node-by-id.js
  var destroyComponentInsideNodeById = ({ id, container }) => {
    const instanceValue = componentMap.get(id);
    const child = instanceValue?.child;
    if (!child) return;
    const allChild = Object.values(child ?? {}).flat();
    allChild.forEach((id2) => {
      const state = componentMap.get(id2);
      const element = state?.element;
      const currentId = state?.id ?? "";
      if (element && container?.contains(element) && element !== container) {
        removeAndDestroyById({ id: id2 });
        return;
      } else {
        destroyComponentInsideNodeById({ id: currentId, container });
      }
    });
  };

  // src/js/mob/mob-js/modules/bind-effetc/index.js
  var bindEffectMap = /* @__PURE__ */ new Map();
  var getExplicitBind = (observe) => {
    const observeArray = modules_exports.checkType(Array, observe) ? observe : [observe];
    return observeArray.map((item) => {
      return detectProp(item);
    });
  };
  var getAutoBind = ({ toggleClass, toggleStyle, toggleAttribute }) => {
    current_key_exports.initializeCurrentDependencies();
    Object.values(toggleStyle).forEach((fn) => fn());
    Object.values(toggleClass).forEach((fn) => fn());
    Object.values(toggleAttribute).forEach((fn) => fn());
    return current_key_exports.getCurrentDependencies();
  };
  var setBindEffect = ({ data, id }) => {
    const dataToArray = modules_exports.checkType(Array, data) ? data : [data];
    const dataBindToArray = dataToArray.map(
      ({ observe, toggleClass, toggleStyle, toggleAttribute }) => {
        const observeParsed = observe ? getExplicitBind(observe) : getAutoBind({
          toggleStyle: toggleStyle ?? { fake: () => "" },
          toggleClass: toggleClass ?? { fake: () => {
          } },
          toggleAttribute: toggleAttribute ?? { fake: () => {
          } }
        });
        return {
          observe: observeParsed,
          toggleClass: toggleClass ?? {},
          toggleStyle: toggleStyle ?? {},
          toggleAttribute: toggleAttribute ?? {}
        };
      }
    );
    const item = {
      parentId: id,
      items: dataBindToArray
    };
    const univoqueId = modules_exports.getUnivoqueId();
    bindEffectMap.set(univoqueId, item);
    return univoqueId;
  };
  var applyBindEffect = (element) => {
    const occurrences = (
      /** @type {HTMLElement[]} */
      [
        ...element.querySelectorAll(`[${ATTR_BIND_EFFECT}]`)
      ]
    );
    occurrences.forEach((target) => {
      const id = target.getAttribute(ATTR_BIND_EFFECT);
      if (!id) return;
      const data = bindEffectMap.get(id);
      if (!data) return;
      target.removeAttribute(ATTR_BIND_EFFECT);
      watchBindEffect({ data, element: target });
      bindEffectMap.delete(id);
    });
  };
  var applyClass = ({ ref, data }) => {
    if (!data) return;
    Object.entries(data).forEach(([className, fn]) => {
      if (!ref.deref()) return;
      ref.deref().classList.toggle(className, fn?.());
    });
  };
  var applyStyle = ({ ref, data }) => {
    Object.entries(data).forEach(([styleName, fn]) => {
      if (!ref.deref()) return;
      ref.deref().style[styleName] = fn?.() ?? "";
    });
  };
  var applyAttribute = ({ ref, data }) => {
    Object.entries(data).forEach(([attributeName, fn]) => {
      if (!ref.deref()) return;
      const value = fn?.();
      if (!value) {
        ref.deref().removeAttribute(attributeName);
        return;
      }
      ref.deref()?.setAttribute(attributeName, value);
    });
  };
  var watchBindEffect = ({ data, element }) => {
    const ref = new WeakRef(element);
    const { parentId: id } = data;
    const { items } = data;
    const unsubScribeFunction = items.flatMap(
      ({ observe, toggleClass, toggleStyle, toggleAttribute }) => {
        let watchIsRunning = false;
        return observe.map((state) => {
          if (toggleClass) {
            modules_exports.useFrame(() => {
              applyClass({ ref, data: toggleClass });
            });
          }
          if (toggleStyle) {
            modules_exports.useFrame(() => {
              applyStyle({ ref, data: toggleStyle });
            });
          }
          if (toggleAttribute) {
            modules_exports.useFrame(() => {
              applyAttribute({ ref, data: toggleAttribute });
            });
          }
          return watchById(id, state, () => {
            if (!ref || !ref?.deref()) {
              unsubScribeFunction.forEach((fn) => {
                if (fn) fn();
              });
              unsubScribeFunction.length = 0;
              return;
            }
            if (watchIsRunning) return;
            watchIsRunning = true;
            modules_exports.useNextLoop(() => {
              modules_exports.useFrame(() => {
                if (toggleClass && ref.deref()) {
                  applyClass({ ref, data: toggleClass });
                }
                if (toggleStyle && ref.deref()) {
                  applyStyle({ ref, data: toggleStyle });
                }
                if (toggleAttribute && ref.deref()) {
                  applyAttribute({ ref, data: toggleAttribute });
                }
                watchIsRunning = false;
              });
            });
          });
        });
      }
    );
  };

  // src/js/mob/mob-js/modules/bind-refs/index.js
  var getBindRefs = ({ element }) => {
    const refs = element.querySelectorAll(`[${ATTR_BIND_REFS_ID}]`);
    const initialValue = {};
    return [...refs].reduce((previous, current) => {
      const refId = current.getAttribute(ATTR_BIND_REFS_ID);
      const refName = current.getAttribute(ATTR_BIND_REFS_NAME);
      current.removeAttribute(ATTR_BIND_REFS_ID);
      current.removeAttribute(ATTR_BIND_REFS_NAME);
      if (!refName) return previous;
      const newRefsByName = refName in previous ? [...previous[refName], { element: current, scopeId: refId }] : [{ element: current, scopeId: refId }];
      return { ...previous, [refName]: newRefsByName };
    }, initialValue);
  };
  var getRefsSorter = (refs) => {
    return [
      ...new Set(
        refs.sort((a, b) => {
          if (a === b || !a || !b) return 0;
          if (a.compareDocumentPosition(b) & 2) {
            return 1;
          }
          return -1;
        })
      )
    ];
  };
  var mergeRefsAndOrder = ({ refs, refName, element }) => {
    return {
      ...refs,
      [refName]: getRefsSorter([...refs[refName], element])
    };
  };
  var addBindRefsToComponent = (refs) => {
    Object.entries(refs).forEach(([refName, entries]) => {
      entries.forEach(({ element, scopeId }) => {
        const item = componentMap.get(scopeId);
        if (!item) return;
        const { refs: previousRef } = item;
        if (!previousRef) return;
        const newRefs = refName in previousRef ? mergeRefsAndOrder({ refs: previousRef, refName, element }) : { ...previousRef, [refName]: [element] };
        componentMap.set(scopeId, {
          ...item,
          refs: newRefs
        });
      });
    });
  };
  var getBindRefsById = ({ id }) => {
    const item = componentMap.get(id);
    if (!item) return {};
    const { refs, element } = item;
    if (!refs) return {};
    const refsUpdated = Object.entries(refs).map(([name, collection]) => {
      return {
        name,
        collection: collection.filter((ref) => element.contains(ref))
      };
    }).reduce((previous, current) => {
      return { ...previous, [current.name]: current.collection };
    }, {});
    componentMap.set(id, {
      ...item,
      refs: refsUpdated
    });
    return refsUpdated;
  };
  var getBindRefById = ({ id }) => {
    const refs = getBindRefsById({ id });
    return Object.entries(refs).reduce((previous, [name, collection]) => {
      return { ...previous, [name]: collection?.[0] };
    }, {});
  };

  // src/js/mob/mob-js/route/dom-ref/root.js
  var root = document.createElement("div");
  var setRoot = ({ element }) => {
    root = element;
  };
  var getRoot = () => root;

  // src/js/mob/mob-js/modules/delegate-events/index.js
  var tempDelegateEventMap = /* @__PURE__ */ new Map();
  var eventDelegationMap = /* @__PURE__ */ new WeakMap();
  var eventToAdd = [];
  var eventRegistered = [];
  var setDelegateBindEvent = (eventsData = []) => {
    const eventsDataParsed = checkType(Object, eventsData) ? [eventsData] : eventsData;
    const id = modules_exports.getUnivoqueId();
    tempDelegateEventMap.set(id, eventsDataParsed);
    return id;
  };
  var findParentElementInMap = (target) => {
    let parent = target?.parentNode;
    while (parent) {
      if (eventDelegationMap.has(parent))
        return { target: parent, data: eventDelegationMap.get(parent) };
      parent = parent?.parentNode;
    }
    return { target: void 0, data: void 0 };
  };
  var getItemFromTarget = (target) => {
    const data = eventDelegationMap.get(target);
    if (data) return { target, data: eventDelegationMap.get(target) };
    return findParentElementInMap(target);
  };
  async function handleAction(eventKey, event) {
    const target = event?.target;
    if (!target) return;
    if (!getFireEvent()) return;
    preventFireEvent();
    await tick();
    allowFireEvent();
    const { target: targetParsed, data } = getItemFromTarget(target);
    if (!data || !document.contains(targetParsed)) return;
    const currentEvent = data.find(({ event: event2 }) => event2 === eventKey);
    if (!currentEvent) return;
    const { callback: callback2 } = currentEvent;
    const componentId = getIdByElement({ element: targetParsed });
    const currentRepeaterState = componentId ? getRepeaterStateById({
      id: componentId
    }) : DEFAULT_CURRENT_REPEATER_STATE;
    Object.defineProperty(event, "target", { value: targetParsed });
    Object.defineProperty(event, "currentTarget", { value: target });
    callback2(event, currentRepeaterState?.current, currentRepeaterState?.index);
  }
  var applyDelegationBindEvent = async (root2) => {
    await repeaterTick();
    await invalidateTick();
    const parent = root2.parentNode;
    const elements = parent?.querySelectorAll(`[${ATTR_WEAK_BIND_EVENTS}]`) ?? [];
    [...elements].forEach((element) => {
      const id = element.getAttribute(ATTR_WEAK_BIND_EVENTS) ?? "";
      element.removeAttribute(ATTR_WEAK_BIND_EVENTS);
      const data = tempDelegateEventMap.get(id);
      tempDelegateEventMap.delete(id);
      const dataParsed = data?.flatMap((item) => {
        return Object.entries(item).map((current) => {
          const [event, callback2] = current;
          if (!eventToAdd.includes(event)) eventToAdd.push(event);
          return { event, callback: callback2 };
        });
      });
      eventDelegationMap.set(element, dataParsed);
    });
    const rootElement = getRoot();
    eventToAdd.forEach((eventKey) => {
      if (eventRegistered.includes(eventKey)) return;
      eventRegistered.push(eventKey);
      rootElement.addEventListener(
        eventKey,
        handleAction.bind(null, eventKey)
      );
    });
  };

  // src/js/mob/mob-js/modules/common-repeat-invalidate.js
  var MODULE_REPEATER = "repeater";
  var MODULE_INVALIDATE = "invalidate";
  var getRepeatOrInvalidateInsideElement = ({
    element,
    skipInitialized = false,
    onlyInitialized = false,
    componentId,
    module
  }) => {
    const entries = module === MODULE_REPEATER ? repeatIdPlaceHolderMap.entries() : invalidateIdPlaceHolderMap.entries();
    const result = [];
    for (const item of entries) {
      const [_id, { element: currentElement, initialized: initialized7, scopeId }] = item;
      if (componentId && !compareIdOrParentIdRecursive({
        id: scopeId ?? "",
        compareValue: componentId
      }))
        continue;
      if (skipInitialized && initialized7) continue;
      if (onlyInitialized && !initialized7) continue;
      const condition = currentElement && element?.contains(currentElement) && element !== currentElement;
      if (condition) result.push(item);
    }
    return result.map(([id, parent]) => ({
      id,
      parent: parent?.element
    }));
  };

  // src/js/mob/mob-js/modules/repeater/action/remove-repeat-by-repeat-id.js
  var removeRepeatByRepeatId = ({ id, repeatId }) => {
    if (!repeatFunctionMap.has(id)) return;
    const value = repeatFunctionMap.get(id);
    if (!value) return;
    const valueParsed = value.filter((item) => item.repeatId !== repeatId);
    if (repeatIdPlaceHolderMap.has(repeatId)) {
      repeatIdPlaceHolderMap.delete(repeatId);
    }
    repeatFunctionMap.set(id, valueParsed);
  };

  // src/js/mob/mob-js/modules/repeater/action/destroy-nested-repeat.js
  var destroyNestedRepeat = ({ id, repeatParent }) => {
    const repeatChildToDelete = getRepeatOrInvalidateInsideElement({
      element: repeatParent,
      skipInitialized: false,
      onlyInitialized: true,
      componentId: id,
      module: MODULE_REPEATER
    });
    for (const value of repeatFunctionMap.values()) {
      value.forEach(({ repeatId, unsubscribe: unsubscribe3 }) => {
        const condition = repeatChildToDelete.some((current) => {
          return current.id === repeatId;
        });
        if (condition) {
          unsubscribe3();
          removeRepeatByRepeatId({ id, repeatId });
        }
      });
    }
  };

  // src/js/mob/mob-js/modules/repeater/action/inizialize-nested-repeat.js
  var inizializeNestedRepeat = ({ repeatParent, id }) => {
    if (!repeatParent) return;
    const newRepeatChild = getRepeatOrInvalidateInsideElement({
      element: repeatParent,
      skipInitialized: true,
      onlyInitialized: false,
      componentId: id,
      module: MODULE_REPEATER
    });
    for (const value of repeatFunctionMap.values()) {
      value.forEach(({ repeatId, fn }) => {
        const condition = newRepeatChild.some((current) => {
          return current.id === repeatId;
        });
        if (condition) fn();
      });
    }
  };

  // src/js/mob/mob-js/modules/invalidate/action/add-invalidate-unsubcribe.js
  var addInvalidateUnsubcribe = ({ id, invalidateId, unsubscribe: unsubscribe3 }) => {
    const currentFunctions = invalidateFunctionMap.get(id) ?? [];
    const item = currentFunctions.map((item2) => {
      if (item2.invalidateId === invalidateId) {
        return { ...item2, unsubscribe: unsubscribe3 };
      }
      return item2;
    });
    invalidateFunctionMap.set(id, item);
  };

  // src/js/mob/mob-js/modules/invalidate/action/remove-invalidate-by-invalidate-id.js
  var removeInvalidateByInvalidateId = ({ id, invalidateId }) => {
    if (!invalidateFunctionMap.has(id)) return;
    const value = invalidateFunctionMap.get(id);
    if (!value) return;
    const valueParsed = value.filter(
      (item) => item.invalidateId !== invalidateId
    );
    if (invalidateIdPlaceHolderMap.has(invalidateId)) {
      invalidateIdPlaceHolderMap.delete(invalidateId);
    }
    invalidateFunctionMap.set(id, valueParsed);
  };

  // src/js/mob/mob-js/modules/invalidate/action/destroy-nested-invalidate.js
  var destroyNestedInvalidate = ({ id, invalidateParent }) => {
    const invalidatechildToDelete = getRepeatOrInvalidateInsideElement({
      element: invalidateParent,
      skipInitialized: false,
      onlyInitialized: true,
      componentId: id,
      module: MODULE_INVALIDATE
    });
    for (const value of invalidateFunctionMap.values()) {
      value.forEach(({ invalidateId, unsubscribe: unsubscribe3 }) => {
        const condition = invalidatechildToDelete.some((current) => {
          return current.id === invalidateId;
        });
        if (condition) {
          unsubscribe3.forEach((fn) => {
            fn();
          });
          removeInvalidateByInvalidateId({ id, invalidateId });
        }
      });
    }
  };

  // src/js/mob/mob-js/modules/invalidate/action/get-invalidate-parent.js
  var getInvalidateParent = ({ id }) => {
    if (!invalidateIdPlaceHolderMap.has(id)) {
      return;
    }
    if (invalidateIdHostMap.has(id)) {
      const host = invalidateIdHostMap.get(id);
      host?.removeCustomComponent();
      host?.remove();
      invalidateIdHostMap.delete(id);
    }
    const parent = invalidateIdPlaceHolderMap.get(id);
    return parent?.element;
  };

  // src/js/mob/mob-js/modules/invalidate/action/inizialize-nested-invalidate.js
  var inizializeNestedInvalidate = ({ invalidateParent, id }) => {
    if (!invalidateParent) return;
    const newInvalidateChild = getRepeatOrInvalidateInsideElement({
      element: invalidateParent,
      skipInitialized: true,
      onlyInitialized: false,
      componentId: id,
      module: MODULE_INVALIDATE
    });
    for (const value of invalidateFunctionMap.values()) {
      value.forEach(({ invalidateId, fn }) => {
        const condition = newInvalidateChild.some((current) => {
          return current.id === invalidateId;
        });
        if (condition) fn();
      });
    }
  };

  // src/js/mob/mob-js/modules/invalidate/action/inizialize-invalidate-watch.js
  var inizializeInvalidateWatch = async ({
    observe = [],
    beforeUpdate = () => Promise.resolve(),
    afterUpdate = () => {
    },
    watch,
    id,
    invalidateId,
    persistent = false,
    renderFunction
  }) => {
    let watchIsRunning = false;
    const fallBackParentId = getParentIdFromWeakElementMap({
      element: getInvalidateParent({ id: invalidateId })
    });
    afterUpdate();
    const unsubScribeArray = observe.map((state) => {
      const unsubscribe3 = watch(state, async () => {
        if (watchIsRunning) return;
        freezePropById({ id, prop: state });
        const invalidateParent = getInvalidateParent({
          id: invalidateId
        });
        const descrementQueue = incrementTickQueuque({
          state,
          id,
          type: QUEQUE_TYPE_INVALIDATE
        });
        const decrementInvalidateQueque = incrementInvalidateTickQueuque({
          state,
          id,
          type: QUEQUE_TYPE_INVALIDATE
        });
        watchIsRunning = true;
        modules_exports.useNextLoop(async () => {
          if (!invalidateParent) {
            unFreezePropById({ id, prop: state });
            return;
          }
          await beforeUpdate();
          destroyNestedInvalidate({ id, invalidateParent });
          destroyNestedRepeat({ id, repeatParent: invalidateParent });
          destroyComponentInsideNodeById({
            id: fallBackParentId ?? id,
            container: invalidateParent
          });
          invalidateParent.textContent = "";
          invalidateParent.insertAdjacentHTML(
            "afterbegin",
            renderFunction()
          );
          mainStore.set(
            MAIN_STORE_ASYNC_PARSER,
            {
              element: invalidateParent,
              parentId: fallBackParentId ?? id,
              persistent
            },
            { emit: false }
          );
          await mainStore.emitAsync(MAIN_STORE_ASYNC_PARSER);
          resetMainStoreAsyncParser();
          watchIsRunning = false;
          descrementQueue();
          decrementInvalidateQueque();
          inizializeNestedInvalidate({ invalidateParent, id });
          inizializeNestedRepeat({ repeatParent: invalidateParent, id });
          unFreezePropById({ id, prop: state });
          afterUpdate();
        });
      });
      return unsubscribe3;
    });
    addInvalidateUnsubcribe({
      id,
      invalidateId,
      unsubscribe: unsubScribeArray
    });
  };

  // src/js/mob/mob-js/modules/invalidate/action/parse-bindprop-invalidate.js
  var parseObserveInvalidate = (observeProp) => {
    const observeArray = modules_exports.checkType(Array, observeProp) ? observeProp : [observeProp];
    return observeArray.map((item) => {
      return detectProp(item);
    });
  };

  // src/js/mob/mob-js/modules/invalidate/action/set-invalidate-function.js
  var setInvalidateFunction = ({ id, invalidateId, fn }) => {
    const currentFunctions = invalidateFunctionMap.get(id) ?? [];
    invalidateFunctionMap.set(id, [
      ...currentFunctions,
      { invalidateId, fn, unsubscribe: [() => {
      }] }
    ]);
  };

  // src/js/mob/mob-js/modules/invalidate/action/set-invalidate-placeholder-map-initialized.js
  var setInvalidatePlaceholderMapInitialized = ({ invalidateId }) => {
    const item = invalidateIdPlaceHolderMap.get(invalidateId);
    if (!item) return;
    invalidateIdPlaceHolderMap.set(invalidateId, {
      ...item,
      initialized: true
    });
  };

  // src/js/mob/mob-js/modules/invalidate/action/set-invalidate-placeholder-map-scoped-id.js
  var setInvalidatePlaceholderMapScopedId = ({
    invalidateId,
    scopeId
  }) => {
    invalidateIdPlaceHolderMap.set(invalidateId, {
      element: void 0,
      initialized: false,
      scopeId
    });
  };

  // src/js/mob/mob-js/modules/repeater/action/add-repeat-unsubcribe.js
  var addRepeatUnsubcribe = ({ id, repeatId, unsubscribe: unsubscribe3 }) => {
    const currentFunctions = repeatFunctionMap.get(id) ?? [];
    const item = currentFunctions.map((item2) => {
      if (item2.repeatId === repeatId) {
        return { ...item2, unsubscribe: unsubscribe3 };
      }
      return item2;
    });
    repeatFunctionMap.set(id, item);
  };

  // src/js/mob/mob-js/modules/repeater/active-repeater/index.js
  var activeRepeatMap = /* @__PURE__ */ new Set();
  var addActiveRepeat = ({ id, state, container }) => {
    activeRepeatMap.add({ id, state, container });
  };
  var removeActiveRepeat = ({ id, state, container }) => {
    if (!container) return;
    activeRepeatMap.forEach((repeat) => {
      if (id === repeat.id && state === repeat.state && container === repeat.container) {
        activeRepeatMap.delete(repeat);
      }
    });
  };
  var getActiveRepeater = ({ id = "", state = "", container }) => {
    const repeatIsActive = [...activeRepeatMap].some((repeat) => {
      return id === repeat.id && state === repeat.state && container === repeat.container;
    });
    return repeatIsActive;
  };

  // src/js/mob/mob-js/modules/repeater/utils.js
  var getItemToRemoveByKey = (current = [], previous = [], key = "") => {
    return current.filter((el) => {
      const value = el?.[key];
      return !previous.some((a) => a?.[key] === value);
    });
  };
  var mixPreviousAndCurrentData = (current, previous, key) => {
    return current.map((el, index) => {
      const value = el?.[key];
      const isNewElement = !previous.some((a) => a?.[key] === value);
      return isNewElement ? { isNewElement: true, keyValue: el?.[key], index } : { isNewElement: false, keyValue: el?.[key], index };
    });
  };
  var arrayhaskey = ({ arr = [], key = "" }) => {
    return arr.every((item) => {
      return modules_exports.checkType(Object, item) && key in item;
    });
  };
  var listKeyExist = ({ current, previous, key }) => {
    return arrayhaskey({ arr: current, key }) && arrayhaskey({ arr: previous, key });
  };
  var getUnivoqueByKey = ({ data = [], key = "" }) => {
    return data.filter(
      (v, i, a) => a.findIndex((v2) => v2?.[key] === v?.[key]) === i
    );
  };
  var chunkIdsByCurrentValue = ({ children, previousChildren = [] }) => {
    const initialState = {};
    return previousChildren.length === 0 ? Object.values(
      /**
       * Chunk children by currentValue ( index ) from a previous empty array.
       */
      children.reduce((previous, current) => {
        const { index } = getRepeaterStateById({ id: current });
        if (index in previous) {
          return {
            ...previous,
            [index]: [...previous[index], current]
          };
        }
        return { ...previous, [index]: [current] };
      }, initialState)
    ) : Object.values(
      /**
       * New elements has the same index of persistent element.
       *
       * The currentValue values of each component at this point have not yet been updated, so new index values
       * collide with previous ones (persistent elements).
       *
       * Mark new index element with `_<index>` char so we have a new group of component for new repeat node.
       *
       * `_<index>` has only internal use state, the function return string[][], the scope of `_<index>` is only
       * create a new group.
       */
      children.reduce((previous, current) => {
        const { index } = getRepeaterStateById({ id: current });
        const indexParsed = previousChildren.includes(current) ? `${index}` : `_${index}`;
        const values = previous?.[indexParsed];
        if (values) {
          return {
            ...previous,
            [indexParsed]: [...values, current]
          };
        }
        return { ...previous, [indexParsed]: [current] };
      }, initialState)
    );
  };

  // src/js/mob/mob-js/modules/repeater/action/get-repeat-placeholder-map-current-data.js
  var getRepeaterPlaceholderCurrentData = ({ repeatId }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return [];
    return item.currentData;
  };

  // src/js/mob/mob-js/modules/repeater/update/get-proxi.js
  var REPEAT_PROXI_INDEX = "index";
  var getRepeatProxi = ({
    observe,
    hasKey,
    key = "",
    keyValue = "",
    index,
    repeatId
  }) => {
    const inistalState = getRepeaterPlaceholderCurrentData({ repeatId });
    const startValue = hasKey ? inistalState?.find(
      (item) => item[key] === keyValue
    ) : inistalState?.[index];
    let currentValue = startValue;
    let lastValue = startValue;
    return new Proxy(
      {},
      {
        get(_, prop) {
          current_key_exports.setCurrentDependencies(observe);
          const state = getRepeaterPlaceholderCurrentData({ repeatId });
          const maxValue = Math.max(state?.length - 1, 0);
          if (prop === REPEAT_PROXI_INDEX) {
            if (hasKey) {
              const indexByKey = state?.findIndex(
                (item) => item[key] === keyValue
              );
              return clamp2(indexByKey, 0, maxValue);
            }
            return clamp2(index, 0, maxValue);
          }
          if (hasKey) {
            lastValue = currentValue ?? lastValue;
            currentValue = state?.find(
              (item) => item[key] === keyValue
            );
            return currentValue ?? lastValue;
          }
          lastValue = currentValue ?? lastValue;
          currentValue = state?.[clamp2(index, 0, maxValue)];
          return currentValue ?? lastValue;
        },
        set() {
          return false;
        }
      }
    );
  };

  // src/js/mob/mob-js/modules/repeater/update/utils.js
  var updateRepeaterWitoutKey = ({
    diff,
    current,
    previousLenght,
    render: render2,
    state,
    repeatId
  }) => {
    const range = document.createRange();
    const renderedDOM = [...Array.from({ length: diff }).keys()].map(
      (_item, index) => {
        const initialValue = current?.[index + previousLenght];
        const initialIndex = index + previousLenght;
        const proxiObject = getRepeatProxi({
          observe: state,
          hasKey: false,
          index: initialIndex,
          repeatId
        });
        const rawRender = render2({
          initialIndex,
          initialValue,
          current: proxiObject,
          sync: () => ""
        });
        const lastSkipUserValue = getSkipAddUserComponent();
        setSkipAddUserComponent(true);
        const fragment = range.createContextualFragment(rawRender);
        setSkipAddUserComponent(lastSkipUserValue);
        if (useRepeatWithoutSyncQuery) {
          const components = queryAllFutureComponent(fragment, false).map(
            (element) => {
              return new WeakRef(element);
            }
          );
          setRepeatAttribute({
            components,
            current: initialValue,
            index: initialIndex,
            observe: state,
            repeatId,
            key: void 0
          });
        }
        if (!useRepeatWithoutSyncQuery) {
          setRepeatAttributeFromInMemory({
            components: getInMemorySet(),
            current: initialValue,
            index: initialIndex,
            observe: state,
            repeatId,
            key: void 0
          });
        }
        return fragment.firstElementChild;
      }
    );
    return renderedDOM.filter((element) => element !== null);
  };
  var getSyncWithoutKey = ({ initialIndex, initialValue, state, repeatId }) => {
    return (
      /* HTML */
      `${ATTR_CURRENT_LIST_VALUE}="${setComponentRepeaterState({
        current: initialValue,
        index: initialIndex
      })}"
    ${ATTR_REPEATER_PROP_BIND}="${state}" ${ATTR_CHILD_REPEATID}="${repeatId}"`
    );
  };
  var updateRepeaterWithoutKeyUseSync = ({
    diff,
    previousLenght,
    current,
    state,
    repeatId,
    render: render2
  }) => {
    return [...Array.from({ length: diff }).keys()].map((_item, index) => {
      const initialIndex = index + previousLenght;
      const initialValue = current?.[initialIndex] ? { ...current?.[initialIndex] } : {};
      const proxiObject = getRepeatProxi({
        observe: state,
        hasKey: false,
        index: initialIndex,
        repeatId
      });
      return render2({
        sync: () => getSyncWithoutKey({
          initialIndex,
          initialValue,
          repeatId,
          state
        }),
        initialIndex,
        initialValue,
        current: proxiObject
      });
    }).join("");
  };
  var updateRepeaterWithtKey = ({
    currentValue,
    index,
    state,
    repeatId,
    key,
    keyValue,
    render: render2
  }) => {
    const proxiObject = getRepeatProxi({
      observe: state,
      hasKey: true,
      key,
      keyValue,
      index,
      repeatId
    });
    const lastSkipUserValue = getSkipAddUserComponent();
    setSkipAddUserComponent(true);
    const fragment = document.createRange().createContextualFragment(
      render2({
        initialIndex: index,
        initialValue: currentValue,
        current: proxiObject,
        sync: () => ""
      })
    );
    setSkipAddUserComponent(lastSkipUserValue);
    if (useRepeatWithoutSyncQuery) {
      const components = queryAllFutureComponent(fragment, false).map(
        (element) => {
          return new WeakRef(element);
        }
      );
      setRepeatAttribute({
        components,
        current: currentValue,
        index,
        observe: state,
        repeatId,
        key: keyValue
      });
    }
    if (!useRepeatWithoutSyncQuery) {
      setRepeatAttributeFromInMemory({
        components: getInMemorySet(),
        current: currentValue,
        index,
        observe: state,
        repeatId,
        key: keyValue
      });
    }
    return fragment.firstElementChild;
  };
  var getSyncWithKey = ({ keyValue, index, currentValue, state, repeatId }) => {
    return (
      /* HTML */
      ` ${ATTR_KEY}="${keyValue}"
    ${ATTR_REPEATER_PROP_BIND}="${state}"
    ${ATTR_CURRENT_LIST_VALUE}="${setComponentRepeaterState({
        current: currentValue,
        index
      })}"
    ${ATTR_CHILD_REPEATID}="${repeatId}"`
    );
  };
  var updateRepeaterWithtKeyUseSync = ({
    currentValue,
    index,
    state,
    repeatId,
    key,
    keyValue,
    render: render2
  }) => {
    const currentValueCopy = { ...currentValue };
    const proxiObject = getRepeatProxi({
      observe: state,
      hasKey: true,
      key,
      keyValue,
      index,
      repeatId
    });
    return render2({
      initialIndex: index,
      initialValue: currentValueCopy,
      current: proxiObject,
      sync: () => getSyncWithKey({
        currentValue: currentValueCopy,
        index,
        keyValue,
        repeatId,
        state
      })
    });
  };
  var getRenderWithoutSync = ({
    currentUnique,
    render: render2,
    observe,
    repeatId,
    key = "",
    hasKey
  }) => {
    const range = document.createRange();
    const renderedDOM = currentUnique.map((item, index) => {
      const proxiObject = getRepeatProxi({
        observe,
        hasKey,
        key,
        keyValue: hasKey ? item?.[key] : "",
        index,
        repeatId
      });
      const lastSkipUserValue = getSkipAddUserComponent();
      setSkipAddUserComponent(true);
      const fragment = range.createContextualFragment(
        render2({
          initialIndex: index,
          initialValue: item,
          current: proxiObject,
          sync: () => ""
        })
      );
      setSkipAddUserComponent(lastSkipUserValue);
      if (useRepeatWithoutSyncQuery) {
        const components = queryAllFutureComponent(fragment, false).map(
          (element) => {
            return new WeakRef(element);
          }
        );
        setRepeatAttribute({
          components,
          current: item,
          index,
          observe,
          repeatId,
          key: hasKey ? item?.[key] : ""
        });
      }
      if (!useRepeatWithoutSyncQuery) {
        setRepeatAttributeFromInMemory({
          components: getInMemorySet(),
          current: item,
          index,
          observe,
          repeatId,
          key: hasKey ? item?.[key] : ""
        });
      }
      return fragment.firstElementChild;
    });
    return renderedDOM.filter((element) => element !== null);
  };
  var getRenderWithSync = ({
    currentUnique,
    key = "",
    observe,
    repeatId,
    hasKey,
    render: render2
  }) => {
    const rawRender = () => {
      return currentUnique.map((item, index) => {
        const sync = (
          /* HTML */
          () => `${ATTR_CURRENT_LIST_VALUE}="${setComponentRepeaterState(
            {
              current: item,
              index
            }
          )}"
                            ${ATTR_KEY}="${hasKey ? item?.[key] : ""}"
                            ${ATTR_REPEATER_PROP_BIND}="${observe}"
                            ${ATTR_CHILD_REPEATID}="${repeatId}"`
        );
        const proxiObject = getRepeatProxi({
          observe,
          hasKey,
          key,
          keyValue: hasKey ? item?.[key] : "",
          index,
          repeatId
        });
        return render2({
          sync,
          initialIndex: index,
          initialValue: item,
          current: proxiObject
        });
      }).join("");
    };
    return rawRender();
  };

  // src/js/mob/mob-js/modules/repeater/action/set-repeat-native-dom-children.js
  var setRepeaterNativeDOMChildren = ({ repeatId, id, observe }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return;
    const { element } = item;
    if (!element) return;
    const children = (
      /** @type {HTMLElement[]} */
      [...element.children]
    );
    const state = getStateById(id);
    const stateByProp = state[observe];
    repeatIdPlaceHolderMap.set(repeatId, {
      ...item,
      key: observe,
      nativeDOMChildren: children.map((child, index) => {
        return { index, value: stateByProp[index], element: child };
      })
    });
  };
  var getRepeaterNativeDOMChildren = ({ repeatId }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return [];
    const { nativeDOMChildren } = item;
    return nativeDOMChildren;
  };

  // src/js/mob/mob-js/modules/repeater/action/set-repeat-placeholder-map-current-data.js
  var setRepeaterPlaceholderCurrentData = ({
    repeatId,
    currentData
  }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return;
    repeatIdPlaceHolderMap.set(repeatId, {
      ...item,
      currentData
    });
  };

  // src/js/mob/mob-js/modules/repeater/update/add-with-key.js
  var addDebugToComponent = ({ element, container }) => {
    const componentName = getComponentNameByElement(element);
    container.insertAdjacentHTML("beforeend", `<!-- ${componentName} --> `);
  };
  var addWithKey = ({
    state = "",
    current = [],
    previous = [],
    repeaterParentElement = document.createElement("div"),
    key = "",
    id = "",
    render: render2,
    repeatId,
    useSync
  }) => {
    const currentUnique = getUnivoqueByKey({ data: current, key });
    setRepeaterPlaceholderCurrentData({
      repeatId,
      currentData: currentUnique
    });
    const currentItemToRemoveByKey = getItemToRemoveByKey(
      previous,
      currentUnique,
      key
    );
    const componentsToRemoveByKey = currentItemToRemoveByKey.map((item) => {
      const keyValue = item?.[key];
      return getElementsByKeyAndRepeatId({
        keyValue,
        repeatId
      });
    }).filter((item) => item.length > 0);
    const shouldRemoveComponent = componentsToRemoveByKey.length > 0;
    componentsToRemoveByKey.forEach((item) => {
      const firstOccurrence = item[0].element;
      const firstCurrentId = item[0].id;
      if (!firstCurrentId) return;
      const elementWrapper = getRepeaterInnerWrap({ id: firstCurrentId });
      const nestedParent = (
        /** @type {HTMLElement} */
        elementWrapper ?? firstOccurrence
      );
      destroyNestedInvalidate({ id, invalidateParent: nestedParent });
      destroyNestedRepeat({ id, repeatParent: nestedParent });
      item.forEach(({ id: id2 }) => {
        removeAndDestroyById({ id: id2 });
      });
      if (elementWrapper) {
        elementWrapper.remove();
      }
    });
    if (!shouldRemoveComponent) {
      const childrenFromRepeater = getRepeaterNativeDOMChildren({ repeatId });
      const itemToRemove = childrenFromRepeater.filter((item) => {
        return currentItemToRemoveByKey.map((item2) => item2?.[key]).includes(item.value?.[key]);
      });
      itemToRemove.forEach((item) => {
        const { element: currentElement } = item;
        destroyNestedInvalidate({ id, invalidateParent: currentElement });
        destroyNestedRepeat({ id, repeatParent: currentElement });
        destroyComponentInsideNodeById({
          id,
          container: currentElement
        });
      });
    }
    const newSequenceByKey = mixPreviousAndCurrentData(
      currentUnique,
      previous,
      key
    ).map(({ keyValue, isNewElement, index }) => {
      if (isNewElement)
        return { keyValue, isNewElement, index, wrapper: void 0 };
      const element = getElementsByKeyAndRepeatId({
        keyValue,
        repeatId
      });
      const wrapperParsed = element[0]?.element ? getRepeaterInnerWrap({ id: element[0]?.id ?? "" }) : (() => {
        const childrenFromRepeater = getRepeaterNativeDOMChildren({
          repeatId
        });
        return childrenFromRepeater.find(
          (item) => item.value?.[key] === keyValue
        )?.element;
      })();
      return {
        keyValue,
        isNewElement,
        index,
        persistentElement: element,
        persistentDOMwrapper: wrapperParsed
      };
    });
    repeaterParentElement.replaceChildren();
    newSequenceByKey.forEach(
      ({
        isNewElement,
        keyValue,
        index,
        persistentElement,
        persistentDOMwrapper
      }) => {
        if (!isNewElement) {
          const { debug } = getDefaultComponent();
          if (persistentDOMwrapper) {
            repeaterParentElement.append(persistentDOMwrapper);
          }
          if (!persistentDOMwrapper && persistentElement?.[0]?.element) {
            repeaterParentElement.append(persistentElement[0].element);
            if (debug) {
              addDebugToComponent({
                element: persistentElement[0]?.element,
                container: repeaterParentElement
              });
            }
          }
          return;
        }
        const currentValue = currentUnique?.[index];
        const currentRender = useSync ? updateRepeaterWithtKeyUseSync({
          currentValue,
          index,
          state,
          repeatId,
          key,
          keyValue,
          render: render2
        }) : updateRepeaterWithtKey({
          currentValue,
          index,
          state,
          repeatId,
          key,
          keyValue,
          render: render2
        });
        if (useSync) {
          repeaterParentElement.insertAdjacentHTML(
            "beforeend",
            /** @type {string} */
            currentRender
          );
        }
        if (!useSync && currentRender) {
          repeaterParentElement.append(
            /** @type {Element} */
            currentRender
          );
        }
      }
    );
    return currentUnique;
  };

  // src/js/mob/mob-js/modules/repeater/update/add-without-key.js
  var removeMissedDebugComment = (container) => {
    const lastElementChild = container.lastElementChild;
    if (!lastElementChild) return;
    let node = lastElementChild.nextSibling;
    while (node) {
      const nextNode = node.nextSibling;
      if (node.nodeType === Node.COMMENT_NODE) {
        node.remove();
      }
      node = nextNode;
    }
  };
  var addWithoutKey = ({
    state = "",
    current = [],
    previous = [],
    repeaterParentElement = document.createElement("div"),
    render: render2,
    repeatId,
    id,
    useSync,
    currentChildren
  }) => {
    setRepeaterPlaceholderCurrentData({
      repeatId,
      currentData: current
    });
    const currentLenght = current.length;
    const previousLenght = previous.length;
    const diff = currentLenght - previousLenght;
    if (diff > 0) {
      const currentRender = useSync ? updateRepeaterWithoutKeyUseSync({
        diff,
        previousLenght,
        current,
        state,
        repeatId,
        render: render2
      }) : updateRepeaterWitoutKey({
        diff,
        current,
        previousLenght,
        render: render2,
        state,
        repeatId
      });
      if (useSync) {
        repeaterParentElement.insertAdjacentHTML(
          "beforeend",
          /** @type {string} */
          currentRender
        );
      }
      if (!useSync) {
        currentRender.forEach((element) => {
          repeaterParentElement.append(element);
        });
      }
    }
    if (diff < 0) {
      const childrenComponentChunkedByWrapper = chunkIdsByCurrentValue({
        children: currentChildren
      });
      const componentToRemoveByKey = childrenComponentChunkedByWrapper.filter(
        (_child, i) => {
          return i >= current.length;
        }
      );
      componentToRemoveByKey.forEach((childArray) => {
        childArray.forEach((childId) => {
          const element = getElementById({ id: childId });
          const elementWrapper = getRepeaterInnerWrap({
            id: childId
          });
          const nestedParent = (
            /** @type {HTMLElement} */
            elementWrapper ?? element
          );
          destroyNestedInvalidate({ id, invalidateParent: nestedParent });
          destroyNestedRepeat({ id, repeatParent: nestedParent });
          removeAndDestroyById({ id: childId });
          if (elementWrapper) elementWrapper.remove();
        });
      });
      const { debug } = getDefaultComponent();
      if (debug) removeMissedDebugComment(repeaterParentElement);
      if (childrenComponentChunkedByWrapper.length > 0) return current;
      const childrenFromRepeater = getRepeaterNativeDOMChildren({ repeatId });
      if (!childrenFromRepeater) return current;
      const childrenFromRepeaterToRemove = childrenFromRepeater.filter(
        ({ index }) => {
          return index >= current.length;
        }
      );
      childrenFromRepeaterToRemove.forEach((item) => {
        const { element: currentElement } = item;
        destroyNestedInvalidate({ id, invalidateParent: currentElement });
        destroyNestedRepeat({ id, repeatParent: currentElement });
        destroyComponentInsideNodeById({
          id,
          container: currentElement
        });
        currentElement.remove();
      });
    }
    return current;
  };

  // src/js/mob/mob-js/modules/repeater/update/index.js
  var updateRepeater = async ({
    state = "",
    persistent,
    repeaterParentElement = document.createElement("div"),
    current = [],
    previous = [],
    key = "",
    id,
    fallBackParentId = "",
    render: render2,
    repeatId,
    useSync,
    currentChildren = []
  }) => {
    const hasKey = listKeyExist({ current, previous, key });
    const fn = hasKey ? addWithKey : addWithoutKey;
    const currentUnivoque = fn({
      state,
      current,
      previous,
      repeaterParentElement,
      key,
      id,
      render: render2,
      repeatId,
      useSync,
      currentChildren
    });
    mainStore.set(
      MAIN_STORE_ASYNC_PARSER,
      {
        element: repeaterParentElement,
        parentId: fallBackParentId ?? id,
        persistent
      },
      { emit: false }
    );
    await mainStore.emitAsync(MAIN_STORE_ASYNC_PARSER);
    resetMainStoreAsyncParser();
    return currentUnivoque;
  };

  // src/js/mob/mob-js/modules/repeater/watch/index.js
  var watchRepeat = ({
    state = "",
    setState,
    persistent = false,
    watch,
    clean: clean2 = false,
    beforeUpdate,
    afterUpdate,
    key = "",
    id = "",
    repeatId = "",
    render: render2,
    useSync = false
  }) => {
    const mainComponent = getElementById({ id });
    const parentByElement = getRepeatParent({ id: repeatId });
    const fallBackParentId = parentByElement ? getParentIdFromWeakElementMap({ element: parentByElement }) ?? "" : "";
    afterUpdate();
    const unsubscribe3 = watch(
      state,
      async (current, previous) => {
        if (!modules_exports.checkType(Array, current)) return;
        const repeaterParentElement = getRepeatParent({
          id: repeatId
        });
        const descrementQueue = incrementTickQueuque({
          state,
          id,
          type: QUEQUE_TYPE_REPEATER
        });
        const descrementRepeaterQueue = incrementRepeaterTickQueuque({
          state,
          id,
          type: QUEQUE_TYPE_REPEATER
        });
        freezePropById({ id, prop: state });
        const repeatIsRunning = getActiveRepeater({
          id,
          state,
          container: repeaterParentElement
        });
        if (repeatIsRunning) {
          unFreezePropById({ id, prop: state });
          setState(state, previous, { emit: false });
          descrementQueue();
          descrementRepeaterQueue();
          return;
        }
        const childrenBeforeUdateByRepeatId = getIdsByByRepeatId({
          id,
          repeatId
        });
        if (mainComponent) {
          await beforeUpdate();
        }
        if (clean2) {
          childrenBeforeUdateByRepeatId.forEach((id2) => {
            removeAndDestroyById({ id: id2 });
          });
          if (repeaterParentElement) {
            repeaterParentElement.textContent = "";
          }
        }
        if (repeaterParentElement)
          addActiveRepeat({
            id,
            state,
            container: repeaterParentElement
          });
        const currentUpdated = await updateRepeater({
          state,
          persistent,
          repeaterParentElement: repeaterParentElement ?? document.createElement("div"),
          current,
          previous: clean2 ? [] : previous,
          key,
          id,
          fallBackParentId,
          render: render2,
          repeatId,
          useSync,
          currentChildren: clean2 ? [] : childrenBeforeUdateByRepeatId
        });
        const childrenFilteredByRepeatId = getIdsByByRepeatId({
          id,
          repeatId
        });
        const hasKey = key && key !== "";
        const childrenChunkedByWrapper = chunkIdsByCurrentValue({
          children: childrenFilteredByRepeatId,
          previousChildren: childrenBeforeUdateByRepeatId
        });
        const chunkChildrenOrdered = hasKey ? [
          ...getOrderedChunkByCurrentRepeatValue({
            children: childrenChunkedByWrapper,
            key,
            current,
            currentUnivoque: currentUpdated
          })
        ] : childrenChunkedByWrapper;
        chunkChildrenOrdered.forEach((childArray, index) => {
          childArray.forEach((id2) => {
            const currentValue = currentUpdated?.[index];
            if (!currentValue) return;
            const realIndex = hasKey ? current.findIndex((value) => {
              return `${value?.[key]}` === `${currentUpdated?.[index]?.[key]}`;
            }) : index;
            setRepeaterStateById({
              id: id2,
              value: { current: currentValue, index: realIndex }
            });
          });
        });
        modules_exports.useNextLoop(async () => {
          if (mainComponent) {
            afterUpdate();
          }
          removeActiveRepeat({
            id,
            state,
            container: repeaterParentElement
          });
          unFreezePropById({ id, prop: state });
          descrementQueue();
          descrementRepeaterQueue();
          inizializeNestedInvalidate({
            invalidateParent: repeaterParentElement,
            id
          });
          inizializeNestedRepeat({
            repeatParent: repeaterParentElement,
            id
          });
          if (chunkChildrenOrdered.length === 0) {
            setRepeaterNativeDOMChildren({
              repeatId,
              id,
              observe: state
            });
          }
        });
      }
    );
    return unsubscribe3;
  };

  // src/js/mob/mob-js/modules/repeater/action/inizialize-repeat-watch.js
  var inizializeRepeatWatch = ({
    repeatId,
    persistent,
    state,
    setState,
    emit,
    watch,
    clean: clean2,
    beforeUpdate,
    afterUpdate,
    key,
    id,
    render: render2,
    useSync
  }) => {
    const unsubscribe3 = watchRepeat({
      state,
      setState,
      persistent,
      emit,
      watch,
      clean: clean2,
      beforeUpdate,
      afterUpdate,
      key,
      id,
      repeatId,
      render: render2,
      useSync
    });
    addRepeatUnsubcribe({
      id,
      repeatId,
      unsubscribe: unsubscribe3
    });
  };

  // src/js/mob/mob-js/modules/repeater/action/set-repeat-function.js
  var setRepeatFunction = ({ id, repeatId, fn }) => {
    const currentFunctions = repeatFunctionMap.get(id) ?? [];
    repeatFunctionMap.set(id, [
      ...currentFunctions,
      { repeatId, fn, unsubscribe: () => {
      } }
    ]);
  };

  // src/js/mob/mob-js/modules/repeater/action/set-repeater-placeholder-map-initialized.js
  var setRepeaterPlaceholderMapInitialized = ({ repeatId }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return;
    repeatIdPlaceHolderMap.set(repeatId, {
      ...item,
      initialized: true
    });
  };

  // src/js/mob/mob-js/modules/repeater/action/set-repeater-placeholder-map-initial-render.js
  var setRepeaterPlaceholderDOMRender = ({
    repeatId,
    initialDOMRender
  }) => {
    const item = repeatIdPlaceHolderMap.get(repeatId);
    if (!item) return;
    repeatIdPlaceHolderMap.set(repeatId, {
      ...item,
      initialRenderWithoutSync: initialDOMRender
    });
  };

  // src/js/mob/mob-js/modules/repeater/action/initialize-repeater-placeholder-map.js
  var initializeRepeaterPlaceholderMap = ({ repeatId, scopeId }) => {
    repeatIdPlaceHolderMap.set(repeatId, {
      element: void 0,
      initialized: false,
      scopeId,
      key: "",
      nativeDOMChildren: [],
      componentChildren: [],
      currentData: [],
      initialRenderWithoutSync: []
    });
  };

  // src/js/mob/mob-js/parse/steps/get-params-for-component.js
  var getParamsForComponentFunction = ({
    getState,
    setState,
    updateState,
    getProxi,
    emit,
    emitAsync,
    computed,
    watch,
    id,
    key,
    bindEventsId,
    debug
  }) => {
    const repeatIdArray = [];
    return {
      bindEventsId,
      key,
      id,
      getState,
      setState,
      updateState,
      getProxi,
      emit,
      emitAsync,
      computed,
      watch,
      debug,
      repeatIdArray,
      renderComponent: async ({
        attachTo,
        component,
        position: position2 = "afterbegin",
        clean: clean2 = true
      }) => {
        if (clean2) {
          destroyComponentInsideNodeById({ id, container: attachTo });
          attachTo.textContent = "";
        }
        attachTo.insertAdjacentHTML(position2, component);
        mainStore.set(
          MAIN_STORE_ASYNC_PARSER,
          {
            element: attachTo,
            parentId: id,
            persistent: componentIsPersistent(id)
          },
          { emit: false }
        );
        await mainStore.emitAsync(MAIN_STORE_ASYNC_PARSER);
        resetMainStoreAsyncParser();
        return;
      },
      getChildren: (componentName) => {
        return getChildrenIdByName({ id, componentName });
      },
      /**
       * Ts issue, prop coem as string\number\symbol, convert in string.
       */
      freezeProp: (prop) => {
        const bindParsed = detectProp(prop);
        return freezePropById({ id, prop: bindParsed.toString() });
      },
      unFreezeProp: (prop) => {
        const bindParsed = detectProp(prop);
        return unFreezePropById({ id, prop: bindParsed.toString() });
      },
      unBind: () => unBind({ id }),
      bindProps: (data) => {
        const dataNormalized = "props" in data ? data : { props: data };
        return `${ATTR_BIND_PROPS}="${setBindProps({
          ...dataNormalized,
          parentId: id
        })}" `;
      },
      staticProps: (obj) => ` ${ATTR_PROPS}="${setStaticProps(obj)}" `,
      remove: () => {
        removeAndDestroyById({ id });
      },
      removeDOM: (element) => {
        destroyComponentInsideNodeById({ id, container: element });
        element.textContent = "";
      },
      getParentId: () => getParentIdById(id),
      watchParent: (prop, cb) => {
        const unsubscribeParent = watchById(getParentIdById(id), prop, cb);
        if (unsubscribeParent)
          setDynamicPropsWatch({ id, unWatchArray: [unsubscribeParent] });
      },
      onMount: (cb) => addOnMoutCallback({ id, cb }),
      bindEvents: (eventsData) => {
        return `${ATTR_BIND_EVENTS}="${setBindEvents(eventsData)}"`;
      },
      delegateEvents: (eventsData) => {
        return `${ATTR_WEAK_BIND_EVENTS}="${setDelegateBindEvent(
          eventsData
        )}"`;
      },
      bindEffect: (effectData) => {
        return `${ATTR_BIND_EFFECT}="${setBindEffect({ data: effectData, id })}"`;
      },
      addMethod: (name, fn) => {
        addMethodById({ id, name, fn });
      },
      setRef: (value) => {
        return `${ATTR_BIND_REFS_ID}="${id}" ${ATTR_BIND_REFS_NAME}="${value}"`;
      },
      getRef: () => {
        return getBindRefById({ id });
      },
      getRefs: () => {
        return getBindRefsById({ id });
      },
      bindText: (strings, ...values) => {
        const bindTextId = modules_exports.getUnivoqueId();
        const render2 = () => renderBindText(id, strings, ...values);
        createBindTextWatcher(id, bindTextId, render2, ...values);
        return `<mobjs-bind-text ${ATTR_COMPONENT_ID}="${id}" ${ATTR_BIND_TEXT_ID}="${bindTextId}"></mobjs-bind-text>${render2()}`;
      },
      bindObject: (strings, ...values) => {
        const keys = getBindObjectKeys(values);
        const bindObjectId = modules_exports.getUnivoqueId();
        const render2 = () => renderBindObject(strings, ...values);
        createBindObjectWatcher(id, bindObjectId, keys, render2);
        return `<mobjs-bind-object ${ATTR_COMPONENT_ID}="${id}" ${ATTR_BIND_OBJECT_ID}="${bindObjectId}"></mobjs-bind-object>${render2()}`;
      },
      invalidate: ({
        observe,
        render: render2,
        beforeUpdate = () => Promise.resolve(),
        afterUpdate = () => {
        }
      }) => {
        const observeParsed = parseObserveInvalidate(observe);
        const invalidateId = modules_exports.getUnivoqueId();
        const sync = `${ATTR_INVALIDATE}=${invalidateId}`;
        const invalidateRender = () => render2();
        let isInizialized = false;
        setInvalidatePlaceholderMapScopedId({ invalidateId, scopeId: id });
        setInvalidateFunction({
          id,
          invalidateId,
          fn: () => {
            if (isInizialized) return;
            inizializeInvalidateWatch({
              observe: (
                /** @type {string[]} */
                observeParsed
              ),
              watch,
              beforeUpdate,
              afterUpdate,
              persistent: componentIsPersistent(id),
              id,
              invalidateId,
              renderFunction: invalidateRender
            });
            isInizialized = true;
            setInvalidatePlaceholderMapInitialized({
              invalidateId
            });
          }
        });
        return `<mobjs-invalidate ${sync} style="display:none;"></mobjs-invalidate>${invalidateRender()}`;
      },
      repeat: ({
        observe,
        clean: clean2 = false,
        beforeUpdate = () => Promise.resolve(),
        afterUpdate = () => {
        },
        key: key2 = "",
        render: render2,
        useSync = false
      }) => {
        const observeParsed = detectProp(observe);
        const repeatId = modules_exports.getUnivoqueId();
        const hasKey = key2 !== "";
        initializeRepeaterPlaceholderMap({
          repeatId,
          scopeId: id
        });
        const initialState = getState()?.[observeParsed];
        const currentUnique = hasKey ? getUnivoqueByKey({ data: initialState, key: key2 }) : initialState;
        setRepeaterPlaceholderCurrentData({
          repeatId,
          currentData: currentUnique
        });
        const initialStringRender = useSync ? getRenderWithSync({
          currentUnique,
          key: key2,
          observe: observeParsed,
          repeatId,
          hasKey,
          render: render2
        }) : "";
        const initialDOMRender = useSync ? [] : getRenderWithoutSync({
          currentUnique,
          render: render2,
          observe: observeParsed,
          repeatId,
          key: key2,
          hasKey
        });
        let isInizialized = false;
        setRepeaterPlaceholderDOMRender({
          repeatId,
          initialDOMRender
        });
        setRepeatFunction({
          id,
          repeatId,
          fn: () => {
            if (isInizialized) return;
            inizializeRepeatWatch({
              repeatId,
              persistent: componentIsPersistent(id),
              state: observeParsed,
              setState,
              emit,
              watch,
              clean: clean2,
              beforeUpdate,
              afterUpdate,
              key: key2,
              id,
              render: render2,
              useSync
            });
            isInizialized = true;
            setRepeaterPlaceholderMapInitialized({
              repeatId
            });
            if (!repeaterhasComponentChildren({ repeatId })) {
              setRepeaterNativeDOMChildren({
                repeatId,
                id,
                observe: observeParsed
              });
            }
          }
        });
        return `<mobjs-repeat ${ATTR_MOBJS_REPEAT}="${repeatId}" style="display:none;"></mobjs-repeat>${initialStringRender}`;
      }
    };
  };

  // src/js/mob/mob-js/component/action/state/export-state.js
  var filterExportableStateFromObject = ({
    componentName,
    currentProps = {}
  }) => {
    const componentList = getComponentList();
    const exportableState = componentList?.[componentName]?.componentParams?.exportState ?? [];
    return Object.entries(currentProps).filter(([key]) => {
      return exportableState.includes(key);
    }).reduce((previous, current) => {
      const [key, value] = current;
      return { ...previous, [key]: value };
    }, {});
  };

  // src/js/mob/mob-js/parse/steps/get-params-from-web-component.js
  var getParamsFromWebComponent = ({ element, parentIdForced }) => {
    const id = element.getId();
    const instanceName = element.getInstanceName();
    const parentIdFromWebComponent = element.getParentId();
    const parentId = autoDetectParentId ? getParentIdFromWeakElementMap({ element }) : parentIdFromWebComponent && parentIdFromWebComponent.length > 0 ? parentIdFromWebComponent : parentIdForced;
    const propsId = element.getStaticPropsId();
    const dynamicPropsId = element.getDynamicPropsid();
    const bindEventsId = element.getBindEventsId();
    const currentRepeaterValueId = element.getRepeatValue();
    const componentRepeatId = element.getComponentRepeatId();
    const key = element.getCurrentKey() ?? "";
    const componentName = element.getComponentName();
    const cleanProsId = propsId?.split(" ").join("");
    const propsFromParent = getPropsFromParent(cleanProsId);
    const baseProps = { ...element.dataset };
    const repeatPropBind = element.getRepeaterPropBind();
    const currentRepeatValue = getComponentRepeaterState(
      currentRepeaterValueId
    );
    return {
      element,
      props: {
        ...filterExportableStateFromObject({
          componentName,
          currentProps: baseProps
        }),
        ...filterExportableStateFromObject({
          componentName,
          currentProps: propsFromParent
        })
      },
      id,
      componentName,
      instanceName,
      key,
      dynamicPropsId,
      repeatPropBind,
      bindEventsId,
      currentRepeatValue,
      parentId,
      componentRepeatId
    };
  };

  // src/js/mob/mob-js/component/action/remove-and-destroy/cancellable-component/add-persisitent-component.js
  var addNonPersisitentComponent = (id) => {
    nonPersisitentComponentSet.add(id);
  };

  // src/js/mob/mob-js/component/index.js
  var addComponentToStore = ({
    element,
    instanceName = "",
    props = {},
    state = {},
    bindStore,
    methods = {},
    key = "",
    currentRepeaterState = DEFAULT_CURRENT_REPEATER_STATE,
    repeaterInnerWrap,
    repeatPropBind = "",
    componentRepeatId = "",
    parentPropsWatcher = [() => {
    }],
    refs = {},
    destroy: destroy3 = () => {
    },
    freezedPros = [],
    persistent = false,
    child = {},
    parentId = "",
    id = "",
    componentName = ""
  }) => {
    const store2 = modules_exports.createStore(state);
    addPropsToState({ props, store: store2 });
    if (bindStore) {
      store2.bindStore(bindStore);
    }
    if (!persistent) {
      addNonPersisitentComponent(id);
    }
    if (componentRepeatId && componentRepeatId.length > 0) {
      setRepeaterComponentChildren({
        componentId: id,
        repeatId: componentRepeatId
      });
    }
    if (instanceName && instanceName.length > 0) {
      addIdToInstanceMap({ instanceName, id });
    }
    componentMap.set(id, {
      element,
      componentName,
      instanceName,
      destroy: destroy3,
      parentPropsWatcher,
      refs,
      methods,
      key,
      currentRepeaterState,
      repeaterInnerWrap,
      repeatPropBind,
      componentRepeatId,
      persistent,
      id,
      parentId,
      freezedPros,
      child,
      state: store2
    });
    return {
      getState: () => store2.get(),
      setState: (prop = "", value = {}, { emit = true } = {}) => {
        const isFreezed2 = getFreezePropStatus({ id, prop });
        if (isFreezed2) return;
        store2.set(prop, value, { emit: emit ?? true });
      },
      updateState: (prop = "", updateFunction = () => {
      }, { emit = true, clone = false } = {}) => {
        const isFreezed2 = getFreezePropStatus({ id, prop });
        if (isFreezed2) return;
        store2.update(prop, updateFunction, {
          emit: emit ?? true,
          clone: clone ?? false
        });
      },
      getProxi: () => store2.getProxi(),
      emit: (prop = "") => store2.emit(prop),
      emitAsync: async (prop = "") => await store2.emitAsync(prop),
      computed: (prop = "", fn = () => {
      }, keys = []) => store2.computed(prop, fn, keys),
      watch: (prop = "", cb = () => {
      }, { wait = false, immediate = false } = {}) => store2.watch(prop, cb, {
        wait: wait ?? false,
        immediate: immediate ?? false
      }),
      debug: () => store2.debug()
    };
  };

  // src/js/mob/mob-js/modules/invalidate/action/get-invalidate-functions.js
  var getInvalidateFunctions = ({ id }) => {
    return invalidateFunctionMap.get(id) ?? [];
  };

  // src/js/mob/mob-js/modules/repeater/action/get-repeat-functions.js
  var getRepeatFunctions = ({ id }) => {
    return repeatFunctionMap.get(id) ?? [];
  };

  // src/js/mob/mob-js/parse/parse-function-while.js
  var parseComponentsWhile = async ({
    element,
    persistent = false,
    parentIdForced = ""
  }) => {
    const componentList = getComponentList();
    const functionToFireAtTheEnd = [];
    const result = getParseSourceArray({
      element,
      currentSelectors: []
    });
    let currentSelectors = result.parseSourceArray;
    let componentToParse = result?.componentToParse;
    while (componentToParse) {
      const componentToParseName = componentToParse.getComponentName();
      const userFunctionComponent = componentList?.[componentToParseName]?.componentFunction;
      const componentParams = componentList?.[componentToParseName]?.componentParams;
      const { scoped, bindStore } = componentParams;
      const {
        props,
        id,
        componentName,
        instanceName,
        key,
        dynamicPropsId,
        currentRepeatValue,
        bindEventsId,
        parentId,
        componentRepeatId,
        repeatPropBind
      } = getParamsFromWebComponent({
        element: componentToParse,
        parentIdForced
      });
      const state = componentParams?.state ?? {};
      const {
        getState,
        setState,
        updateState,
        getProxi,
        emit,
        emitAsync,
        computed,
        watch,
        debug
      } = addComponentToStore({
        element: componentToParse,
        props,
        state,
        id,
        componentName,
        instanceName,
        key,
        repeatPropBind,
        persistent,
        parentId,
        componentRepeatId,
        bindStore
      });
      addSelfIdToParentComponent({ id });
      if (componentRepeatId && componentRepeatId?.length > 0) {
        setRepeaterStateById({ id, value: currentRepeatValue });
        setRepeaterInnerWrap({
          id,
          repeatId: componentRepeatId,
          element: componentToParse
        });
      }
      addCurrentIdToBindProps({
        propsId: dynamicPropsId,
        repeatPropBind,
        componentId: id
      });
      const objectFromComponentFunction = getParamsForComponentFunction({
        getState,
        setState,
        updateState,
        getProxi,
        emit,
        emitAsync,
        computed,
        watch,
        id,
        key,
        bindEventsId,
        debug
      });
      const content = await userFunctionComponent(
        objectFromComponentFunction
      );
      const classList = componentToParse.classList;
      const { newElement } = convertToRealElement({
        content,
        // @ts-ignore
        element: componentToParse
      });
      if (!useSlotQuery) clearSlotPlaceHolder();
      if (classList.length > 0) {
        newElement?.classList.add(...classList);
      }
      if (!autoDetectParentId)
        addParentIdToFutureComponent({ element: newElement, id });
      if (!newElement) {
        return;
      }
      setElementById({ id, newElement });
      const invalidateFunctions = getInvalidateFunctions({ id });
      const repeatFunctions = getRepeatFunctions({ id });
      if (bindEventsId) {
        applyBindEvents({
          element: newElement,
          componentId: id,
          bindEventsId
        });
      }
      const shoulBeScoped = scoped ?? getDefaultComponent().scoped;
      if (shoulBeScoped) {
        await fireOnMountCallBack({
          id,
          element: newElement
        });
      }
      newElement?.inizializeCustomComponent?.(objectFromComponentFunction);
      functionToFireAtTheEnd.push({
        onMount: async () => {
          if (shoulBeScoped) return;
          await fireOnMountCallBack({
            id,
            element: newElement
          });
        },
        initializeBindPropsWatcher: () => {
          applyBindProps({
            componentId: id,
            repeatPropBind,
            inizilizeWatcher: true
          });
        },
        fireInvalidateFunction: invalidateFunctions.length > 0 ? () => {
          invalidateFunctions.forEach(({ fn }) => {
            fn?.();
          });
        } : () => {
        },
        fireRepeatFunction: repeatFunctions.length > 0 ? () => {
          repeatFunctions.forEach(({ fn }) => {
            fn?.();
          });
        } : () => {
        }
      });
      const result2 = getParseSourceArray({
        element,
        currentSelectors
      });
      currentSelectors = result2.parseSourceArray;
      componentToParse = result2.componentToParse;
      const parseLimitReached = getCurrentIterationCounter() === getDefaultComponent().maxParseIteration;
      incrementCurrentIterationCounter();
      if (parseLimitReached) {
        console.warn(
          `dom parse reached max parse limit: ${getCurrentIterationCounter()}`
        );
        break;
      }
    }
    const bindRefs = getBindRefs({ element });
    if (Object.keys(bindRefs).length > 0) addBindRefsToComponent(bindRefs);
    for (const item of functionToFireAtTheEnd.reverse()) {
      const {
        onMount,
        initializeBindPropsWatcher,
        fireInvalidateFunction,
        fireRepeatFunction
      } = item;
      await onMount();
      fireRepeatFunction();
      fireInvalidateFunction();
      initializeBindPropsWatcher();
    }
    functionToFireAtTheEnd.length = 0;
    currentSelectors.length = 0;
    componentToParse = null;
    applyDelegationBindEvent(element);
    applyBindEffect(element);
    switchBindTextMap();
    switchBindObjectMap();
    return;
  };

  // src/js/mob/mob-js/parse/index.js
  var parseComponents = async ({
    element,
    persistent = false,
    parentIdForced = ""
  }) => {
    await parseComponentsWhile({
      element,
      persistent,
      parentIdForced
    });
    resetCurrentIterationCounter();
  };
  var initParseWatcher = () => {
    mainStore.watch(
      MAIN_STORE_ASYNC_PARSER,
      async ({ element, parentId, persistent = false }) => {
        await parseComponents({
          element,
          parentIdForced: parentId ?? "",
          persistent
        });
      }
    );
  };

  // src/js/mob/mob-js/route/constant.js
  var HISTORY_BACK = "BACK";
  var HISTORY_NEXT = "NEXT";

  // src/js/mob/mob-js/route/history/index.js
  var historyBack = [];
  var historyNext = [];
  var deleteLastHistoryBack = () => {
    const arrayLenght = historyBack.length;
    if (arrayLenght >= 1) historyBack.length = historyBack.length - 1;
  };
  var deleteLastHistoryNext = () => {
    const arrayLenght = historyNext.length;
    if (arrayLenght >= 1) historyNext.length = historyNext.length - 1;
  };
  var setHistoryBack = (value) => {
    historyBack.push(value);
  };
  var setHistoryNext = (value) => {
    historyNext.push(value);
  };
  var resetNext = () => {
    historyNext = [];
  };
  var historyBackSize = () => {
    return historyBack.length;
  };
  var getLastHistoryBack = () => {
    const value = historyBack.at(-1);
    deleteLastHistoryBack();
    return value;
  };
  var getPenultimateHistoryNext = () => {
    const value = historyNext.at(-2);
    deleteLastHistoryNext();
    return value;
  };
  var getLastHistoryNext = () => {
    const value = historyNext.at(-1);
    return value;
  };
  var getLastHistory = (direction2) => {
    if (direction2 === HISTORY_BACK) {
      return getLastHistoryBack();
    }
    return getPenultimateHistoryNext();
  };

  // src/js/mob/mob-js/component/action/remove-and-destroy/remove-orphan-temp-ids.js
  var removeOrphanTempIds = () => {
    removeOrphansPropsFromParent();
    removeOrphansBindEvent();
    removeOrphansBindProps();
  };

  // src/js/mob/mob-js/route/page-transition/index.js
  var pageTransition = () => {
  };
  var beforePageTransition = () => {
  };
  var setBeforePageTransition = ({ fn }) => {
    if (!fn) return;
    beforePageTransition = fn;
  };
  var setPageTransition = ({ fn }) => {
    if (!fn) return;
    pageTransition = fn;
  };
  var getBeforePageTransition = () => beforePageTransition;
  var getPageTransition = () => pageTransition;

  // src/js/mob/mob-js/route/scroll/index.js
  var restoreScroll = true;
  var setRestoreScroll = (value) => {
    restoreScroll = value;
  };
  var getRestoreScroll = () => restoreScroll;

  // src/js/mob/mob-js/component/action/remove-and-destroy/cancellable-component/destroy-all-non-persisitent-component.js
  var removeCancellableComponent = () => {
    for (const id of nonPersisitentComponentSet) {
      removeAndDestroyById({ id });
    }
  };

  // src/js/mob/mob-js/route/load-route/index.js
  var loadRoute = async ({
    route = "",
    templateName = "",
    restoreScroll: restoreScroll2 = true,
    params = {},
    scrollY: scrollY2,
    skipTransition
  }) => {
    mainStore.set(MAIN_STORE_ROUTE_IS_LOADING, true);
    await tick();
    const contentElement = getContentElement();
    if (!contentElement || !(contentElement instanceof HTMLElement)) return;
    if (!skipTransition) contentElement.style.visibility = "hidden";
    const { activeRoute: fromRoute } = mainStore.get();
    mainStore.set(MAIN_STORE_BEFORE_ROUTE_CHANGE, {
      currentRoute: fromRoute.route,
      currentTemplate: fromRoute.templateName,
      nextRoute: route,
      nextTemplate: templateName
    });
    let skip = false;
    const unWatchRouteChange = mainStore.watch(
      MAIN_STORE_BEFORE_ROUTE_CHANGE,
      () => {
        skip = true;
      }
    );
    removeOrphanTempIds();
    mainStore.set(MAIN_STORE_ACTIVE_ROUTE, { route, templateName });
    mainStore.set(MAIN_STORE_ACTIVE_PARAMS, params);
    const routeObejct = getRouteByName({ routeName: route });
    const props = routeObejct?.props ?? {};
    const content = await routeObejct?.layout?.({ params, props }) ?? "";
    const beforePageTransition3 = getBeforePageTransition();
    let clone = contentElement.cloneNode(true);
    if (beforePageTransition3 && clone && !skipTransition) {
      await beforePageTransition3({
        // @ts-ignore
        oldNode: clone,
        oldRoute: fromRoute.route,
        newRoute: route,
        oldTemplateName: fromRoute.templateName,
        newTemplateName: templateName
      });
      contentElement?.parentNode?.insertBefore(clone, contentElement);
    }
    contentElement.replaceChildren();
    removeCancellableComponent();
    contentElement.insertAdjacentHTML("afterbegin", content);
    await parseComponents({ element: contentElement });
    if (!skipTransition) contentElement.style.visibility = "";
    if (!skip)
      mainStore.set(MAIN_STORE_AFTER_ROUTE_CHANGE, {
        currentRoute: route,
        currentTemplate: templateName,
        previousRoute: fromRoute.route,
        previousTemplate: fromRoute.templateName
      });
    if (getRestoreScroll() && restoreScroll2) scrollTo(0, scrollY2);
    document.body.dataset["route"] = route;
    document.body.dataset["template"] = templateName;
    const pageTransition3 = getPageTransition();
    if (pageTransition3 && !skipTransition) {
      await pageTransition3({
        oldNode: clone,
        newNode: contentElement,
        oldRoute: fromRoute.route,
        newRoute: route,
        oldTemplateName: fromRoute.templateName,
        newTemplateName: templateName
      });
      clone.remove();
    }
    clone = null;
    unWatchRouteChange?.();
    mainStore.set(MAIN_STORE_ROUTE_IS_LOADING, false);
  };

  // src/js/mob/mob-js/route/redirect/index.js
  var redirectFunction = ({ route }) => route;
  var setRedirectFunction = (fn) => {
    redirectFunction = fn;
  };
  var tryRedirect = ({ route }) => {
    const newRoute = redirectFunction({ route });
    return {
      route: newRoute,
      isRedirect: newRoute !== route
    };
  };

  // src/js/mob/mob-js/route/utils.js
  var getRouteModule = ({ url = "" }) => {
    const index = getIndex();
    const pageNotFound3 = getPageNotFound();
    if (url === "") return index;
    return getRouteByName({ routeName: url }) ? url : pageNotFound3;
  };
  var getTemplateName = ({ url = "" }) => {
    return getRouteByName({ routeName: url })?.templateName ?? "";
  };
  var getRestoreScrollVale = ({ url = "" }) => {
    return getRouteByName({ routeName: url })?.restoreScroll ?? true;
  };

  // src/js/mob/mob-js/route/index.js
  var previousHash = "";
  var previousParamsToPush = "";
  var currentStringParams;
  var currentSkipTransition;
  var historyDirection = "back";
  var previousHistory;
  var currentHistory;
  var sanitizeParams = (value) => {
    return value.replace("?", "").replace("/", "");
  };
  var sanitizeHash = (value) => {
    return value.replace("#", "").replace("/", "").replace(".", "");
  };
  var getParams = (value) => {
    return value.split("&").reduce((previous, current) => {
      const currentParams = current.split("=");
      const key = sanitizeParams(currentParams?.[0] ?? "");
      const value2 = currentParams?.[1];
      return key && key.length > 0 ? { ...previous, [key]: value2 } : previous;
    }, {});
  };
  var convertObjectParamsToString = (params) => {
    return params && Object.entries(params).reduce((previous, [key, value], index) => {
      const currentJoin = index === 0 ? "" : "&";
      return `${previous}${currentJoin}${key}=${value}`;
    }, "");
  };
  var hashHandler = async () => {
    const historyObejct = { time: modules_exports.getTime(), scrollY: window.scrollY };
    const originalHash = globalThis.location.hash.slice(1);
    const { routeIsLoading } = mainStore.get();
    if (routeIsLoading) {
      history.replaceState(
        { nextId: historyObejct },
        "",
        `#${previousHash}${previousParamsToPush}`
      );
      return;
    }
    const { route: currentRoute, isRedirect } = tryRedirect({
      route: originalHash
    });
    if (isRedirect) {
      history.replaceState({ nextId: historyObejct }, "", `#${currentRoute}`);
    }
    const parts = currentRoute.split("?");
    const search = sanitizeParams(parts?.[1] ?? "");
    const hash = sanitizeHash(parts?.[0] ?? "");
    const params = getParams(currentStringParams ?? search);
    const paramsToPush = currentStringParams || Object.keys(search).length > 0 ? `?${currentStringParams ?? search}` : "";
    if (!currentHistory)
      history.replaceState(
        { nextId: historyObejct },
        "",
        `#${hash}${paramsToPush}`
      );
    currentStringParams = void 0;
    previousHash = hash;
    previousParamsToPush = paramsToPush;
    if (!currentHistory) {
      setHistoryBack(historyObejct);
    }
    if (currentHistory && historyDirection === HISTORY_BACK) {
      setHistoryNext(historyObejct);
    }
    if (currentHistory && historyDirection === HISTORY_NEXT) {
      setHistoryBack(getLastHistoryNext());
    }
    await loadRoute({
      route: getRouteModule({ url: hash }),
      templateName: getTemplateName({
        url: hash && hash.length > 0 ? hash : getIndex()
      }),
      restoreScroll: getRestoreScrollVale({ url: hash }),
      params,
      scrollY: currentHistory ? getLastHistory(historyDirection)?.scrollY ?? 0 : 0,
      skipTransition: currentHistory ?? currentSkipTransition ? true : false
    });
    currentSkipTransition = void 0;
  };
  var router = () => {
    hashHandler();
    globalThis.addEventListener("popstate", (event) => {
      currentHistory = event?.state?.nextId;
      if (currentHistory && !previousHistory && historyBackSize() > 0) {
        previousHistory = currentHistory;
        historyDirection = HISTORY_BACK;
        return;
      }
      if (currentHistory && previousHistory && previousHistory?.time > currentHistory?.time && historyBackSize() > 0) {
        previousHistory = currentHistory;
        historyDirection = HISTORY_BACK;
        return;
      }
      if (currentHistory && previousHistory && previousHistory?.time < currentHistory?.time) {
        previousHistory = currentHistory;
        historyDirection = HISTORY_NEXT;
        return;
      }
      previousHistory = void 0;
      historyDirection = "";
      resetNext();
    });
    globalThis.addEventListener("hashchange", () => {
      hashHandler();
    });
  };
  var loadUrl = ({ url, params, skipTransition }) => {
    if (!url) return;
    currentSkipTransition = skipTransition;
    const parts = url.split("?");
    const hash = sanitizeHash(parts?.[0] ?? "");
    const objectParams = convertObjectParamsToString(params);
    const stringParams = sanitizeParams(parts?.[1] ?? "");
    const urlsParams = objectParams ?? stringParams;
    if (urlsParams.length > 0) currentStringParams = urlsParams;
    globalThis.location.hash = hash;
    if (hash === previousHash || previousHash === "") {
      globalThis.dispatchEvent(new HashChangeEvent("hashchange"));
    }
  };

  // src/js/mob/mob-js/initialize-app/index.js
  var inizializeApp = async ({
    rootId,
    wrapper: wrapper2,
    contentId,
    routes: routes2 = [],
    afterInit = () => {
    },
    redirect = ({ route }) => route,
    index = "home",
    pageNotFound: pageNotFound3 = "pageNotFound",
    beforePageTransition: beforePageTransition3,
    pageTransition: pageTransition3,
    restoreScroll: restoreScroll2 = true,
    componentDefaultProps = {
      scoped: false,
      maxParseIteration: 1e4,
      debug: false
    }
  }) => {
    setDefaultComponent(componentDefaultProps);
    const rootEl = (
      /** @type {HTMLElement} */
      document.querySelector(rootId)
    );
    const wrapperDOM = await wrapper2();
    setRedirectFunction(redirect);
    if (!contentId || !rootEl) return;
    setContentId({ contentId });
    setRoot({ element: rootEl });
    setPageTransition({ fn: pageTransition3 });
    setBeforePageTransition({ fn: beforePageTransition3 });
    setRestoreScroll(restoreScroll2);
    initParseWatcher();
    setComponentList();
    setRouteList(routes2);
    setIndex({ routeName: index });
    setPageNotFound({ routeName: pageNotFound3 });
    rootEl.insertAdjacentHTML("afterbegin", wrapperDOM);
    setContentElement();
    await parseComponents({ element: rootEl, persistent: true });
    modules_exports.useFrameIndex(() => {
      modules_exports.useNextTick(() => {
        afterInit();
      });
    }, frameDelayAfterParse);
    router();
  };

  // src/js/mob/mob-js/modules/invalidate/action/get-number-of-active-invalidate.js
  var getNumberOfActiveInvalidate = () => invalidateIdPlaceHolderMap.size;

  // src/js/mob/mob-js/modules/repeater/action/get-number-of-active-repeater.js
  var getNumberOfActiveRepeater = () => {
    return repeatIdPlaceHolderMap.size;
  };

  // src/js/mob/mob-motion/core.js
  var core_exports = {};
  __export(core_exports, {
    clamp: () => clamp3,
    getDefault: () => getDefault,
    mq: () => mq2,
    printDefault: () => printDefault,
    setDefault: () => setDefault
  });

  // src/js/mob/mob-motion/animation/spring/spring-config.js
  var springPresetConfig = {
    default: {
      tension: 20,
      mass: 1,
      friction: 5,
      velocity: 0,
      precision: 0.01
    },
    gentle: {
      tension: 120,
      mass: 1,
      friction: 14,
      velocity: 0,
      precision: 0.01
    },
    wobbly: {
      tension: 180,
      mass: 1,
      friction: 12,
      velocity: 0,
      precision: 0.01
    },
    bounce: {
      tension: 200,
      mass: 3,
      friction: 5,
      velocity: 0,
      precision: 0.01
    },
    scroller: {
      tension: 10,
      mass: 1,
      friction: 5,
      velocity: 0,
      precision: 0.5
    }
  };

  // src/js/mob/mob-motion/animation/utils/set-up/set-up-validation.js
  var easeReference = {
    easeLinear: "easeLinear",
    easeInQuad: "easeInQuad",
    easeOutQuad: "easeOutQuad",
    easeInOutQuad: "easeInOutQuad",
    easeInCubic: "easeInCubic",
    easeOutCubic: "easeOutCubic",
    easeInOutCubic: "easeInOutCubic",
    easeInQuart: "easeInQuart",
    easeOutQuart: "easeOutQuart",
    easeInOutQuart: "easeInOutQuart",
    easeInQuint: "easeInQuint",
    easeOutQuint: "easeOutQuint",
    easeInOutQuint: "easeInOutQuint",
    easeInSine: "easeInSine",
    easeOutSine: "easeOutSine",
    easeInOutSine: "easeInOutSine",
    easeInExpo: "easeInExpo",
    easeOutExpo: "easeOutExpo",
    easeInOutExpo: "easeInOutExpo",
    easeInCirc: "easeInCirc",
    easeOutCirc: "easeOutCirc",
    easeInOutCirc: "easeInOutCirc",
    easeInElastic: "easeInElastic",
    easeOutElastic: "easeOutElastic",
    easeInOutElastic: "easeInOutElastic",
    easeInBack: "easeInBack",
    easeOutBack: "easeOutBack",
    easeInOutBack: "easeInOutBack",
    easeInBounce: "easeInBounce",
    easeOutBounce: "easeOutBounce",
    easeInOutBounce: "easeInOutBounce"
  };
  var MQ_MIN = "min";
  var MQ_MAX = "max";
  var defaultMqValueDefault = "desktop";
  var easeDefault = "easeLinear";
  var springConfigDefault = "default";
  var mqDefault = {
    xSmall: 320,
    small: 360,
    medium: 600,
    tablet: 768,
    desktop: 992,
    large: 1200,
    xLarge: 1600,
    xxLarge: 1980
  };
  var sequencerDurationDefault = 10;
  var lerpConfigDefault = 0.06;
  var markerStartDefault = "#ff0000";
  var markerItemDefault = "#14df3b";
  var scrollerRangeDefault = 8;
  var scrollerTweenDurationDefault = 10;
  var tweenDurationDefault = 1e3;
  var tweenRealtiveDefault = false;
  var springRealtiveDefault = false;
  var lerpRelativeDefault = false;
  var lerpPrecisionDefault = 0.01;
  var lerpVelocityDefault = 0.06;
  var setupValidation = (obj) => {
    const deferredNextTick = checkSetUpType({
      prop: "deferredNextTick",
      value: obj?.deferredNextTick,
      defaultValue: modules_exports.store.getProp("deferredNextTick"),
      type: Boolean
    });
    const usePassive = checkSetUpType({
      prop: "usePassive",
      value: obj?.usePassive,
      defaultValue: modules_exports.store.getProp("usePassive"),
      type: Boolean
    });
    const throttle2 = checkSetUpType({
      prop: "throttle",
      value: obj?.throttle,
      defaultValue: modules_exports.store.getProp("throttle"),
      type: Number
    });
    const mq3 = checkSetUpMq(obj?.mq ?? {});
    const defaultMqValue = checkSetUpType({
      prop: "defaultMq.value",
      value: obj?.defaultMq?.value,
      defaultValue: defaultMqValueDefault,
      type: String
    });
    const defaultMqType = checkSetUpType({
      prop: "defaultMq.type",
      value: obj?.defaultMq?.type,
      defaultValue: MQ_MIN,
      type: String
    });
    const sequencerDuration = checkSetUpType({
      prop: "sequencer.duration",
      value: obj?.sequencer?.duration,
      defaultValue: sequencerDurationDefault,
      type: Number
    });
    const sequencerEase = checkSetUpEase(obj?.sequencer?.ease, "sequencer");
    const scrollTriggerSpringConfig = checkSetUpType({
      prop: "scrolTrigger.springConfig",
      value: obj?.scrollTrigger?.springConfig,
      defaultValue: springConfigDefault,
      type: String
    });
    const scrollTriggerLerpConfig = checkSetUpType({
      prop: "scrolTrigger.lerpConfig",
      value: obj?.scrollTrigger?.lerpConfig,
      defaultValue: lerpConfigDefault,
      type: Number
    });
    const scrollTriggerMarkerEnd = checkSetUpType({
      prop: "scrolTrigger.markerColor.startEnd",
      value: obj?.scrollTrigger?.markerColor?.startEnd,
      defaultValue: markerStartDefault,
      type: String
    });
    const scrollTriggerMarkerItem = checkSetUpType({
      prop: "scrolTrigger.markerColor.item",
      value: obj?.scrollTrigger?.markerColor?.item,
      defaultValue: markerItemDefault,
      type: String
    });
    const scrollerRange = checkSetUpType({
      prop: "parallax.defaultRange",
      value: obj?.parallax?.defaultRange,
      defaultValue: scrollerRangeDefault,
      type: Number
    });
    const scrollerSpringConfig = checkSetUpType({
      prop: "parallax.springConfig",
      value: obj?.parallax?.springConfig,
      defaultValue: springConfigDefault,
      type: String
    });
    const scrollerLerpConfig = checkSetUpType({
      prop: "parallax.lerpConfig",
      value: obj?.parallax?.lerpConfig,
      defaultValue: lerpConfigDefault,
      type: Number
    });
    const scrollerTweenDuration = checkSetUpType({
      prop: "parallaxTween.duration",
      value: obj?.parallaxTween?.duration,
      defaultValue: scrollerTweenDurationDefault,
      type: Number
    });
    const scrollerTweenEase = checkSetUpEase(
      obj?.parallaxTween?.ease,
      "parallaxTween"
    );
    const tweenDuration = checkSetUpType({
      prop: "tween.duration",
      value: obj?.tween?.duration,
      defaultValue: tweenDurationDefault,
      type: Number
    });
    const tweenEase = checkSetUpEase(obj?.tween?.ease, "tween");
    const tweenRelative = checkSetUpType({
      prop: "tween.relative",
      value: obj?.tween?.relative,
      defaultValue: tweenRealtiveDefault,
      type: Boolean
    });
    const springRelative = checkSetUpType({
      prop: "spring.relative",
      value: obj?.spring?.relative,
      defaultValue: springRealtiveDefault,
      type: Boolean
    });
    const lerpRelative = checkSetUpType({
      prop: "lerp.relative",
      value: obj?.lerp?.relative,
      defaultValue: lerpRelativeDefault,
      type: Boolean
    });
    const lerpPrecision = checkSetUpType({
      prop: "lerp.precision",
      value: obj?.lerp?.precision,
      defaultValue: lerpPrecisionDefault,
      type: Number
    });
    const lerpVelocity = checkSetUpType({
      prop: "lerp.velocity",
      value: obj?.lerp?.velocity,
      defaultValue: lerpVelocityDefault,
      type: Number
    });
    const result = {
      deferredNextTick,
      throttle: throttle2,
      usePassive,
      mq: mq3,
      defaultMq: {
        value: defaultMqValue,
        type: defaultMqType
      },
      sequencer: {
        duration: sequencerDuration,
        // @ts-ignore
        ease: sequencerEase
      },
      scrollTrigger: {
        springConfig: scrollTriggerSpringConfig,
        lerpConfig: scrollTriggerLerpConfig,
        markerColor: {
          startEnd: scrollTriggerMarkerEnd,
          item: scrollTriggerMarkerItem
        }
      },
      parallax: {
        defaultRange: scrollerRange,
        springConfig: scrollerSpringConfig,
        lerpConfig: scrollerLerpConfig
      },
      parallaxTween: {
        duration: scrollerTweenDuration,
        // @ts-ignore
        ease: scrollerTweenEase
      },
      tween: {
        duration: tweenDuration,
        // @ts-ignore
        ease: tweenEase,
        relative: tweenRelative
      },
      spring: {
        relative: springRelative,
        config: obj?.spring?.config ? { ...springPresetConfig, ...obj.spring.config } : springPresetConfig
      },
      lerp: {
        relative: lerpRelative,
        precision: lerpPrecision,
        velocity: lerpVelocity
      }
    };
    return result;
  };
  var checkSetUpType = ({ prop, value, defaultValue, type }) => {
    const isValid = modules_exports.checkType(type, value);
    if (!isValid)
      console.warn(
        `handleSetUp error: ${prop}: ${value}, is not valid must be a ${modules_exports.getTypeName(
          type
        )}`
      );
    return isValid ? value : defaultValue;
  };
  var checkSetUpMq = (obj) => {
    const isValid = modules_exports.checkType(Object, obj) && Object.values(obj).every((value) => {
      return modules_exports.checkType(Number, value);
    });
    if (!isValid)
      console.warn(
        `handleSetUp error: mq must be an object as { ..., String: Number }`
      );
    return isValid ? obj : mqDefault;
  };
  var checkSetUpEase = (value, label) => {
    const isValid = Object.keys(easeReference).includes(value);
    if (!isValid && value !== void 0 && value !== null)
      console.warn(
        `handleSetUp error: ${label}.ease properties is not valid`
      );
    return isValid ? value : easeDefault;
  };

  // src/js/mob/mob-motion/utils/merge-deep.js
  var mergeDeep = (target, source, isMergingArrays = true) => {
    target = ((obj) => {
      let cloneObj;
      try {
        cloneObj = JSON.parse(JSON.stringify(obj));
      } catch {
        cloneObj = Object.assign({}, obj);
      }
      return cloneObj;
    })(target);
    const isObject = (obj) => obj && typeof obj === "object";
    if (!isObject(target) || !isObject(source)) return source;
    Object.keys(source).forEach((key) => {
      const targetValue = target[key];
      const sourceValue = source[key];
      if (Array.isArray(targetValue) && Array.isArray(sourceValue))
        if (isMergingArrays) {
          target[key] = targetValue.map(
            (x, i) => sourceValue.length <= i ? x : mergeDeep(x, sourceValue[i], isMergingArrays)
          );
          if (sourceValue.length > targetValue.length)
            target[key] = target[key].concat(
              sourceValue.slice(targetValue.length)
            );
        } else {
          target[key] = targetValue.concat(sourceValue);
        }
      else if (isObject(targetValue) && isObject(sourceValue))
        target[key] = mergeDeep(
          Object.assign({}, targetValue),
          sourceValue,
          isMergingArrays
        );
      else target[key] = sourceValue;
    });
    return target;
  };

  // src/js/mob/mob-motion/setup.js
  function getData() {
    return {
      deferredNextTick: modules_exports.store.getProp("deferredNextTick"),
      throttle: modules_exports.store.getProp("throttle"),
      usePassive: modules_exports.store.getProp("usePassive"),
      mq: mqDefault,
      defaultMq: {
        value: defaultMqValueDefault,
        type: MQ_MIN
      },
      sequencer: {
        duration: sequencerDurationDefault,
        ease: easeDefault
      },
      scrollTrigger: {
        springConfig: springConfigDefault,
        lerpConfig: lerpConfigDefault,
        markerColor: {
          startEnd: markerStartDefault,
          item: markerItemDefault
        }
      },
      parallax: {
        defaultRange: scrollerRangeDefault,
        springConfig: springConfigDefault,
        lerpConfig: lerpConfigDefault
      },
      parallaxTween: {
        duration: scrollerTweenDurationDefault,
        ease: easeDefault
      },
      tween: {
        duration: tweenDurationDefault,
        ease: easeDefault,
        relative: tweenRealtiveDefault
      },
      spring: {
        relative: false,
        config: springPresetConfig
      },
      lerp: {
        relative: false,
        precision: 0.01,
        velocity: 0.06
      }
    };
  }
  var handleSetUp = (() => {
    let data = getData();
    const set = (obj) => {
      data = setupValidation(mergeDeep(getData(), obj));
      if ("usePassive" in obj)
        modules_exports.store.set("usePassive", data.usePassive);
      if ("deferredNextTick" in obj)
        modules_exports.store.set("deferredNextTick", data.deferredNextTick);
      if ("throttle" in obj) modules_exports.store.set("throttle", data.throttle);
    };
    const get3 = (prop) => {
      if (!(prop in data)) {
        console.warn(`handleSetUp: ${prop} is not a setup propierties`);
      }
      return data[prop];
    };
    const print = () => {
      console.log(`Writable props:`);
      console.log(data);
    };
    return {
      set,
      get: get3,
      print
    };
  })();

  // src/js/mob/mob-motion/utils/media-manager.js
  var max = (breakpoint = "desktop") => {
    return window.innerWidth < handleSetUp.get("mq")[breakpoint];
  };
  var min = (breakpoint = "desktop") => {
    return window.innerWidth >= handleSetUp.get("mq")[breakpoint];
  };
  var getBreackpoint = (breakpoint = "desktop") => {
    return handleSetUp.get("mq")[breakpoint];
  };
  var mq = /* @__PURE__ */ (() => {
    return { max, min, getBreackpoint };
  })();

  // src/js/mob/mob-motion/animation/utils/animation-utils.js
  var getRoundedValue = (x) => {
    if (modules_exports.checkType(Number, x)) {
      return Math.round(x * 1e4) / 1e4 || 0;
    }
    if (Math.abs(x) < 1) {
      const e = Number.parseInt(x.toString().split("e-")[1]);
      if (e) {
        x *= Math.pow(10, e - 1);
        x = "0." + Array.from({ length: e }).join("0") + x.toString().slice(2);
      }
    } else {
      let e = Number.parseInt(x.toString().split("+")[1]);
      if (e > 20) {
        e -= 20;
        x /= Math.pow(10, e);
        x += Array.from({ length: e + 1 }).join("0");
      }
    }
    return Number.parseFloat(Number.parseFloat(x).toFixed(4));
  };
  var clamp3 = (num, min2, max2) => {
    return Math.min(Math.max(num, min2), max2);
  };
  var lerp = (start, end, amt) => {
    return (1 - amt) * start + amt * end;
  };
  var compareKeys = (a, b) => {
    const aKeys = Object.keys(a).sort();
    const bKeys = Object.keys(b).sort();
    return aKeys.length === bKeys.length && aKeys.every((element, index) => element === bKeys[index]);
  };
  var sliceIntoChunks = (arr, chunkSize) => {
    const res = [];
    for (let i = 0; i < arr.length; i += chunkSize) {
      const chunk = arr.slice(i, i + chunkSize);
      res.push(chunk);
    }
    return res;
  };
  var arrayColumn = (arr, n) => arr.map((x) => x[n]);

  // src/js/mob/mob-motion/core.js
  function setDefault(props) {
    handleSetUp.set(props);
  }
  function getDefault(prop) {
    return handleSetUp.get(prop);
  }
  function printDefault() {
    handleSetUp.print();
  }
  function mq2(action2, breakpoint) {
    switch (action2) {
      case "min": {
        return mq["min"](breakpoint);
      }
      case "max": {
        return mq["max"](breakpoint);
      }
      case "get": {
        return mq["getBreackpoint"](breakpoint);
      }
    }
  }

  // src/js/mob/mob-motion/tween.js
  var tween_exports = {};
  __export(tween_exports, {
    createLerp: () => createLerp,
    createMasterSequencer: () => createMasterSequencer,
    createScrollerTween: () => createScrollerTween,
    createSequencer: () => createSequencer,
    createSpring: () => createSpring,
    createStaggers: () => createStaggers,
    createTimeTween: () => createTimeTween
  });

  // src/js/mob/mob-motion/animation/utils/tween-action/set-values.js
  var setFromByCurrent = (arr) => {
    return arr.map((item) => {
      if (!item.settled) {
        item.fromValue = item.currentValue;
      }
      return item;
    });
  };
  var setFromCurrentByTo = (arr) => {
    return arr.map((item) => {
      item.fromValue = item.toValue;
      item.currentValue = item.toValue;
      return item;
    });
  };
  var setFromToByCurrent = (arr) => {
    return arr.map((item) => {
      item.toValue = item.currentValue;
      item.fromValue = item.currentValue;
      return item;
    });
  };
  var setReverseValues = (obj, arr) => {
    const keysTorevert = Object.keys(obj);
    return arr.map((item) => {
      if (keysTorevert.includes(item["prop"])) {
        const fromValue = item.fromValue;
        const toValue = item.toValue;
        item.fromValue = toValue;
        item.toValue = fromValue;
      }
      return item;
    });
  };
  var setRelative = (arr, relative) => {
    return arr.map((item) => {
      item.toValue = relative ? item.toValue + item.currentValue : item.toValue;
      return item;
    });
  };
  var tweenSmallNumber = 1e-5;
  var setRelativeTween = (arr, relative) => {
    return arr.map((item) => {
      if (item.shouldUpdate) {
        item.toValProcessed = relative ? item.toValue + tweenSmallNumber : item.toValue - item.fromValue + tweenSmallNumber;
      }
      return item;
    });
  };

  // src/js/mob/mob-motion/animation/utils/stagger/stagger-costant.js
  var DIRECTION_ROW = "row";
  var DIRECTION_COL = "col";
  var DIRECTION_RADIAL = "radial";
  var STAGGER_START = "start";
  var STAGGER_END = "end";
  var STAGGER_CENTER = "center";
  var STAGGER_EDGES = "edges";
  var STAGGER_RANDOM = "random";
  var MERGE_FROM_UP = "MERGE_FROM_UP";
  var MERGE_FROM_DOWN = "MERGE_FROM_DOWN";
  var STAGGER_TYPE_EQUAL = "equal";
  var STAGGER_TYPE_START = "start";
  var STAGGER_TYPE_END = "end";
  var STAGGER_TYPE_CENTER = "center";
  var STAGGER_DEFAULT_OBJ = {
    type: STAGGER_TYPE_EQUAL,
    each: 0,
    waitComplete: false,
    from: STAGGER_START,
    grid: {
      col: 1,
      row: 1,
      direction: DIRECTION_COL
    }
  };
  var STAGGER_DEFAULT_INDEX_OBJ = {
    index: 0,
    frame: 0
  };

  // src/js/mob/mob-motion/animation/scroller/mob-scroller-constant.js
  var MobScrollerConstant = {
    // Constant misure units
    /**
     * @type {string}
     */
    PX: "px",
    /**
     * @type {string}
     */
    VH: "vh",
    /**
     * @type {string}
     */
    VW: "vw",
    /**
     * @type {string}
     */
    WPERCENT: "w",
    /**
     * @type {string}
     */
    HPERCENT: "h",
    /**
     * @type {string}
     */
    DEGREE: "deg",
    // AdditionalChoiceContant
    /**
     * @type {string}
     */
    PLUS_HEIGHT: "+height",
    /**
     * @type {string}
     */
    PLUS_HEIGHT_HALF: "+halfHeight",
    /**
     * @type {string}
     */
    PLUS_WIDTH: "+width",
    /**
     * @type {string}
     */
    PLUS_WIDTH_HALF: "+halfWidth",
    /**
     * @type {string}
     */
    MINUS_HEIGHT: "-height",
    /**
     * @type {string}
     */
    MINUS_HEIGHT_HALF: "-halfHeight",
    /**
     * @type {string}
     */
    MINUS_WIDTH: "-width",
    /**
     * @type {string}
     */
    MINUS_WIDTH_HALF: "-halfWidth",
    // End Start position Constant
    /**
     * @type {string}
     */
    POSITION_BOTTOM: "bottom",
    /**
     * @type {string}
     */
    POSITION_TOP: "top",
    /**
     * @type {string}
     */
    POSITION_LEFT: "left",
    /**
     * @type {string}
     */
    POSITION_RIGHT: "right",
    // Constant direction
    /**
     * @type {string}
     */
    DIRECTION_VERTICAL: "vertical",
    /**
     * @type {string}
     */
    DIRECTION_HORIZONTAL: "horizontal",
    // Constant computation type
    /**
     * @type {string}
     */
    TYPE_PARALLAX: "parallax",
    /**
     * @type {string}
     */
    TYPE_SCROLLTRIGGER: "scrolltrigger",
    // Constant propierties
    /**
     * @type {string}
     */
    PROP_VERTICAL: "y",
    /**
     * @type {string}
     */
    PROP_HORIZONTAL: "x",
    /**
     * @type {string}
     */
    PROP_ROTATE: "rotate",
    /**
     * @type {string}
     */
    PROP_ROTATEY: "rotateY",
    /**
     * @type {string}
     */
    PROP_ROTATEX: "rotateX",
    /**
     * @type {string}
     */
    PROP_ROTATEZ: "rotateZ",
    /**
     * @type {string}
     */
    PROP_OPACITY: "opacity",
    /**
     * @type {string}
     */
    PROP_SCALE: "scale",
    /**
     * @type {string}
     */
    PROP_SCALE_X: "scaleX",
    /**
     * @type {string}
     */
    PROP_SCALE_Y: "scaleY",
    /**
     * @type {string}
     */
    PROP_TWEEN: "tween",
    /**
     * @type {string}
     */
    TWEEN_TWEEN: "parallaxTween",
    /**
     * @type {string}
     */
    TWEEN_TIMELINE: "sequencer",
    // Align constant
    /**
     * @type {string}
     */
    ALIGN_START: "start",
    /**
     * @type {string}
     */
    ALIGN_TOP: "top",
    /**
     * @type {string}
     */
    ALIGN_RIGHT: "right",
    /**
     * @type {string}
     */
    ALIGN_CENTER: "center",
    /**
     * @type {string}
     */
    ALIGN_BOTTOM: "bottom",
    /**
     * @type {string}
     */
    ALIGN_LEFT: "left",
    /**
     * @type {string}
     */
    ALIGN_END: "end",
    // Switch constant
    /**
     * @type {string}
     */
    IN_STOP: "in-stop",
    /**
     * @type {string}
     */
    IN_BACK: "in-back",
    /**
     * @type {string}
     */
    OUT_STOP: "out-stop",
    /**
     * @type {string}
     */
    OUT_BACK: "out-back",
    // Ease type constant
    /**
     * @type {string}
     */
    EASE_SPRING: "spring",
    /**
     * @type {string}
     */
    EASE_LERP: "lerp",
    /**
     * @type {number}
     */
    EASE_PRECISION: 1e-3,
    /**
     * @type {string}
     */
    SCROLL_UP: "up",
    /**
     * @type {string}
     */
    SCROLL_DOWN: "down",
    /**
     * @type {string}
     */
    ON_LEAVE: "ON_LEAVE",
    /**
     * @type {string}
     */
    ON_LEAVE_BACK: "ON_LEAVE_BACK",
    /**
     * @type {string}
     */
    ON_ENTER: "ON_ENTER",
    /**
     * @type {string}
     */
    ON_ENTER_BACK: "ON_ENTER_BACK",
    /**
     * @type {string}
     */
    ON_NOOP: "ON_NOOP"
  };

  // src/js/mob/mob-motion/animation/utils/warning.js
  var possibleChoice = (choice) => {
    return choice.map((item) => {
      return `${item} | `;
    }).join("");
  };
  var compareKeysWarning = (label, fromObj, toObj) => {
    console.warn(
      `${label}: ${JSON.stringify(fromObj)} and to ${JSON.stringify(
        toObj
      )} is not equal`
    );
  };
  var staggerIsOutOfRangeWarning = (max2) => {
    console.warn(
      `stagger col of grid is out of range, it must be less than ${max2} ( staggers length )`
    );
  };
  var dataTweenValueIsNotValidWarning = (label) => {
    console.warn(
      `tween | sequencer: ${label} is not valid value, must be a number or a Function that return a number`
    );
  };
  var sequencerRangeStartWarning = (val2) => {
    console.warn(
      `sequencer, start option: ${val2} value is not valid, must be a Number`
    );
  };
  var sequencerRangeEndWarning = (val2) => {
    console.warn(
      `sequencer, end option: ${val2} value is not valid, must be a Number`
    );
  };
  var relativePropInsideTimelineWarning = () => {
    console.warn("relative prop is not allowed inside a timeline");
  };
  var timelineSuspendWarning = (val2) => {
    console.warn(
      `Timeline Supend: ${val2()} is not a valid value, must be a boolean`
    );
  };
  var timelineReverseGoFromWarning = () => {
    console.warn(
      `SyncTimeline: in revese ( or yoyo mode) only goTo || goFromTo || set action is allowed. Using goFrom makes no sense in this context. Enable forceFromTo to use from action in reverse mode`
    );
  };
  var timelineSetTweenArrayWarining = (items) => {
    console.warn(`timeline setTween: ${items} is not an array of tween`);
  };
  var timelineSetTweenLabelWarining = (label) => {
    console.warn(`timeline setTween: ${label} is not a string`);
  };
  var timelineSetTweenLabelNotFoundWarining = (label) => {
    console.warn(`asyncTimeline.setTween() label: ${label} not found`);
  };
  var timelineSetTweenFailWarining = () => {
    console.warn("setTween fail");
  };
  var syncTimelineLabelWarning = (label) => {
    console.warn(`label ${label} not founded`);
  };
  var syncTimelineAddFnWarning = (fn) => {
    console.warn(`sequencer.add(fn,time) ${fn}: fn must be Function`);
  };
  var syncTimelineAddTimeWarning = (time2) => {
    console.warn(`sequencer.add(fn,time) ${time2}: time must be a Number`);
  };
  var springPresetWarning = (preset) => {
    console.warn(`${preset} doesn't exist in spring configuration list`);
  };
  var springConfigPropWarning = () => {
    console.warn(`Spring configProps: all prop must be a positive Number`);
  };
  var springConfigSpecificPropWarning = (config) => {
    console.warn(
      `Spring config: ${config}: config must have friction/mass/precision/tesnion props and must be a number`
    );
  };
  var tweenEaseWarning = (preset) => {
    console.warn(`${preset} doesn't exist in tweens ease function`);
  };
  var staggerEachWarning = () => {
    console.warn(`stagger each must be a Number `);
  };
  var staggerRowColGenericWarining = (val2) => {
    console.warn(
      `stagger, row/col: ${val2} value is not valid, must be a Number`
    );
  };
  var staggerWaitCompleteWarning = () => {
    console.warn("Stagger error: waitComplete propierties must be a Boolean");
  };
  var staggerGridDirectionWarning = () => {
    console.warn(
      `Stagger error: in grid option direction should be a string radial/col/row`
    );
  };
  var staggerColRowWarning = () => {
    console.warn(
      `Stagger error: in col/row direction 'from' propierties must be a string start/end/center/edges or a number`
    );
  };
  var staggerFromGenericWarning = (from) => {
    console.warn(
      `Stagger error: from: ${from} is not a valid value, must be a string start/end/center/edges or a number or a Object {x:Number,y:Number}`
    );
  };
  var durationWarining = (value) => {
    console.warn(
      `duration error: ${value} is not valid duration must be a number`
    );
  };
  var durationNumberOrFunctionWarining = (value) => {
    console.warn(
      `duration error: ${value} is not valid duration must be a number or a Function that return a number`
    );
  };
  var repeatWarining = (value) => {
    console.warn(
      `repeat error: ${value} is not valid repeat value must be a Number`
    );
  };
  var initialDataPropWarining = (prop) => {
    console.warn(
      `data inizializiation error; ${prop} is not a valid value, must be a string`
    );
  };
  var initialDataValueWarining = (value) => {
    console.warn(
      `data inizializiation error; ${value} is not a valid value, must be a number`
    );
  };
  var createStaggerItemsWarning = () => {
    console.warn(`createStaggers error: items array can not be empty`);
  };
  var createStaggerItemsTypeWarning = () => {
    console.warn(
      `createStaggers error: each element of the array must be an Element or an Object`
    );
  };
  var createStaggerTypeWarning = () => {
    console.warn(
      `screateStaggers error: type should be: ${STAGGER_TYPE_EQUAL} || ${STAGGER_START} || ${STAGGER_TYPE_END} || ${STAGGER_TYPE_CENTER}`
    );
  };
  var createStaggerEachWarning = (eachProportion) => {
    console.warn(
      `createStagger:  each must be between 1 and ${eachProportion}`
    );
  };
  var relativeWarining = (val2, tweenType) => {
    console.warn(
      `${tweenType}: relative prop: ${val2} is not a valid parameter, must be a boolean `
    );
  };
  var booleanWarning = (val2, label) => {
    console.warn(`${label}: '${val2}' is not Boolean`);
  };
  var stringWarning = (val2, label) => {
    console.warn(`${label}: '${val2}' is not String`);
  };
  var naumberWarning = (val2, label) => {
    console.warn(`${label}: '${val2}' is not Number`);
  };
  var functionWarning = (val2, label) => {
    console.warn(`${label}: '${val2}' is not Function`);
  };
  var lerpVelocityWarining = () => {
    console.warn(
      "Lerp error: velocity is not valid, must be a Number greater than 0 and less than 1"
    );
  };
  var lerpPrecisionWarining = () => {
    console.warn(
      "Lerp error: precision is not valid, must be a number greater than 0"
    );
  };
  var asyncTimelineMetodsInsideGroupWarining = (methodName) => {
    console.warn(
      `asyncTimeline error: ${methodName} cannot be used inside group`
    );
  };
  var valueStringWarning = (label) => {
    console.warn(`${label} value must be a string`);
  };
  var asyncTimelineTweenWaring = () => {
    console.warn(
      "tween added to asyncTimeline or used inside sync() method must be instance of HandleLerp | HandleTween | HandleSpring"
    );
  };
  var asyncTimelineDelayWarning = () => {
    console.warn("asyncTimeline arror: delay must be a Number");
  };
  var playLabelWarining = (label) => {
    console.warn(`${label} not found`);
  };
  var addAsyncFunctionWarining = (value) => {
    console.warn(`timeline add async function, ${value} is not a function `);
  };
  var scrollerDirectionWarining = (value, component) => {
    console.warn(
      `${component} direction: ${value} is not valid value: must be ${MobScrollerConstant.DIRECTION_VERTICAL} | ${MobScrollerConstant.DIRECTION_HORIZONTAL}`
    );
  };
  var scrollerDynmicValueWarining = (label) => {
    console.warn(
      `scrollTrigger error; ${label} propierties: value must be a Object like { position: top|bottom|left|right, value: () => { return Number} } `
    );
  };
  var scrollerDynmicRangeValueWarining = () => {
    console.warn(
      `scrollTrigger error; dynamicRange propierties: value must be a Function that return a Number`
    );
  };
  var scrollerTweenWarning = () => {
    console.warn(
      "parallax|scrolTrigger error: tween is not valid, must be an instance of HandleSequencer || ParallaxTween"
    );
  };
  var scrollerAlignWarining = (value, choice) => {
    console.warn(
      `parallax error align propierties: ${value} is not valid must be one of ${possibleChoice(
        choice
      )} or a Number between 0 and 100`
    );
  };
  var scrollerOnSwitchWarining = (value, choice) => {
    console.warn(
      `parallax error align propierties: ${value} is not valid must be one of ${possibleChoice(
        choice
      )}`
    );
  };
  var scrollerOpacityWarning = (val2, label) => {
    console.warn(
      `${label}: '${val2}' is not Number, must be a number between 0 and 100`
    );
  };
  var scrollerTypeWarining = (value, choice) => {
    console.warn(
      `parallax error type propierties: ${value} is not valid must be one of ${possibleChoice(
        choice
      )}`
    );
  };
  var scrollerPropiertiesWarining = (value, choice) => {
    console.warn(
      `parallax/scrollTrigger error propierties props: ${value} is not valid must be one of ${possibleChoice(
        choice
      )} or a custom css propierites like margin|line-height|...`
    );
  };
  var scrollerEaseTypeWarining = (value, choice) => {
    console.warn(
      `parallax error easeType props: ${value} is not valid must be one of ${possibleChoice(
        choice
      )}`
    );
  };
  var genericEaseTypeWarining = (value, choice, component) => {
    console.warn(
      `${component} error easeType props: ${value} is not valid must be one of ${possibleChoice(
        choice
      )}`
    );
  };
  var scrollerEaseTypeSpringWarining = () => {
    console.warn(
      'Scrolltrigger warning: spring animation is only available for native properties and scrollerTween, Check that with the "propierties" property set to "tween" no HandleSequencer is associated with the "tween" property'
    );
  };
  var scrollerSpringCongifWarining = (value, choice) => {
    console.warn(
      `parallax/scrollTrigger error springConfig props: ${value} is not valid must be one of ${possibleChoice(
        choice
      )}`
    );
  };
  var scrollerRangeNumberWarning = (value) => {
    console.warn(
      `parallax error range propierties, current value: ${value}, the value must be a number between 0 and 9.99`
    );
  };
  var scrollerRangeStringWarning = (value) => {
    console.warn(
      `scrollTrigger error range propierties: ${value} is not a String`
    );
  };
  var breakpointWarning = (mq3, choice, label, component) => {
    console.warn(
      `${component} error ${label} propierties: ${mq3} is not valid must be one of ${possibleChoice(
        choice
      )}`
    );
  };
  var scrollerUseSequencerWarining = () => {
    console.warn(
      "Parallax warning: if propierties is a tween the only choice is ParallaxTween, HandleSequencer or empty tween propierites is not allowed inside a parallax"
    );
  };
  var scrollerLerpConfigWarning = () => {
    console.warn(
      "parallax/ScrollTrrigger error: velocity is not valid, must be a Number greater than 0 and less than 1"
    );
  };
  var scrollerNoTweenDefinedWarning = () => {
    console.warn(
      'parallax/ScrollTrrigger warning:  The property is "tween" but no tween has been associated, associate a tween with the "tween" property'
    );
  };
  var scrollerUseTweenButNotProsDefinedWarning = () => {
    console.warn(
      'parallax/ScrollTrrigger: there is tween associated but pros "propierties" is not set to "tween"'
    );
  };
  var functionIsValidAndReturnDefaultWarining = (label, value) => {
    console.warn(`${label}: ${value} is not a function`);
  };
  var scrollTriggerRangeWarning = (string, properties, choice) => {
    console.warn(
      `scrollTrigger error range : with '${properties}' propierties ${string} is not valid, add one of the following unit misure: ${possibleChoice(
        choice
      )}, es: 45deg|100px|50vw etc..`
    );
  };
  var scrollTriggerCustomRangeWarning = (properties) => {
    console.warn(
      `scrollTrigger error range : with custom css propierties '${properties}' no unit misure is necessary, the default unit misure will be used (px). Only '-' for negative value is allowed`
    );
  };
  var scrollTriggerRangeScaleWarning = (string, properties) => {
    console.warn(
      `scrollTrigger error range : with '${properties}' propierties ${string} is not valid no unit misure is necessary. Only '-' for negative value is allowed`
    );
  };

  // src/js/mob/mob-motion/animation/tween/tween-config.js
  var tweenConfig = {
    [easeReference.easeLinear]: (elapsed, initialValue, amountOfChange, duration2) => {
      return amountOfChange * elapsed / duration2 + initialValue;
    },
    [easeReference.easeInQuad]: (elapsed, initialValue, amountOfChange, duration2) => {
      return amountOfChange * (elapsed /= duration2) * elapsed + initialValue;
    },
    [easeReference.easeOutQuad]: (elapsed, initialValue, amountOfChange, duration2) => {
      return -amountOfChange * (elapsed /= duration2) * (elapsed - 2) + initialValue;
    },
    [easeReference.easeInOutQuad]: (elapsed, initialValue, amountOfChange, duration2) => {
      if ((elapsed /= duration2 / 2) < 1) {
        return amountOfChange / 2 * elapsed * elapsed + initialValue;
      }
      return -amountOfChange / 2 * (--elapsed * (elapsed - 2) - 1) + initialValue;
    },
    [easeReference.easeInCubic]: (elapsed, initialValue, amountOfChange, duration2) => {
      return amountOfChange * (elapsed /= duration2) * elapsed * elapsed + initialValue;
    },
    [easeReference.easeOutCubic]: (elapsed, initialValue, amountOfChange, duration2) => {
      return amountOfChange * ((elapsed = elapsed / duration2 - 1) * elapsed * elapsed + 1) + initialValue;
    },
    [easeReference.easeInOutCubic]: (elapsed, initialValue, amountOfChange, duration2) => {
      if ((elapsed /= duration2 / 2) < 1) {
        return amountOfChange / 2 * elapsed * elapsed * elapsed + initialValue;
      }
      return amountOfChange / 2 * ((elapsed -= 2) * elapsed * elapsed + 2) + initialValue;
    },
    [easeReference.easeInQuart]: (elapsed, initialValue, amountOfChange, duration2) => {
      return amountOfChange * (elapsed /= duration2) * elapsed * elapsed * elapsed + initialValue;
    },
    [easeReference.easeOutQuart]: (elapsed, initialValue, amountOfChange, duration2) => {
      return -amountOfChange * ((elapsed = elapsed / duration2 - 1) * elapsed * elapsed * elapsed - 1) + initialValue;
    },
    [easeReference.easeInOutQuart]: (elapsed, initialValue, amountOfChange, duration2) => {
      if ((elapsed /= duration2 / 2) < 1) {
        return amountOfChange / 2 * elapsed * elapsed * elapsed * elapsed + initialValue;
      }
      return -amountOfChange / 2 * ((elapsed -= 2) * elapsed * elapsed * elapsed - 2) + initialValue;
    },
    [easeReference.easeInQuint]: (elapsed, initialValue, amountOfChange, duration2) => {
      return amountOfChange * (elapsed /= duration2) * elapsed * elapsed * elapsed * elapsed + initialValue;
    },
    [easeReference.easeOutQuint]: (elapsed, initialValue, amountOfChange, duration2) => {
      return amountOfChange * ((elapsed = elapsed / duration2 - 1) * elapsed * elapsed * elapsed * elapsed + 1) + initialValue;
    },
    [easeReference.easeInOutQuint]: (elapsed, initialValue, amountOfChange, duration2) => {
      if ((elapsed /= duration2 / 2) < 1) {
        return amountOfChange / 2 * elapsed * elapsed * elapsed * elapsed * elapsed + initialValue;
      }
      return amountOfChange / 2 * ((elapsed -= 2) * elapsed * elapsed * elapsed * elapsed + 2) + initialValue;
    },
    [easeReference.easeInSine]: (elapsed, initialValue, amountOfChange, duration2) => {
      return -amountOfChange * Math.cos(elapsed / duration2 * (Math.PI / 2)) + amountOfChange + initialValue;
    },
    [easeReference.easeOutSine]: (elapsed, initialValue, amountOfChange, duration2) => {
      return amountOfChange * Math.sin(elapsed / duration2 * (Math.PI / 2)) + initialValue;
    },
    [easeReference.easeInOutSine]: (elapsed, initialValue, amountOfChange, duration2) => {
      return -amountOfChange / 2 * (Math.cos(Math.PI * elapsed / duration2) - 1) + initialValue;
    },
    [easeReference.easeInExpo]: (elapsed, initialValue, amountOfChange, duration2) => {
      return elapsed === 0 ? initialValue : amountOfChange * Math.pow(2, 10 * (elapsed / duration2 - 1)) + initialValue;
    },
    [easeReference.easeOutExpo]: (elapsed, initialValue, amountOfChange, duration2) => {
      return elapsed === duration2 ? initialValue + amountOfChange : amountOfChange * (-Math.pow(2, -10 * elapsed / duration2) + 1) + initialValue;
    },
    [easeReference.easeInOutExpo]: (elapsed, initialValue, amountOfChange, duration2) => {
      if (elapsed === 0) {
        return initialValue;
      }
      if (elapsed === duration2) {
        return initialValue + amountOfChange;
      }
      if ((elapsed /= duration2 / 2) < 1) {
        return amountOfChange / 2 * Math.pow(2, 10 * (elapsed - 1)) + initialValue;
      }
      return amountOfChange / 2 * (-Math.pow(2, -10 * --elapsed) + 2) + initialValue;
    },
    [easeReference.easeInCirc]: (elapsed, initialValue, amountOfChange, duration2) => {
      return -amountOfChange * (Math.sqrt(1 - (elapsed /= duration2) * elapsed) - 1) + initialValue;
    },
    [easeReference.easeOutCirc]: (elapsed, initialValue, amountOfChange, duration2) => {
      return amountOfChange * Math.sqrt(1 - (elapsed = elapsed / duration2 - 1) * elapsed) + initialValue;
    },
    [easeReference.easeInOutCirc]: (elapsed, initialValue, amountOfChange, duration2) => {
      if ((elapsed /= duration2 / 2) < 1) {
        return -amountOfChange / 2 * (Math.sqrt(1 - elapsed * elapsed) - 1) + initialValue;
      }
      return amountOfChange / 2 * (Math.sqrt(1 - (elapsed -= 2) * elapsed) + 1) + initialValue;
    },
    [easeReference.easeInElastic]: (elapsed, initialValue, amountOfChange, duration2) => {
      let s = 1.70158;
      let p = 0;
      let a = amountOfChange;
      if (elapsed === 0) {
        return initialValue;
      }
      if ((elapsed /= duration2) === 1) {
        return initialValue + amountOfChange;
      }
      if (!p) {
        p = duration2 * 0.3;
      }
      if (a < Math.abs(amountOfChange)) {
        a = amountOfChange;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(amountOfChange / a);
      }
      return -(a * Math.pow(2, 10 * (elapsed -= 1)) * Math.sin((elapsed * duration2 - s) * (2 * Math.PI) / p)) + initialValue;
    },
    [easeReference.easeOutElastic]: (elapsed, initialValue, amountOfChange, duration2) => {
      let s = 1.70158;
      let p = 0;
      let a = amountOfChange;
      if (elapsed === 0) {
        return initialValue;
      }
      if ((elapsed /= duration2) === 1) {
        return initialValue + amountOfChange;
      }
      if (!p) {
        p = duration2 * 0.3;
      }
      if (a < Math.abs(amountOfChange)) {
        a = amountOfChange;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(amountOfChange / a);
      }
      return a * Math.pow(2, -10 * elapsed) * Math.sin((elapsed * duration2 - s) * (2 * Math.PI) / p) + amountOfChange + initialValue;
    },
    [easeReference.easeInOutElastic]: (elapsed, initialValue, amountOfChange, duration2) => {
      let s = 1.70158;
      let p = 0;
      let a = amountOfChange;
      if (elapsed === 0) {
        return initialValue;
      }
      if ((elapsed /= duration2 / 2) === 2) {
        return initialValue + amountOfChange;
      }
      if (!p) {
        p = duration2 * (0.3 * 1.5);
      }
      if (a < Math.abs(amountOfChange)) {
        a = amountOfChange;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(amountOfChange / a);
      }
      if (elapsed < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (elapsed -= 1)) * Math.sin(
          (elapsed * duration2 - s) * (2 * Math.PI) / p
        )) + initialValue;
      }
      return a * Math.pow(2, -10 * (elapsed -= 1)) * Math.sin((elapsed * duration2 - s) * (2 * Math.PI) / p) * 0.5 + amountOfChange + initialValue;
    },
    [easeReference.easeInBack]: (elapsed, initialValue, amountOfChange, duration2, s = 1.70158) => {
      return amountOfChange * (elapsed /= duration2) * elapsed * ((s + 1) * elapsed - s) + initialValue;
    },
    [easeReference.easeOutBack]: (elapsed, initialValue, amountOfChange, duration2, s = 1.70158) => {
      return amountOfChange * ((elapsed = elapsed / duration2 - 1) * elapsed * ((s + 1) * elapsed + s) + 1) + initialValue;
    },
    easeInOutBack: (elapsed, initialValue, amountOfChange, duration2, s = 1.70158) => {
      if ((elapsed /= duration2 / 2) < 1) {
        return amountOfChange / 2 * (elapsed * elapsed * (((s *= 1.525) + 1) * elapsed - s)) + initialValue;
      }
      return amountOfChange / 2 * ((elapsed -= 2) * elapsed * (((s *= 1.525) + 1) * elapsed + s) + 2) + initialValue;
    },
    [easeReference.easeInBounce]: (elapsed, initialValue, amountOfChange, duration2) => {
      return amountOfChange - tweenConfig[easeReference.easeOutBounce](
        duration2 - elapsed,
        0,
        amountOfChange,
        duration2
      ) + initialValue;
    },
    [easeReference.easeOutBounce]: (elapsed, initialValue, amountOfChange, duration2) => {
      if ((elapsed /= duration2) < 1 / 2.75) {
        return amountOfChange * (7.5625 * elapsed * elapsed) + initialValue;
      } else if (elapsed < 2 / 2.75) {
        return amountOfChange * (7.5625 * (elapsed -= 1.5 / 2.75) * elapsed + 0.75) + initialValue;
      } else if (elapsed < 2.5 / 2.75) {
        return amountOfChange * (7.5625 * (elapsed -= 2.25 / 2.75) * elapsed + 0.9375) + initialValue;
      } else {
        return amountOfChange * (7.5625 * (elapsed -= 2.625 / 2.75) * elapsed + 0.984375) + initialValue;
      }
    },
    [easeReference.easeInOutBounce]: (elapsed, initialValue, amountOfChange, duration2) => {
      if (elapsed < duration2 / 2) {
        return tweenConfig[easeReference.easeInBounce](
          elapsed * 2,
          0,
          amountOfChange,
          duration2
        ) * 0.5 + initialValue;
      }
      return tweenConfig[easeReference.easeOutBounce](
        elapsed * 2 - duration2,
        0,
        amountOfChange,
        duration2
      ) * 0.5 + amountOfChange * 0.5 + initialValue;
    }
  };
  var getTweenFn = (prop) => {
    if (prop in tweenConfig) {
      return tweenConfig[prop];
    } else {
      tweenEaseWarning(prop);
      return tweenConfig[handleSetUp.get("tween").ease];
    }
  };

  // src/js/mob/mob-motion/animation/utils/regex-validation.js
  var escapeRegExp = (text) => {
    return text ? text.replaceAll(/[\s#$()*+,.?[\\\]^{|}-]/g, String.raw`\$&`) : "";
  };
  var checkIfIsOnlyNumberPositiveNegative = (pattern) => {
    return /^[+-]?\d+(\.\d+)?$/.test(pattern);
  };
  var checkIfIsOnlyNumber = (pattern) => {
    return /^\d+\.\d+$|^\d+$/.test(pattern);
  };
  var exactMatchInsensitive = (string, pattern) => {
    const regex = new RegExp(`^${escapeRegExp(pattern)}$`, "i");
    const result = string.match(regex) || [];
    return result.length;
  };
  var exactMatchInsesitiveNumberProp = (string, pattern) => {
    const regex = new RegExp(`[0-9]${pattern}$`, "i");
    const result = string.match(regex) || [];
    return result.length;
  };
  var exactMatchInsesitiveNumberPropArray = (arr, string) => {
    return arr.some((unitMisure) => {
      const regex = new RegExp(`[0-9]${unitMisure}$`, "i");
      const result = string.match(regex) || [];
      return result.length;
    });
  };
  var exactMatchInsesitivePropArray = (arr, string) => {
    return arr.some((unitMisure) => {
      const regex = new RegExp(`^${escapeRegExp(unitMisure)}$`, "i");
      const result = string.match(regex) || [];
      return result.length;
    });
  };

  // src/js/mob/mob-motion/animation/scroller/get-constant-from-regex.js
  var getPropiertiesValueFromConstant = (value) => {
    if (!value) return value;
    if (exactMatchInsensitive(value, MobScrollerConstant.PROP_VERTICAL))
      return MobScrollerConstant.PROP_VERTICAL;
    if (exactMatchInsensitive(value, MobScrollerConstant.PROP_HORIZONTAL))
      return MobScrollerConstant.PROP_HORIZONTAL;
    if (exactMatchInsensitive(value, MobScrollerConstant.PROP_ROTATE))
      return MobScrollerConstant.PROP_ROTATE;
    if (exactMatchInsensitive(value, MobScrollerConstant.PROP_ROTATEY))
      return MobScrollerConstant.PROP_ROTATEY;
    if (exactMatchInsensitive(value, MobScrollerConstant.PROP_ROTATEX))
      return MobScrollerConstant.PROP_ROTATEX;
    if (exactMatchInsensitive(value, MobScrollerConstant.PROP_OPACITY))
      return MobScrollerConstant.PROP_OPACITY;
    if (exactMatchInsensitive(value, MobScrollerConstant.PROP_SCALE))
      return MobScrollerConstant.PROP_SCALE;
    if (exactMatchInsensitive(value, MobScrollerConstant.PROP_SCALE_X))
      return MobScrollerConstant.PROP_SCALE_X;
    if (exactMatchInsensitive(value, MobScrollerConstant.PROP_SCALE_Y))
      return MobScrollerConstant.PROP_SCALE_Y;
    if (exactMatchInsensitive(value, MobScrollerConstant.PROP_TWEEN))
      return MobScrollerConstant.PROP_TWEEN;
    return value;
  };
  var getStartEndUnitMisure = (pattern) => {
    if (pattern) {
      if (exactMatchInsesitiveNumberProp(pattern, MobScrollerConstant.PX))
        return MobScrollerConstant.PX;
      if (exactMatchInsesitiveNumberProp(pattern, MobScrollerConstant.VH))
        return MobScrollerConstant.VH;
      if (exactMatchInsesitiveNumberProp(pattern, MobScrollerConstant.VW))
        return MobScrollerConstant.VW;
    }
    return "";
  };
  var getScrollerPositionFromContanst = (position2) => {
    if (exactMatchInsensitive(position2, MobScrollerConstant.POSITION_TOP))
      return MobScrollerConstant.POSITION_TOP;
    if (exactMatchInsensitive(position2, MobScrollerConstant.POSITION_BOTTOM))
      return MobScrollerConstant.POSITION_BOTTOM;
    if (exactMatchInsensitive(position2, MobScrollerConstant.POSITION_LEFT))
      return MobScrollerConstant.POSITION_LEFT;
    if (exactMatchInsensitive(position2, MobScrollerConstant.POSITION_RIGHT))
      return MobScrollerConstant.POSITION_RIGHT;
    return "";
  };
  var getRangeUnitMisure = (string) => {
    if (exactMatchInsesitiveNumberProp(string, MobScrollerConstant.PX))
      return MobScrollerConstant.PX;
    if (exactMatchInsesitiveNumberProp(string, MobScrollerConstant.VH))
      return MobScrollerConstant.VH;
    if (exactMatchInsesitiveNumberProp(string, MobScrollerConstant.VW))
      return MobScrollerConstant.VW;
    if (exactMatchInsesitiveNumberProp(string, MobScrollerConstant.WPERCENT))
      return MobScrollerConstant.WPERCENT;
    if (exactMatchInsesitiveNumberProp(string, MobScrollerConstant.HPERCENT))
      return MobScrollerConstant.HPERCENT;
    if (exactMatchInsesitiveNumberProp(string, MobScrollerConstant.DEGREE))
      return MobScrollerConstant.DEGREE;
    return MobScrollerConstant.PX;
  };

  // src/js/mob/mob-motion/animation/utils/tween-action/tween-validation.js
  var dataTweenValueIsValid = (val2) => {
    return modules_exports.checkType(Number, val2) || // @ts-ignore
    modules_exports.checkType(Function, val2) && modules_exports.checkType(Number, val2());
  };
  var sequencerRangeValidate = ({ start, end }) => {
    const startIsValid = modules_exports.checkType(Number, start);
    const endIsValid = modules_exports.checkType(Number, end);
    if (!startIsValid) sequencerRangeStartWarning(start);
    if (!endIsValid) sequencerRangeEndWarning(end);
    return startIsValid && endIsValid;
  };
  var durationIsValid = (duration2) => {
    const isValid = modules_exports.checkType(Number, duration2);
    if (!isValid && duration2) durationWarining(duration2);
    return isValid ? (
      /** @type {number} */
      duration2
    ) : handleSetUp.get("sequencer").duration;
  };
  var repeatIsValid = (repeat) => {
    const isValid = modules_exports.checkType(Number, repeat);
    if (!isValid && repeat) repeatWarining(repeat);
    return isValid && repeat ? repeat : 1;
  };
  var easeIsValid = (ease) => {
    const isValid = ease && ease in tweenConfig;
    if (!isValid && ease) tweenEaseWarning(ease);
    return isValid ? ease : handleSetUp.get("sequencer").ease;
  };
  var easeScrollerTweenIsValid = (ease) => {
    const isValid = ease && ease in tweenConfig;
    if (!isValid && ease) tweenEaseWarning(ease);
    return isValid ? getTweenFn(ease) : getTweenFn(handleSetUp.get("parallaxTween").ease);
  };
  var initialDataPropValidate = (prop, value) => {
    const propIsValid = modules_exports.checkType(String, prop);
    const valueIsValid = modules_exports.checkType(Number, value);
    if (!propIsValid) initialDataPropWarining(prop);
    if (!valueIsValid) initialDataValueWarining(value);
    return propIsValid && valueIsValid;
  };
  var validateStaggerEach = (each) => {
    if (!each) return;
    const eachIsValid = modules_exports.checkType(Number, each);
    if (!eachIsValid) staggerEachWarning();
    return eachIsValid;
  };
  var validateStaggerFrom = (from) => {
    if (!from) return;
    const fromList = [
      STAGGER_START,
      STAGGER_END,
      STAGGER_CENTER,
      STAGGER_EDGES,
      STAGGER_RANDOM
    ];
    const fromIsAValidString = fromList.includes(from);
    const fromIsANumber = modules_exports.checkType(Number, from);
    const fromIsAValidObject = modules_exports.checkType(Object, from);
    const fromIsValid = fromIsAValidString || fromIsANumber || fromIsAValidObject;
    if (!fromIsValid) staggerFromGenericWarning(from);
    return fromIsValid;
  };
  var validateStaggerColRow = (val2) => {
    if (!val2) return;
    const valIsValid = modules_exports.checkType(Number, val2);
    if (!valIsValid) staggerRowColGenericWarining(val2);
    return valIsValid;
  };
  var validateStaggerDirection = (direction2) => {
    if (!direction2) return;
    const directionList = [DIRECTION_RADIAL, DIRECTION_ROW, DIRECTION_COL];
    const directionisValid = directionList.includes(direction2);
    if (!directionisValid) staggerGridDirectionWarning();
    return directionisValid;
  };
  var validateStaggerWaitComplete = (waitComplete) => {
    if (!waitComplete) return;
    const valIsValid = modules_exports.checkType(Boolean, waitComplete);
    if (!valIsValid) staggerWaitCompleteWarning();
    return valIsValid;
  };
  var validateStaggerItems = (arr = []) => {
    const isValid = modules_exports.checkType(Array, [...arr]) && arr.length > 0;
    if (!isValid) createStaggerItemsWarning();
    return isValid;
  };
  var staggerItemsIsValid = (arr = []) => {
    const isValid = modules_exports.checkType(Array, [...arr]) && arr.length > 0;
    return isValid ? arr : [];
  };
  var validateStaggerType = (type) => {
    if (!type) return;
    const stagerTypeList = [
      STAGGER_TYPE_EQUAL,
      STAGGER_TYPE_START,
      STAGGER_TYPE_END,
      STAGGER_TYPE_CENTER
    ];
    const isValid = stagerTypeList.includes(type);
    if (!isValid) {
      createStaggerTypeWarning();
      return;
    }
    return isValid;
  };
  var relativeIsValid = (val2, tweenType) => {
    const isValid = modules_exports.checkType(Boolean, val2);
    if (!isValid && val2) relativeWarining(val2, tweenType);
    return isValid ? (
      /** @type {boolean} */
      val2
    ) : handleSetUp.get(tweenType).relative;
  };
  var easeTweenIsValidGetFunction = (ease) => {
    const isValid = ease && ease in tweenConfig;
    if (!isValid && ease) tweenEaseWarning(ease);
    return isValid ? getTweenFn(ease) : getTweenFn(handleSetUp.get("tween").ease);
  };
  var easeTweenIsValid = (ease) => {
    const isValid = ease && ease in tweenConfig;
    if (!isValid && ease) tweenEaseWarning(ease);
    return isValid ? ease : handleSetUp.get("tween").ease;
  };
  var springConfigIsValidAndGetNew = (config) => {
    const { config: allConfig } = handleSetUp.get("spring");
    const isInConfig = config && config in allConfig;
    const obj = isInConfig ? allConfig[config] : {};
    const isValidPropsKey = isInConfig ? (() => {
      return modules_exports.checkType(Object, obj) && "tension" in obj && "mass" in obj && "friction" in obj && "velocity" in obj && "precision" in obj;
    })() : false;
    const isValidPropsValue = isValidPropsKey ? Object.values(obj).every((prop) => {
      return modules_exports.checkType(Number, prop) && prop >= 0;
    }) : null;
    if (!isInConfig && config) springPresetWarning(config);
    if (!isValidPropsValue && isInConfig)
      springConfigSpecificPropWarning(config);
    return isValidPropsValue ? allConfig[config] : allConfig.default;
  };
  var springConfigIsValid = (config) => {
    const { config: allConfig } = handleSetUp.get("spring");
    const isValid = config && config in allConfig;
    if (!isValid && config) springPresetWarning(config);
    return isValid;
  };
  var springConfigPropIsValid = (obj) => {
    const isValid = modules_exports.checkType(Object, obj) && // @ts-ignore
    Object.values(obj).every((prop) => {
      return modules_exports.checkType(Number, prop) && prop >= 0;
    });
    if (!isValid && obj) springConfigPropWarning();
    return isValid ? obj : {};
  };
  var durationIsNumberOrFunctionIsValid = (duration2) => {
    const durationIsFn = modules_exports.checkType(Function, duration2);
    const durationResult = durationIsFn ? duration2() : duration2;
    const isValid = modules_exports.checkType(Number, durationResult);
    if (!isValid && duration2) durationNumberOrFunctionWarining(duration2);
    return isValid ? durationResult : handleSetUp.get("tween").duration;
  };
  var valueIsBooleanAndTrue = (value, label) => {
    const isValid = modules_exports.checkType(Boolean, value);
    if (!isValid && value) booleanWarning(value, label);
    return isValid && value === true;
  };
  var valueIsBooleanAndReturnDefault = (value, label, defaultValue) => {
    const isValid = modules_exports.checkType(Boolean, value);
    if (!isValid && value) booleanWarning(value, label);
    return isValid ? value : defaultValue;
  };
  var valueIsStringAndReturnDefault = (value, label, defaultValue) => {
    const isValid = modules_exports.checkType(String, value);
    if (!isValid && value) stringWarning(value, label);
    return isValid ? value : defaultValue;
  };
  var valueIsNumberAndReturnDefault = (value, label, defaultValue) => {
    const isValid = modules_exports.checkType(Number, value);
    if (!isValid && value) naumberWarning(value, label);
    return isValid ? (
      /** @type {number} */
      value
    ) : defaultValue;
  };
  var valueIsFunctionAndReturnDefault = (value, label, defaultValue) => {
    const isValid = modules_exports.checkType(Function, value);
    if (!isValid && value) functionWarning(value, label);
    return isValid ? value : defaultValue;
  };
  var lerpVelocityIsValid = (value) => {
    const isValid = modules_exports.checkType(Number, value) && value > 0 && value <= 1;
    if (!isValid && value) lerpVelocityWarining();
    return isValid ? (
      /** @type {number} */
      value
    ) : handleSetUp.get("lerp").velocity;
  };
  var lerpPrecisionIsValid = (value) => {
    const isValid = modules_exports.checkType(Number, value);
    if (!isValid && value) lerpPrecisionWarining();
    return isValid ? (
      /** @type {number} */
      value
    ) : handleSetUp.get("lerp").precision;
  };
  var valueStringIsValid = (value, label) => {
    const isValid = modules_exports.checkType(String, value);
    if (!isValid && value) valueStringWarning(label);
    return isValid;
  };
  var asyncTimelineDelayIsValid = (value) => {
    const isValid = modules_exports.checkType(Number, value);
    if (!isValid && value) asyncTimelineDelayWarning();
    return isValid ? value : void 0;
  };
  var asyncTimelineTweenIsValid = (instance) => {
    const isValid = instance?.getType?.() && (instance.getType() === "LERP" || instance.getType() === "SPRING" || instance.getType() === "TWEEN");
    if (!isValid && instance) asyncTimelineTweenWaring();
    return isValid;
  };
  var playLabelIsValid = (index, label) => {
    if (index === -1) playLabelWarining(label);
  };
  var functionIsValidAndReturnDefault = (fn, defaultValue, label) => {
    const isValid = modules_exports.checkType(Function, fn);
    if (!isValid && fn) functionIsValidAndReturnDefaultWarining(label, fn);
    return isValid ? fn : defaultValue;
  };
  var addAsyncFunctionIsValid = (fn) => {
    const isValid = modules_exports.checkType(Function, fn);
    if (!isValid && fn) addAsyncFunctionWarining(fn);
    return isValid ? fn : ({ resolve }) => {
      resolve();
    };
  };
  var timelineSetTweenArrayIsValid = (arr) => {
    const isValid = modules_exports.checkType(Array, arr);
    if (!isValid && arr) timelineSetTweenArrayWarining(arr);
    return isValid;
  };
  var timelineSetTweenLabelIsValid = (label) => {
    const isValid = modules_exports.checkType(String, label);
    if (!isValid && label) timelineSetTweenLabelWarining(label);
    return isValid;
  };
  var domNodeIsValidAndReturnElOrWin = (element, returnWindow = false) => {
    const isNode3 = modules_exports.checkType(Element, element);
    const realEl = isNode3 ? element : document.querySelector(element);
    return returnWindow ? (
      /** @type {HTMLElement} */
      realEl ?? globalThis
    ) : (
      /** @type {HTMLElement} */
      realEl ?? document.createElement("div")
    );
  };
  var domNodeIsValidAndReturnNull = (element) => {
    const isNode3 = modules_exports.checkType(Element, element);
    const realEl = isNode3 ? element : document.querySelector(element);
    return realEl;
  };
  var directionIsValid = (direction2, component) => {
    if (!direction2) return MobScrollerConstant.DIRECTION_VERTICAL;
    const choice = [
      MobScrollerConstant.DIRECTION_VERTICAL,
      MobScrollerConstant.DIRECTION_HORIZONTAL
    ];
    const isValid = choice.includes(direction2);
    if (!isValid && direction2) scrollerDirectionWarining(direction2, component);
    return isValid ? direction2 : MobScrollerConstant.DIRECTION_VERTICAL;
  };
  var scrollerDynamicValueIsValid = (obj, label) => {
    const positionChoice = [
      MobScrollerConstant.POSITION_TOP,
      MobScrollerConstant.POSITION_LEFT,
      MobScrollerConstant.POSITION_RIGHT,
      MobScrollerConstant.POSITION_BOTTOM
    ];
    const valueIsObject = modules_exports.checkType(Object, obj);
    const positionIsValid = valueIsObject && modules_exports.checkType(String, obj?.position) && positionChoice.includes(obj.position);
    const valueIsValid = valueIsObject && modules_exports.checkType(Function, obj.value) && modules_exports.checkType(Number, obj.value());
    const isValid = valueIsObject && positionIsValid && valueIsValid;
    if (!isValid) scrollerDynmicValueWarining(label);
    return isValid ? obj : null;
  };
  var scrollerDynamicRangeIsValid = (fn) => {
    const isValid = modules_exports.checkType(Function, fn) && modules_exports.checkType(Number, fn?.());
    if (!isValid && fn) scrollerDynmicRangeValueWarining();
    return isValid ? fn : void 0;
  };
  var scrollerTweenIsValid = (instance) => {
    const isValid = instance?.getType?.() && (instance.getType() === MobScrollerConstant.TWEEN_TWEEN || instance.getType() === MobScrollerConstant.TWEEN_TIMELINE);
    if (!isValid && instance) scrollerTweenWarning();
    return isValid ? instance : {};
  };
  var scrollerAlignIsValid = (value) => {
    if (!value) return MobScrollerConstant.ALIGN_CENTER;
    const choice = [
      MobScrollerConstant.ALIGN_START,
      MobScrollerConstant.ALIGN_TOP,
      MobScrollerConstant.ALIGN_RIGHT,
      MobScrollerConstant.ALIGN_CENTER,
      MobScrollerConstant.ALIGN_BOTTOM,
      MobScrollerConstant.ALIGN_LEFT,
      MobScrollerConstant.ALIGN_END
    ];
    const isValid = choice.includes(value) || modules_exports.checkType(Number, value);
    if (!isValid && value) scrollerAlignWarining(value, choice);
    return isValid ? value : MobScrollerConstant.ALIGN_CENTER;
  };
  var scrollerOnSwitchIsValid = (value) => {
    if (!value) return false;
    const choice = [
      MobScrollerConstant.IN_BACK,
      MobScrollerConstant.IN_STOP,
      MobScrollerConstant.OUT_BACK,
      MobScrollerConstant.OUT_STOP
    ];
    const isValid = choice.includes(value);
    if (!isValid && value) scrollerOnSwitchWarining(value, choice);
    return isValid ? value : false;
  };
  var scrollerOpacityIsValid = (value, label, defaultValue) => {
    if (value === void 0 || value === null) return defaultValue;
    const isValid = modules_exports.checkType(Number, value);
    if (!isValid && value) scrollerOpacityWarning(value, label);
    return isValid ? value : defaultValue;
  };
  var scrollerTypeIsValid = (value) => {
    if (!value) return MobScrollerConstant.TYPE_PARALLAX;
    const valueLowerCase = value?.toLowerCase();
    const choice = [
      MobScrollerConstant.TYPE_PARALLAX,
      MobScrollerConstant.TYPE_SCROLLTRIGGER
    ];
    const isValid = choice.includes(valueLowerCase);
    if (!isValid && valueLowerCase)
      scrollerTypeWarining(valueLowerCase, choice);
    return isValid ? valueLowerCase : MobScrollerConstant.TYPE_PARALLAX;
  };
  var scrollerRangeIsValid = (value, type) => {
    const parsedValue = () => {
      if (type === MobScrollerConstant.TYPE_PARALLAX) {
        const isOnlyNumber = checkIfIsOnlyNumber(value);
        const isValid = modules_exports.checkType(Number, Number(value)) && isOnlyNumber && // @ts-ignore
        value >= 0 && // @ts-ignore
        value < 10;
        if (!isValid && value) scrollerRangeNumberWarning(value);
        return isValid ? (
          // @ts-ignore
          10 - value
        ) : 10 - handleSetUp.get("parallax").defaultRange;
      } else {
        const isValid = modules_exports.checkType(String, value);
        if (!isValid && value) scrollerRangeStringWarning(value);
        return isValid ? value : "0px";
      }
    };
    return parsedValue();
  };
  var breakpointIsValid = (mq3, label, component) => {
    const defaultMq = handleSetUp.get("defaultMq").value;
    if (!mq3) return defaultMq;
    const mqObj = handleSetUp.get("mq");
    const choice = Object.keys(mqObj);
    const isValid = modules_exports.checkType(String, mq3) && choice.includes(mq3);
    if (!isValid && mq3) breakpointWarning(mq3, choice, label, component);
    return isValid ? mq3 : defaultMq;
  };
  var breakpointTypeIsValid = (type, label, component) => {
    const defaultType = handleSetUp.get("defaultMq").type;
    if (!type) return defaultType;
    const choice = [MQ_MAX, MQ_MIN];
    const isValid = modules_exports.checkType(String, type) && choice.includes(type);
    if (!isValid && type) breakpointWarning(type, choice, label, component);
    return isValid ? type : defaultType;
  };
  var scrollerPropiertiesIsValid = (value, type, tweenIsParallaxTween, tweenIsSequencer) => {
    if (!value && tweenIsSequencer)
      return {
        propierties: MobScrollerConstant.PROP_VERTICAL,
        shouldTrackOnlyEvents: true
      };
    if (!value && tweenIsParallaxTween)
      return {
        propierties: MobScrollerConstant.PROP_VERTICAL,
        shouldTrackOnlyEvents: false
      };
    const shouldTrackOnlyEvents = type === MobScrollerConstant.TYPE_SCROLLTRIGGER && !value;
    const choice = [
      MobScrollerConstant.PROP_VERTICAL,
      MobScrollerConstant.PROP_HORIZONTAL,
      MobScrollerConstant.PROP_ROTATE,
      MobScrollerConstant.PROP_ROTATEY,
      MobScrollerConstant.PROP_ROTATEX,
      MobScrollerConstant.PROP_ROTATEZ,
      MobScrollerConstant.PROP_OPACITY,
      MobScrollerConstant.PROP_SCALE,
      MobScrollerConstant.PROP_SCALE_X,
      MobScrollerConstant.PROP_SCALE_Y,
      MobScrollerConstant.PROP_TWEEN
    ];
    const isValid = modules_exports.checkType(String, value);
    if (!isValid && value) scrollerPropiertiesWarining(value, choice);
    const notParallaxTweenInsideParallax = type === MobScrollerConstant.TYPE_PARALLAX && value === MobScrollerConstant.PROP_TWEEN && !tweenIsParallaxTween;
    if (!tweenIsParallaxTween && !tweenIsSequencer && value === MobScrollerConstant.PROP_TWEEN)
      scrollerNoTweenDefinedWarning();
    if ((tweenIsParallaxTween || tweenIsSequencer) && value !== MobScrollerConstant.PROP_TWEEN)
      scrollerUseTweenButNotProsDefinedWarning();
    if (notParallaxTweenInsideParallax) scrollerUseSequencerWarining();
    const valueParsed = notParallaxTweenInsideParallax ? MobScrollerConstant.PROP_VERTICAL : value;
    const valueFromConstant = getPropiertiesValueFromConstant(valueParsed);
    return {
      propierties: isValid ? valueFromConstant ?? MobScrollerConstant.PROP_VERTICAL : MobScrollerConstant.PROP_VERTICAL,
      shouldTrackOnlyEvents
    };
  };
  var scrollerEaseTypeIsValid = (value) => {
    if (!value) return MobScrollerConstant.EASE_LERP;
    const choice = [
      MobScrollerConstant.EASE_SPRING,
      MobScrollerConstant.EASE_LERP
    ];
    const isValid = choice.includes(value);
    if (!isValid) scrollerEaseTypeWarining(value, choice);
    const fallback = isValid ? value : MobScrollerConstant.EASE_LERP;
    return isValid ? value : fallback;
  };
  var genericEaseTypeIsValid = (value, component) => {
    const choice = [
      MobScrollerConstant.EASE_SPRING,
      MobScrollerConstant.EASE_LERP
    ];
    const isValid = choice.includes(value);
    if (!isValid && value) genericEaseTypeWarining(value, choice, component);
    return isValid ? value : MobScrollerConstant.EASE_LERP;
  };
  var scrollerSpringConfigIsValid = (config, type) => {
    const defaultConfig = type === MobScrollerConstant.TYPE_PARALLAX ? handleSetUp.get("parallax").springConfig : handleSetUp.get("scrollTrigger").springConfig;
    if (!config) return defaultConfig;
    const springDefaultConfig = handleSetUp.get("spring").config;
    const choice = Object.keys(springDefaultConfig);
    const isValid = choice.includes(config);
    if (!isValid && config) scrollerSpringCongifWarining(config, choice);
    return isValid ? config : defaultConfig;
  };
  var scrollerLerpConfigIsValid = (value, type) => {
    const isValid = (
      // @ts-ignore
      modules_exports.checkType(Number, Number(value)) && value > 0 && value <= 1
    );
    if (!isValid && value) scrollerLerpConfigWarning();
    const defaultConfig = type === MobScrollerConstant.TYPE_PARALLAX ? handleSetUp.get("parallax").lerpConfig : handleSetUp.get("scrollTrigger").lerpConfig;
    return isValid ? (
      /** @type {number} */
      value
    ) : defaultConfig;
  };
  var checkStringRangeOnPropierties = (value, properties) => {
    const parallalxXYRangeChoice = [
      MobScrollerConstant.PX,
      MobScrollerConstant.VW,
      MobScrollerConstant.VH,
      MobScrollerConstant.WPERCENT,
      MobScrollerConstant.HPERCENT
    ];
    if (properties === MobScrollerConstant.PROP_VERTICAL || properties === MobScrollerConstant.PROP_HORIZONTAL) {
      const isValid2 = exactMatchInsesitiveNumberPropArray(
        parallalxXYRangeChoice,
        value
      );
      if (!isValid2)
        scrollTriggerRangeWarning(
          value,
          properties,
          parallalxXYRangeChoice
        );
      return isValid2 ? value : "0px";
    }
    if (properties === MobScrollerConstant.PROP_ROTATE || properties === MobScrollerConstant.PROP_ROTATEX || properties === MobScrollerConstant.PROP_ROTATEY || properties === MobScrollerConstant.PROP_ROTATEZ) {
      const isValid2 = exactMatchInsesitiveNumberPropArray(
        [MobScrollerConstant.DEGREE],
        value
      );
      if (!isValid2)
        scrollTriggerRangeWarning(value, properties, [
          MobScrollerConstant.DEGREE
        ]);
      return isValid2 ? value : "0";
    }
    if (properties === MobScrollerConstant.PROP_SCALE || properties === MobScrollerConstant.PROP_SCALE_X || properties === MobScrollerConstant.PROP_SCALE_Y) {
      const isValid2 = checkIfIsOnlyNumberPositiveNegative(value);
      if (!isValid2) scrollTriggerRangeScaleWarning(value, properties);
      return isValid2 ? value : "0";
    }
    const isValid = checkIfIsOnlyNumberPositiveNegative(value);
    if (!isValid) scrollTriggerCustomRangeWarning(properties);
    return isValid ? value : "0";
  };

  // src/js/mob/mob-motion/animation/utils/stagger/stagger-utils.js
  var getEachByFps = (each) => {
    const { instantFps } = modules_exports.store.get();
    const eachByFps = Math.round(each * (instantFps / 60));
    return each === 1 && eachByFps === 0 ? each : eachByFps;
  };
  var getStaggerFromProps = (props) => {
    return {
      type: validateStaggerType(props?.stagger?.type) ? props.stagger.type : STAGGER_DEFAULT_OBJ.type,
      each: validateStaggerEach(props?.stagger?.each) ? props.stagger.each : STAGGER_DEFAULT_OBJ.each,
      //
      from: validateStaggerFrom(props?.stagger?.from) ? props?.stagger?.from : STAGGER_TYPE_START,
      //
      grid: {
        col: validateStaggerColRow(props?.stagger?.grid?.col) ? props.stagger.grid.col : STAGGER_DEFAULT_OBJ.grid.col,
        //
        row: validateStaggerColRow(props?.stagger?.grid?.row) ? props.stagger.grid.row : STAGGER_DEFAULT_OBJ.grid.row,
        //
        direction: validateStaggerDirection(props?.stagger?.grid?.direction) ? props.stagger.grid.direction : DIRECTION_COL
      },
      //
      waitComplete: validateStaggerWaitComplete(props?.stagger?.waitComplete) ? props.stagger.waitComplete : STAGGER_DEFAULT_OBJ.waitComplete
    };
  };
  var getStaggerArray = (callbackCache, callbackDefault) => {
    return callbackCache.length > callbackDefault.length ? callbackCache : callbackDefault;
  };

  // src/js/mob/mob-motion/animation/utils/stagger/get-default-stagger.js
  var isOdd = (num) => num % 2;
  var getRandomInt = (max2) => Math.floor(Math.random() * max2);
  var getRandomChoice = (arrayChunk, each, index) => {
    const previousFrame = new Set(
      arrayChunk.slice(0, index).map((item) => item.frame)
    );
    const posibileFrame = arrayChunk.map((_item, i) => i * each);
    const randomChoice = posibileFrame.filter((x) => !previousFrame.has(x));
    return randomChoice;
  };
  var getStaggerIndex = (index, arraylenght, stagger, randomChoice = []) => {
    const { from, each } = stagger;
    const eachByFps = getEachByFps(each);
    if (from === STAGGER_RANDOM) {
      return {
        index,
        frame: (() => randomChoice[getRandomInt(randomChoice.length)])()
      };
    }
    if (from === STAGGER_START) {
      return {
        index,
        frame: index * eachByFps
      };
    }
    if (from === STAGGER_END) {
      return {
        index,
        frame: (arraylenght - 1 - index) * eachByFps
      };
    }
    if (from === STAGGER_CENTER) {
      const half = Math.trunc(arraylenght / 2);
      return (() => {
        if (index > half) {
          return {
            index,
            frame: (index - half) * eachByFps
          };
        }
        if (index < half) {
          return isOdd(arraylenght) === 0 && half - index === 1 ? {
            index,
            frame: 0
          } : (() => {
            return isOdd(arraylenght) === 0 ? {
              index,
              frame: (half - index - 1) * eachByFps
            } : {
              index,
              frame: (half - index) * eachByFps
            };
          })();
        }
        return {
          index,
          frame: 0
        };
      })();
    }
    if (from === STAGGER_EDGES) {
      const half = Math.trunc(arraylenght / 2);
      return (() => {
        if (index > half) {
          return {
            index,
            frame: (arraylenght - half - 1 - (index - half)) * eachByFps
          };
        }
        if (index < half) {
          return isOdd(arraylenght) === 0 && half - index === 1 ? {
            index,
            frame: (half - 1) * eachByFps
          } : (() => {
            return isOdd(arraylenght) === 0 ? {
              index,
              frame: (arraylenght - half - (half - index)) * eachByFps
            } : {
              index,
              frame: (arraylenght - half - 1 - (half - index)) * eachByFps
              // dfault,
            };
          })();
        }
        return isOdd(arraylenght) ? {
          index,
          frame: half * eachByFps
          // dfault,
        } : {
          index,
          frame: (half - 1) * eachByFps
          // dfault,
        };
      })();
    }
    if (from && checkType(Number, from)) {
      const half = from >= arraylenght ? arraylenght - 1 : from;
      return (() => {
        if (index > half) {
          return {
            index,
            // @ts-ignore
            frame: (index - half) * each
          };
        }
        if (index < half) {
          return {
            index,
            // @ts-ignore
            frame: (half - index) * each
          };
        }
        return {
          index,
          frame: 0
        };
      })();
    }
    return {
      index: 0,
      frame: 0
    };
  };
  var getItemsByRow = (arrayDefault, stagger, chunckSizeCol) => {
    if (stagger.grid.direction === DIRECTION_ROW) {
      const chunkByCol = sliceIntoChunks(arrayDefault, chunckSizeCol);
      const colToRowArray = [
        ...Array.from({ length: stagger.grid.col }).keys()
        // @ts-ignore
      ].reduce((p, _c, i) => {
        return [...p, ...arrayColumn(chunkByCol, i)];
      }, []);
      return [...colToRowArray].flat();
    } else {
      return arrayDefault;
    }
  };
  var getDefaultStagger = ({
    arrayDefault,
    arrayOnStop,
    stagger,
    slowlestStagger,
    fastestStagger
  }) => {
    const chunckSizeCol = stagger?.grid?.col <= 1 ? arrayDefault.length : stagger.grid.col;
    const chunckSizeRow = stagger?.grid?.row <= 1 ? arrayDefault.length : stagger.grid.row;
    const itemByRow = getItemsByRow(arrayDefault, stagger, chunckSizeCol);
    const staggerArray = itemByRow.map((item) => {
      return item && item !== void 0 ? item : { index: 0, frame: 0 };
    });
    const itemCompleteByRow = getItemsByRow(
      arrayOnStop,
      stagger,
      chunckSizeCol
    );
    const staggerArrayOnComplete = itemCompleteByRow.map((item) => {
      return item && item !== void 0 ? item : { index: 0, frame: 0 };
    });
    const chunksize = stagger.grid.direction === DIRECTION_ROW ? chunckSizeRow : chunckSizeCol;
    const chunked = sliceIntoChunks(staggerArray, chunksize);
    const firstChunk = chunked[0];
    firstChunk.forEach((item, i) => {
      const { index, frame } = getStaggerIndex(
        i,
        chunked[0].length,
        stagger,
        getRandomChoice(firstChunk, stagger.each, i)
      );
      item.index = index;
      item.frame = frame;
      if (frame >= slowlestStagger.frame)
        slowlestStagger = {
          index,
          frame
        };
      if (frame <= fastestStagger.frame)
        fastestStagger = {
          index,
          frame
        };
    });
    chunked.forEach((chunkItem) => {
      chunkItem.forEach((item, i) => {
        if (item) {
          item.index = chunked[0][i].index;
          item.frame = chunked[0][i].frame;
        }
      });
    });
    const flatArray = chunked.flat();
    flatArray.forEach((item, i) => {
      staggerArray[i].index = item.index;
      staggerArray[i].frame = item.frame;
      if (staggerArrayOnComplete.length > 0) {
        staggerArrayOnComplete[i].index = item.index;
        staggerArrayOnComplete[i].frame = item.frame;
      }
    });
    return {
      staggerArray,
      staggerArrayOnComplete,
      fastestStagger,
      slowlestStagger
    };
  };

  // src/js/mob/mob-motion/animation/utils/stagger/get-radial-stagger.js
  var getRadialY = (arr, x, y) => {
    return arr.reduce((total, row, i) => {
      const offset2 = Math.abs(i - y);
      const newRow = row.reduce((p, c, i2) => {
        return i2 < x - offset2 || i2 > x + offset2 ? p : [...p, c];
      }, []);
      return [...total, newRow];
    }, []);
  };
  var getRadialX = (arr, x, y, chunk) => {
    return arr.reduce((total, _row, i) => {
      const offset2 = Math.abs(i - y);
      const newRow = [];
      if (i >= y && i <= y * 2) {
        return [...total, newRow];
      }
      const xStart = x - offset2;
      const xEnd = x + offset2;
      for (let i2 = 0; i2 < offset2; i2++) {
        if (isAvailableIntoChunk(chunk, y + i2, xStart)) {
          newRow.push(chunk[y + i2][xStart]);
        }
        if (isAvailableIntoChunk(chunk, y + i2, xEnd)) {
          newRow.push(chunk[y + i2][xEnd]);
        }
        if (i2 > 0) {
          if (isAvailableIntoChunk(chunk, y - i2, xStart)) {
            newRow.push(chunk[y - i2][xStart]);
          }
          if (isAvailableIntoChunk(chunk, y - i2, xEnd)) {
            newRow.push(chunk[y - i2][xEnd]);
          }
        }
      }
      const newRowFiltered = newRow.filter((item) => item != void 0);
      return [...total, newRowFiltered];
    }, []);
  };
  var isAvailableIntoChunk = (arr, i, i2) => {
    return arr[i] !== void 0 && arr[i][i2] !== void 0;
  };
  var getRadialArray = (arr, stagger) => {
    const { col } = stagger.grid;
    const { x, y } = stagger.from;
    const chunk = sliceIntoChunks(arr, col);
    [...Array.from({ length: col }).keys()].forEach(() => {
      chunk.push([]);
    });
    const radialArrY = getRadialY(chunk, x, y);
    const radialArrX = getRadialX(radialArrY, x, y, chunk);
    const radialXY = radialArrY.reduce((p, _c, i) => {
      const row = [...radialArrY[i], ...radialArrX[i]];
      p.push(row);
      return p;
    }, []);
    const arrayLength = radialXY.length;
    const mergeDirection = y >= arrayLength / 2 ? MERGE_FROM_UP : MERGE_FROM_DOWN;
    const finalArray = mergeDirection === MERGE_FROM_DOWN ? radialXY.reduce(
      (previous, _current, index) => {
        if (index < y) {
          return previous;
        } else if (index === y) {
          const merged = [...radialXY[index]];
          previous.push(merged);
          return previous;
        } else {
          const downRow = radialXY[y - (index - y)] ?? [];
          const merged = [...radialXY[index], ...downRow];
          previous.push(merged);
          return previous;
        }
      },
      []
    ) : radialXY.reduce(
      (previous, _current, index) => {
        if (index > y) {
          return previous;
        } else if (index === y) {
          const merged = [...radialXY[index]];
          previous.push(merged);
          return previous;
        } else {
          const upRow = radialXY[y + (y - index)] ?? [];
          const merged = [...radialXY[index], ...upRow];
          previous.push(merged);
          return previous;
        }
      },
      []
    ).reverse();
    const cleanArray = finalArray.reduce(
      (previous, current) => {
        return current.length === 0 ? previous : [...previous, current];
      },
      []
    );
    return {
      cleanArray
    };
  };

  // src/js/mob/mob-motion/animation/utils/stagger/set-stagger.js
  var getRadial = ({
    arrayDefault,
    arrayOnStop,
    stagger,
    slowlestStagger,
    fastestStagger
  }) => {
    if (!modules_exports.checkType(Object, stagger?.from)) {
      stagger.from = {};
    }
    if (!modules_exports.checkType(Number, stagger?.from?.x)) {
      stagger.from = { ...stagger.from, x: 0 };
    }
    if (!modules_exports.checkType(Number, stagger?.from?.y)) {
      stagger.from = { ...stagger.from, y: 0 };
    }
    const { cleanArray: cleanCb } = getRadialArray(arrayDefault, stagger);
    let counter = 0;
    cleanCb.forEach((chunk, i) => {
      chunk.forEach((item) => {
        const eachByFps = getEachByFps(stagger.each);
        const frame = i * eachByFps;
        item.index = counter;
        item.frame = frame;
        if (frame >= slowlestStagger.frame)
          slowlestStagger = {
            index: counter,
            frame
          };
        if (frame <= fastestStagger.frame)
          fastestStagger = {
            index: counter,
            frame
          };
        counter++;
      });
    });
    const cleanEndCb = (() => {
      if (arrayOnStop.length > 0) {
        const { cleanArray } = getRadialArray(arrayOnStop, stagger);
        return cleanArray.flat();
      } else {
        return [];
      }
    })();
    const staggerArray = cleanCb.flat();
    const endstaggerArray = cleanEndCb.flat();
    staggerArray.forEach((item, i) => {
      if (endstaggerArray.length > 0) {
        endstaggerArray[i].index = item.index;
        endstaggerArray[i].frame = item.frame;
      }
    });
    return {
      staggerArray,
      staggerArrayOnComplete: endstaggerArray,
      fastestStagger,
      slowlestStagger
    };
  };
  var getDefault2 = ({
    arrayDefault,
    arrayOnStop,
    stagger,
    slowlestStagger,
    fastestStagger
  }) => {
    const fromList = [
      STAGGER_START,
      STAGGER_END,
      STAGGER_CENTER,
      STAGGER_EDGES,
      STAGGER_RANDOM
    ];
    if (!modules_exports.checkType(String, stagger?.from) && !modules_exports.checkType(Number, stagger?.from) || modules_exports.checkType(String, stagger?.from) && // @ts-ignore
    !fromList.includes(stagger?.from)) {
      staggerColRowWarning();
      stagger.from = STAGGER_START;
    }
    return getDefaultStagger({
      arrayDefault,
      arrayOnStop,
      stagger,
      slowlestStagger,
      fastestStagger
    });
  };
  var setStagger = ({
    arrayDefault,
    arrayOnStop,
    stagger,
    slowlestStagger,
    fastestStagger
  }) => {
    const result = stagger?.grid?.direction === DIRECTION_RADIAL ? getRadial({
      arrayDefault,
      arrayOnStop,
      stagger,
      slowlestStagger,
      fastestStagger
    }) : getDefault2({
      arrayDefault,
      arrayOnStop,
      stagger,
      slowlestStagger,
      fastestStagger
    });
    const staggerArray = result.staggerArray;
    const staggerArrayOnComplete = result.staggerArrayOnComplete;
    const fastestStaggerUpdated = result.fastestStagger;
    const slowlestStaggerUpdated = result.slowlestStagger;
    return {
      staggerArray,
      staggerArrayOnComplete,
      fastestStagger: fastestStaggerUpdated,
      slowlestStagger: slowlestStaggerUpdated
    };
  };

  // src/js/mob/mob-motion/animation/utils/callbacks/default-callback.js
  var defaultCallback = ({
    stagger,
    callback: callback2,
    callbackCache,
    callBackObject,
    useStagger
  }) => {
    if (stagger.each === 0 || !useStagger) {
      modules_exports.useFrame(() => {
        callback2.forEach(({ cb }) => {
          cb(callBackObject);
        });
      });
      modules_exports.useFrame(() => {
        callbackCache.forEach(({ cb }) => {
          modules_exports.useCache.fireObject({ id: cb, obj: callBackObject });
        });
      });
      return;
    }
    callback2.forEach(({ cb, frame }) => {
      modules_exports.useFrameIndex(() => {
        cb(callBackObject);
      }, frame);
    });
    callbackCache.forEach(({ cb, frame }) => {
      modules_exports.useCache.update({ id: cb, callBackObject, frame });
    });
  };
  var defaultCallbackOnComplete = ({
    onComplete: onComplete2,
    callback: callback2,
    callbackCache,
    callbackOnComplete,
    callBackObject,
    stagger,
    slowlestStagger,
    fastestStagger,
    useStagger
  }) => {
    if (stagger.each === 0 || !useStagger) {
      onComplete2();
      modules_exports.useNextFrame(() => {
        callback2.forEach(({ cb }) => {
          cb(callBackObject);
        });
        callbackCache.forEach(({ cb }) => {
          modules_exports.useCache.fireObject({ id: cb, obj: callBackObject });
        });
        callbackOnComplete.forEach(({ cb }) => {
          cb(callBackObject);
        });
      });
      return;
    }
    callback2.forEach(({ cb, frame }, index) => {
      modules_exports.useFrameIndex(() => {
        if (stagger.waitComplete) {
          if (index === slowlestStagger.index) {
            cb(callBackObject);
            onComplete2();
          }
          return;
        }
        if (index === fastestStagger.index) {
          cb(callBackObject);
          onComplete2();
        }
      }, frame);
    });
    callbackCache.forEach(({ cb, frame }, index) => {
      modules_exports.useFrameIndex(() => {
        if (stagger.waitComplete) {
          if (index === slowlestStagger.index) {
            modules_exports.useCache.fireObject({
              id: cb,
              obj: callBackObject
            });
            onComplete2();
          }
          return;
        }
        if (index === fastestStagger.index) {
          modules_exports.useCache.fireObject({ id: cb, obj: callBackObject });
          onComplete2();
        }
      }, frame);
    });
    callbackOnComplete.forEach(({ cb, frame }) => {
      modules_exports.useFrameIndex(() => {
        cb(callBackObject);
      }, frame + 1);
    });
  };

  // src/js/mob/mob-motion/animation/utils/callbacks/call-back-store.js
  var callBackStore = modules_exports.createStore({ id: 0 });

  // src/js/mob/mob-motion/animation/utils/callbacks/set-callback.js
  var updateSubScribers = (currentCallback, arrayOfCallback) => {
    const { id } = callBackStore.get();
    const arrayOfCallbackUpdated = [
      ...arrayOfCallback,
      { cb: currentCallback, id, index: -1, frame: -1 }
    ];
    const prevId = id;
    callBackStore.quickSetProp("id", id + 1);
    return {
      arrayOfCallbackUpdated,
      unsubscribeCb: (arrayOfCallback2) => arrayOfCallback2.map(({ id: id2, cb, index, frame }) => {
        if (id2 === prevId) cb = () => {
        };
        return { id: id2, cb, index, frame };
      })
    };
  };
  var updateSubscribersCache = (item, currentCallback, arrayOfCallback, unsubscribeCacheArray) => {
    const { id } = callBackStore.get();
    const { id: cacheId, unsubscribe: unsubscribe3 } = modules_exports.useCache.add(
      item,
      currentCallback
    );
    const arrayOfCallbackUpdated = [
      ...arrayOfCallback,
      { cb: cacheId, id, index: -1, frame: -1 }
    ];
    unsubscribeCacheArray.push(unsubscribe3);
    const prevId = id;
    callBackStore.quickSetProp("id", id + 1);
    return {
      arrayOfCallbackUpdated,
      unsubscribeCache: unsubscribeCacheArray,
      unsubscribeCb: (arrayOfCallback2) => {
        unsubscribe3();
        return arrayOfCallback2.map(({ id: id2, cb, index, frame }) => {
          if (id2 === prevId) cb = "";
          return { id: id2, cb, index, frame };
        });
      }
    };
  };

  // src/js/mob/mob-motion/animation/utils/tween-action/actions.js
  var parseGoToObject = (obj) => {
    return Object.keys(obj).map((item) => {
      if (!dataTweenValueIsValid(obj[item])) {
        dataTweenValueIsNotValidWarning(`${item}: ${obj[item]}`);
        return {
          prop: item,
          toValue: 0,
          toFn: () => 0,
          toIsFn: false,
          settled: false
        };
      }
      const toValue = modules_exports.checkType(Number, obj[item]) ? obj[item] : (
        // @ts-ignore
        obj[item]?.() ?? 0
      );
      return {
        prop: item,
        toValue,
        toFn: (
          /** @type{() => number} */
          obj[item]
        ),
        toIsFn: modules_exports.checkType(Function, obj[item]),
        settled: false
      };
    });
  };
  var parseGoFromObject = (obj) => {
    return Object.keys(obj).map((item) => {
      if (!dataTweenValueIsValid(obj[item])) {
        dataTweenValueIsNotValidWarning(`${item}: ${obj[item]}`);
        return {
          prop: item,
          fromValue: 0,
          currentValue: 0,
          fromFn: () => 0,
          fromIsFn: false,
          settled: false
        };
      }
      const value = modules_exports.checkType(Number, obj[item]) ? obj[item] : (
        // @ts-ignore
        obj[item]?.() ?? 0
      );
      return {
        prop: item,
        fromValue: value,
        currentValue: value,
        fromFn: (
          /** @type{() => number} */
          obj[item]
        ),
        fromIsFn: modules_exports.checkType(Function, obj[item]),
        settled: false
      };
    });
  };
  var parseGoFromToObject = (fromObj, toObj) => {
    return Object.keys(fromObj).map((item) => {
      if (!dataTweenValueIsValid(toObj[item]) || !dataTweenValueIsValid(fromObj[item])) {
        dataTweenValueIsNotValidWarning(
          `${item}: ${toObj[item]} || ${item}: ${fromObj[item]}`
        );
        return {
          prop: item,
          fromValue: 0,
          fromFn: () => 0,
          fromIsFn: false,
          currentValue: 0,
          toValue: 0,
          toFn: () => 0,
          toIsFn: false,
          settled: false
        };
      }
      const fromValue = modules_exports.checkType(Number, fromObj[item]) ? fromObj[item] : (
        // @ts-ignore
        fromObj[item]?.() ?? 0
      );
      const toValue = modules_exports.checkType(Number, toObj[item]) ? toObj[item] : (
        // @ts-ignore
        toObj[item]?.() ?? 0
      );
      return {
        prop: item,
        fromValue,
        fromFn: (
          /** @type{() => number} */
          fromObj[item]
        ),
        fromIsFn: modules_exports.checkType(Function, fromObj[item]),
        currentValue: fromValue,
        toValue,
        toFn: (
          /** @type{() => number} */
          toObj[item]
        ),
        toIsFn: modules_exports.checkType(Function, toObj[item]),
        settled: false
      };
    });
  };
  var parseSetObject = (obj) => {
    return Object.keys(obj).map((item) => {
      if (!dataTweenValueIsValid(obj[item])) {
        dataTweenValueIsNotValidWarning(`${item}: ${obj[item]}`);
        return {
          prop: item,
          fromValue: 0,
          fromFn: () => 0,
          fromIsFn: false,
          currentValue: 0,
          toValue: 0,
          toFn: () => 0,
          toIsFn: false,
          settled: false
        };
      }
      const value = modules_exports.checkType(Number, obj[item]) ? obj[item] : (
        // @ts-ignore
        obj[item]?.() ?? 0
      );
      return {
        prop: item,
        fromValue: value,
        fromFn: (
          /** @type{() => number} */
          obj[item]
        ),
        fromIsFn: modules_exports.checkType(Function, obj[item]),
        currentValue: value,
        toValue: value,
        toFn: (
          /** @type{() => number} */
          obj[item]
        ),
        toIsFn: modules_exports.checkType(Function, obj[item]),
        settled: false
      };
    });
  };

  // src/js/mob/mob-motion/animation/utils/init-raf.js
  var initRaf = ({ validationFunction, defaultRafInit }) => {
    modules_exports.useFrame(() => {
      modules_exports.useNextTick(({ time: time2, fps: fps2 }) => {
        const result = validationFunction.findLast(
          ({ validation }) => validation()
        );
        defaultRafInit(time2, fps2);
        if (result) {
          result?.callback();
          console.log("custom tween run function extrecuted");
          return;
        }
      });
    });
  };

  // src/js/mob/mob-motion/animation/utils/fps-log-inizialization.js
  var fpsLoadedLog = (label, fps2) => {
    console.log(`stagger on ${label} loaded at: ${fps2} fps`);
  };

  // src/js/mob/mob-motion/animation/utils/stagger/should-inizialize.js
  var shouldInizializzeStagger = (each, firstRun, arrayToCompare1, arrayToCompare2) => {
    if (!modules_exports.checkType(Number, each)) {
      staggerEachWarning();
    }
    return each > 0 && firstRun && (arrayToCompare1.length > 0 || arrayToCompare2.length > 0);
  };

  // src/js/mob/mob-motion/animation/utils/resume-tween.js
  var resume = (rafFunction) => {
    modules_exports.useFrame(() => {
      modules_exports.useNextTick(({ time: time2, fps: fps2 }) => {
        rafFunction(time2, fps2);
      });
    });
  };

  // src/js/mob/mob-motion/animation/utils/tween-action/get-values.js
  var getValueObj = (arr, key) => {
    return arr.map((item) => ({ [item["prop"]]: Number.parseFloat(item[key]) })).reduce((p, c) => ({ ...p, ...c }), {});
  };
  var getValueObjToNative = (arr) => {
    return arr.map((item) => {
      return item.toIsFn ? { [item.prop]: item.toFn } : { [item.prop]: Number.parseFloat(item.toValue) };
    }).reduce((p, c) => ({ ...p, ...c }), {});
  };
  var getValueObjFromNative = (arr) => {
    return arr.map((item) => {
      return item.fromIsFn ? { [item.prop]: item.fromFn } : { [item.prop]: Number.parseFloat(item.fromValue) };
    }).reduce((p, c) => ({ ...p, ...c }), {});
  };

  // src/js/mob/mob-motion/animation/utils/tween-action/merge-array.js
  var mergeArray = (newData, data) => {
    return data.map((item) => {
      const itemToMerge = newData.find((newItem) => {
        return newItem.prop === item.prop;
      });
      return itemToMerge ? { ...item, ...itemToMerge } : item;
    });
  };
  var mergeArrayTween = (newData, data) => {
    return data.map((item) => {
      const itemToMerge = newData.find((newItem) => {
        return newItem.prop === item.prop;
      });
      return itemToMerge ? { ...item, ...itemToMerge, shouldUpdate: true } : { ...item, shouldUpdate: false };
    });
  };

  // src/js/mob/mob-motion/animation/lerp/get-values-on-draw.js
  var lerpGetValuesOnDraw = ({ values, fps: fps2, velocity, precision }) => {
    return values.map((item) => {
      if (item.settled) return item;
      const { currentValue, toValue } = item;
      const lerpValue = lerp(currentValue, toValue, velocity / fps2 * 60);
      const newCurrentValue = getRoundedValue(lerpValue);
      const settled = Number(Math.abs(toValue - newCurrentValue).toFixed(4)) <= precision;
      if (settled) {
        return {
          ...item,
          currentValue: toValue,
          settled: true
        };
      }
      return {
        ...item,
        currentValue: newCurrentValue,
        settled: false
      };
    });
  };

  // src/js/mob/mob-motion/animation/lerp/mob-lerp.js
  var MobLerp = class {
    /**
     * @type {import('../utils/stagger/type.js').StaggerObject}
     */
    #stagger;
    /**
     * @type {boolean}
     */
    #relative;
    /**
     * @type {number}
     */
    #velocity;
    /**
     * @type {number}
     */
    #precision;
    /**
     * @type {string}
     */
    #uniqueId;
    /**
     * @type {boolean}
     */
    #isRunning;
    /**
     * @type{((value:any) => void)|undefined }
     */
    #currentResolve;
    /**
     * @type{((value:any) => void)|undefined}
     */
    #currentReject;
    /**
     * @type {Promise<void> | undefined}
     */
    #currentPromise;
    /**
     * @type {import('./type.js').LerpValues[] | []}
     */
    #values;
    /**
     * @type {import('./type.js').LerpInitialData[]}
     */
    #initialData;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackDefault}
     */
    #callback;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackCache}
     */
    #callbackCache;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackDefault}
     */
    #callbackOnComplete;
    /**
     * @type {{ validation: () => boolean; callback: () => void }[]}
     */
    #externalValidations;
    /**
     * @type {(() => void)[]}
     */
    #unsubscribeCache;
    /**
     * @type {boolean}
     */
    #pauseStatus;
    /**
     * @type {boolean}
     */
    #firstRun;
    /**
     * @type {boolean}
     */
    #useStagger;
    /**
     * @type {boolean}
     */
    #staggerIsFreezed;
    /**
     * @type {boolean}
     */
    #fpsInLoading;
    /**
     * This value is the base value merged with new value in custom prop passed form user in goTo etc..
     *
     * @type {import('./type.js').LerpDefault}
     */
    #defaultProps;
    /**
     * @type {import('../utils/stagger/type.js').StaggerFrameIndexObject}
     */
    #slowlestStagger;
    /**
     * @type {import('../utils/stagger/type.js').StaggerFrameIndexObject}
     */
    #fastestStagger;
    /**
     * Available methods:
     *
     * ```javascript
     * myLerp.set();
     * myLerp.goTo();
     * myLerp.goFrom();
     * myLerp.goFromTo();
     * myLerp.subscribe();
     * myLerp.subscribeCache();
     * myLerp.onComplete();
     * myLerp.updateVelocity();
     * myLerp.updatePrecision();
     * myLerp.getId();
     * myLerp.get();
     * myLerp.getTo();
     * myLerp.getFrom();
     * myLerp.getToNativeType();
     * myLerp.getFromNativeType();
     * ```
     *
     * @example
     *     ```javascript
     *     const myLerp = new MobLerp({
     *       data: Object.<string, number>,
     *       precision: Number,
     *       velocity: Number,
     *       relative: Boolean
     *       stagger:{
     *          each: Number,
     *          from: Number|String|{x:number,y:number},
     *          grid: {
     *              col: Number,
     *              row: Number,
     *              direction: String,
     *          },
     *          waitComplete: Boolean,
     *       },
     *     })
     *
     *
     *     ```;
     *
     * @param {import('./type.js').LerpTweenProps} [data]
     */
    constructor(data) {
      this.#stagger = getStaggerFromProps(data ?? {});
      this.#relative = relativeIsValid(data?.relative, "lerp");
      this.#velocity = lerpVelocityIsValid(data?.velocity);
      this.#precision = lerpPrecisionIsValid(data?.precision);
      this.#uniqueId = modules_exports.getUnivoqueId();
      this.#isRunning = false;
      this.#currentResolve = void 0;
      this.#currentReject = void 0;
      this.#currentPromise = void 0;
      this.#values = [];
      this.#initialData = [];
      this.#callback = [];
      this.#callbackCache = [];
      this.#callbackOnComplete = [];
      this.#externalValidations = [];
      this.#unsubscribeCache = [];
      this.#pauseStatus = false;
      this.#firstRun = true;
      this.#useStagger = true;
      this.#staggerIsFreezed = false;
      this.#fpsInLoading = false;
      this.#defaultProps = {
        reverse: false,
        velocity: this.#velocity,
        precision: this.#precision,
        relative: this.#relative,
        immediate: false
      };
      this.#slowlestStagger = STAGGER_DEFAULT_INDEX_OBJ;
      this.#fastestStagger = STAGGER_DEFAULT_INDEX_OBJ;
      const props = data?.data;
      if (props) this.setData(props);
    }
    /**
     * @param {number} _time
     * @param {number} fps
     * @returns {void}
     */
    #draw(_time, fps2) {
      this.#isRunning = true;
      this.#values = lerpGetValuesOnDraw({
        values: this.#values,
        fps: fps2,
        velocity: this.#velocity,
        precision: this.#precision
      });
      const callBackObject = getValueObj(this.#values, "currentValue");
      if (!this.#pauseStatus) {
        defaultCallback({
          stagger: this.#stagger,
          callback: this.#callback,
          callbackCache: this.#callbackCache,
          callBackObject,
          useStagger: this.#useStagger
        });
      }
      const allSettled = this.#values.every((item) => item.settled === true);
      if (allSettled) {
        const onComplete2 = () => {
          this.#isRunning = false;
          this.#values = [...this.#values].map((item) => {
            return { ...item, fromValue: item.toValue };
          });
          this.#currentResolve?.(true);
          this.#currentPromise = void 0;
          this.#currentReject = void 0;
          this.#currentResolve = void 0;
          this.#pauseStatus = false;
          this.#isRunning = false;
        };
        const cbObjectSettled = getValueObj(this.#values, "toValue");
        defaultCallbackOnComplete({
          onComplete: onComplete2,
          callback: this.#callback,
          callbackCache: this.#callbackCache,
          callbackOnComplete: this.#callbackOnComplete,
          callBackObject: cbObjectSettled,
          stagger: this.#stagger,
          slowlestStagger: this.#slowlestStagger,
          fastestStagger: this.#fastestStagger,
          useStagger: this.#useStagger
        });
        return;
      }
      modules_exports.useFrame(() => {
        modules_exports.useNextTick(({ time: time2, fps: fps3 }) => {
          if (this.#isRunning) this.#draw(time2, fps3);
        });
      });
    }
    /**
     * @param {number} time Current global time
     * @param {number} fps Current FPS
     */
    #onReuqestAnim(time2, fps2) {
      this.#draw(time2, fps2);
    }
    /**
     * Inzialize stagger array
     *
     * @returns {Promise<any>}
     */
    async #inzializeStagger() {
      if (shouldInizializzeStagger(
        this.#stagger.each,
        this.#firstRun,
        this.#callbackCache,
        this.#callback
      )) {
        const { averageFPS } = await modules_exports.useFps();
        fpsLoadedLog("lerp", averageFPS);
        const cb = getStaggerArray(this.#callbackCache, this.#callback);
        if (this.#stagger.grid.col > cb.length) {
          staggerIsOutOfRangeWarning(cb.length);
          this.#firstRun = false;
          return;
        }
        const {
          staggerArray,
          staggerArrayOnComplete,
          fastestStagger,
          slowlestStagger
        } = setStagger({
          arrayDefault: cb,
          arrayOnStop: this.#callbackOnComplete,
          stagger: this.#stagger,
          slowlestStagger: this.#slowlestStagger,
          fastestStagger: this.#fastestStagger
        });
        if (this.#callbackCache.length > this.#callback.length) {
          this.#callbackCache = /** @type {import('../utils/callbacks/type.js').CallbackCache} */
          staggerArray;
        } else {
          this.#callback = /** @type {import('../utils/callbacks/type.js').CallbackDefault} */
          staggerArray;
        }
        this.#callbackOnComplete = staggerArrayOnComplete;
        this.#slowlestStagger = slowlestStagger;
        this.#fastestStagger = fastestStagger;
        this.#firstRun = false;
      }
      return { ready: true };
    }
    /**
     * @param {(arg0: any) => void} resolve
     * @param {(value: any) => void} reject
     * @returns {Promise<any>}
     */
    async #startRaf(resolve, reject) {
      if (this.#fpsInLoading) return;
      this.#currentResolve = resolve;
      this.#currentReject = reject;
      if (this.#firstRun) {
        this.#fpsInLoading = true;
        await this.#inzializeStagger();
        this.#fpsInLoading = false;
      }
      initRaf({
        validationFunction: this.#externalValidations,
        defaultRafInit: (time2, fps2) => this.#onReuqestAnim(time2, fps2)
      });
    }
    /**
     * AsyncTimeline utils.
     *
     * - We perform a Promise.reject() of the tween. We are sure that the tween can start with a new promise to resolve.
     *   If in a Promise.race(), a tween continues because it is slower and risks not resolving its promise, we force
     *   manual cleanup. Importantly, this must not happen when the tween is paused—forcing the this.#isRunning
     *   parameter could interfere with the pause mechanism.
     *
     * @returns {void}
     */
    clearCurretPromise() {
      if (!this.#pauseStatus) {
        this.#currentReject?.(modules_exports.ANIMATION_STOP_REJECT);
        this.#currentPromise = void 0;
        this.#currentReject = void 0;
        this.#currentResolve = void 0;
        this.#isRunning = false;
      }
    }
    /**
     * @type {import('./type.js').LerpStop}
     */
    stop({ clearCache = true, updateValues = true } = {}) {
      if (this.#pauseStatus) this.#pauseStatus = false;
      if (updateValues) this.#values = setFromToByCurrent(this.#values);
      this.unFreezeStagger();
      if (clearCache)
        this.#callbackCache.forEach(({ cb }) => modules_exports.useCache.clean(cb));
      if (this.#currentReject) {
        this.#currentReject(modules_exports.ANIMATION_STOP_REJECT);
        this.#currentPromise = void 0;
        this.#currentReject = void 0;
        this.#currentResolve = void 0;
      }
      this.#isRunning = false;
    }
    /**
     * @returns {void}
     */
    freezeStagger() {
      if (this.#staggerIsFreezed) return;
      this.#callbackCache.forEach(({ cb }) => modules_exports.useCache.freeze(cb));
      this.#staggerIsFreezed = true;
    }
    /**
     * @param {object} [params]
     * @param {boolean} [params.updateFrame]
     * @returns {void}
     */
    unFreezeStagger({ updateFrame = true } = {}) {
      if (!this.#staggerIsFreezed) return;
      this.#callbackCache.forEach(
        ({ cb }) => modules_exports.useCache.unFreeze({ id: cb, update: updateFrame })
      );
      this.#staggerIsFreezed = false;
    }
    /**
     * @type {import('./type.js').LerpPause}
     */
    pause() {
      if (this.#pauseStatus) return;
      this.#pauseStatus = true;
      this.#isRunning = false;
      this.#values = setFromByCurrent(this.#values);
      this.freezeStagger();
    }
    /**
     * @type {import('./type.js').LerpResume}
     */
    resume() {
      if (!this.#pauseStatus) return;
      this.#pauseStatus = false;
      this.unFreezeStagger();
      if (!this.#isRunning && this.#currentResolve) {
        resume((time2, fps2) => this.#onReuqestAnim(time2, fps2));
      }
    }
    /**
     * Set initial data structure, the method is call by data prop in constructor. In case of need it can be called
     * after creating the instance
     *
     * @type {import('../../utils/type.js').SetData}
     */
    setData(obj) {
      this.#values = Object.entries(obj).map((item) => {
        const [prop, value] = item;
        return {
          prop,
          toValue: value,
          fromValue: value,
          currentValue: value,
          fromFn: () => 0,
          fromIsFn: false,
          toFn: () => 0,
          toIsFn: false,
          settled: false
        };
      });
      this.#initialData = this.#values.map((item) => {
        return {
          prop: item.prop,
          toValue: item.toValue,
          fromValue: item.fromValue,
          currentValue: item.currentValue,
          fromFn: () => 0,
          fromIsFn: false,
          toFn: () => 0,
          toIsFn: false,
          settled: false
        };
      });
    }
    /**
     * @type {import('./type.js').LerpResetData}
     */
    resetData() {
      this.#values = mergeDeep(this.#values, this.#initialData);
    }
    /**
     * @type {import('./type.js').LerpMergeProps}
     */
    #mergeProps(props) {
      const newProps = { ...this.#defaultProps, ...props };
      const { velocity, precision, relative } = newProps;
      this.#relative = relativeIsValid(relative, "lerp");
      this.#velocity = lerpVelocityIsValid(velocity);
      this.#precision = lerpPrecisionIsValid(precision);
      return newProps;
    }
    /**
     * @type {import('../../utils/type.js').GoTo<import('./type.js').LerpActions>} obj To Values
     */
    goTo(toObject, spacialProps = {}) {
      if (this.#pauseStatus)
        return Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
      this.#useStagger = true;
      const toObjectparsed = parseGoToObject(toObject);
      return this.#doAction(toObjectparsed, toObject, spacialProps);
    }
    /**
     * @type {import('../../utils/type.js').GoFrom<import('./type.js').LerpActions>} obj To Values
     */
    goFrom(fromObject, specialProps = {}) {
      if (this.#pauseStatus)
        return Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
      this.#useStagger = true;
      const fromObjectParsed = parseGoFromObject(fromObject);
      return this.#doAction(fromObjectParsed, fromObject, specialProps);
    }
    /**
     * @type {import('../../utils/type.js').GoFromTo<import('./type.js').LerpActions>} obj To Values
     */
    goFromTo(fromObject, toObject, specialProps = {}) {
      if (this.#pauseStatus)
        return Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
      this.#useStagger = true;
      if (!compareKeys(fromObject, toObject)) {
        compareKeysWarning("lerp goFromTo:", fromObject, toObject);
        return new Promise((resolve) => resolve);
      }
      const objectParsed = parseGoFromToObject(fromObject, toObject);
      return this.#doAction(objectParsed, fromObject, specialProps);
    }
    /**
     * @type {import('../../utils/type.js').Set<import('./type.js').LerpActions>} obj To Values
     */
    set(setObject, specialProps = {}) {
      if (this.#pauseStatus)
        return Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
      this.#useStagger = false;
      const setObjectParsed = parseSetObject(setObject);
      return this.#doAction(setObjectParsed, setObject, specialProps);
    }
    /**
     * @type {import('../../utils/type.js').SetImmediate<import('./type.js').LerpActions>} obj To Values
     */
    setImmediate(setObject, specialProps = {}) {
      if (this.#isRunning)
        this.stop({ clearCache: false, updateValues: false });
      if (this.#pauseStatus) return;
      this.#useStagger = false;
      const setObjectParsed = parseSetObject(setObject);
      this.#values = mergeArray(setObjectParsed, this.#values);
      const { reverse } = this.#mergeProps(specialProps ?? {});
      if (valueIsBooleanAndTrue(reverse, "reverse"))
        this.#values = setReverseValues(setObject, this.#values);
      this.#values = setRelative(this.#values, this.#relative);
      this.#values = setFromCurrentByTo(this.#values);
      return;
    }
    /**
     * @type {import('../../utils/type.js').DoAction<import('./type.js').LerpActions>} obj To Values
     */
    #doAction(newObjectparsed, newObjectRaw, spacialProps = {}) {
      this.#values = mergeArray(newObjectparsed, this.#values);
      const { reverse, immediate } = this.#mergeProps(spacialProps ?? {});
      if (valueIsBooleanAndTrue(reverse, "reverse"))
        this.#values = setReverseValues(newObjectRaw, this.#values);
      this.#values = setRelative(this.#values, this.#relative);
      if (valueIsBooleanAndTrue(immediate, "immediate ")) {
        if (this.#isRunning) this.stop({ updateValues: false });
        this.#values = setFromCurrentByTo(this.#values);
        return Promise.resolve();
      }
      const shouldInitializeRAF = !this.#isRunning && !this.#currentPromise;
      if (shouldInitializeRAF) {
        this.#currentPromise = new Promise((resolve, reject) => {
          this.#startRaf(resolve, reject);
        });
      }
      return shouldInitializeRAF && this.#currentPromise ? this.#currentPromise : Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
    }
    /**
     * Get current values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myLerp.get();
     *     ```;
     *
     * @type {import('./type.js').LerpGetValue}
     */
    get() {
      return getValueObj(this.#values, "currentValue");
    }
    /**
     * Get initial values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myLerp.getIntialData();
     *     ```;
     *
     * @type {import('./type.js').LerpGetValue}
     */
    getInitialData() {
      return getValueObj(this.#initialData, "currentValue");
    }
    /**
     * Get from values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myLerp.getFrom();
     *     ```;
     *
     * @type {import('./type.js').LerpGetValue}
     */
    getFrom() {
      return getValueObj(this.#values, "fromValue");
    }
    /**
     * Get to values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myLerp.getTo();
     *     ```;
     *
     * @type {import('./type.js').LerpGetValue}
     */
    getTo() {
      return getValueObj(this.#values, "toValue");
    }
    /**
     * Get From values, if the single value is a function it returns the same function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myLerp.getFromNativeType();
     *     ```;
     *
     * @type {import('./type.js').LerpGetValueNative}
     */
    getFromNativeType() {
      return getValueObjFromNative(this.#values);
    }
    /**
     * Get To values, if the single value is a function it returns the same function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myLerp.getToNativeType();
     *     ```;
     *
     * @type {import('./type.js').LerpGetValueNative}
     */
    getToNativeType() {
      return getValueObjToNative(this.#values);
    }
    /**
     * Get tween type
     *
     * @example
     *     ```javascript
     *
     *
     *     const type = myLerp.getType();
     *     ```;
     *
     * @type {import('./type.js').LerpGetType} tween Type
     */
    getType() {
      return "LERP";
    }
    /**
     * Get univoque Id
     *
     * @example
     *     ```javascript
     *
     *
     *     const type = myLerp.getId();
     *     ```;
     *
     * @type {import('./type.js').LerpGetId}
     */
    getId() {
      return this.#uniqueId;
    }
    /**
     * Return active state.
     *
     * @returns {boolean}
     */
    isActive() {
      return this.#isRunning;
    }
    /**
     * Update velocity value. `default value is 0.06`,the closer the value is to 1, the faster the transition will be.
     * The change will be persistent
     *
     * @example
     *     ```javascript
     *     myLerp.updateVelocity(0.1)
     *
     *
     *     ```;
     *
     * @type {import('./type.js').LerpUpdateVelocity}
     */
    updateVelocity(velocity) {
      this.#velocity = lerpVelocityIsValid(velocity);
      this.#defaultProps = mergeDeep(this.#defaultProps, {
        velocity: this.#velocity
      });
    }
    /**
     * Update precision value. When the calculated value is less than this number, the transition will be considered
     * completed, the smaller the value, the greater the precision of the calculation, the `default value is 0.01`. The
     * change will be persistent
     *
     * @example
     *     ```javascript
     *     myLerp.updatePrecision(0.5)
     *
     *
     *     ```;
     *
     * @type {import('./type.js').LerpUpdatePrecision}
     */
    updatePrecision(precision) {
      this.#velocity = lerpPrecisionIsValid(precision);
      this.#defaultProps = mergeDeep(this.#defaultProps, {
        precision: this.#precision
      });
    }
    /**
     * Callback that returns updated values ready to be usable, it is advisable to use it for single elements, although
     * it works well on a not too large number of elements (approximately 100-200 elements) for large staggers it is
     * advisable to use the subscribeCache method .
     *
     * @type {import('./type.js').LerpSubscribe}
     */
    subscribe(cb) {
      const { arrayOfCallbackUpdated, unsubscribeCb } = updateSubScribers(
        cb,
        this.#callback
      );
      this.#callback = arrayOfCallbackUpdated;
      return () => this.#callback = unsubscribeCb(this.#callback);
    }
    /**
     * Callback that returns updated values ready to be usable, specific to manage large staggers.
     *
     * @type {import('./type.js').LerpSubscribeCache}
     */
    subscribeCache(item, fn) {
      const { arrayOfCallbackUpdated, unsubscribeCb, unsubscribeCache } = updateSubscribersCache(
        item,
        fn,
        this.#callbackCache,
        this.#unsubscribeCache
      );
      this.#callbackCache = arrayOfCallbackUpdated;
      this.#unsubscribeCache = unsubscribeCache;
      return () => this.#callbackCache = unsubscribeCb(this.#callbackCache);
    }
    /**
     * Support callback to asyncTimeline. Callback to manage the departure of tweens in a timeline. If a delay is
     * applied to the tween and before the delay ends the timeline pauses the tween at the end of the delay will
     * automatically pause. Add callback to start in pause to stack
     *
     * @param {object} params
     * @param {() => boolean} params.validation
     * @param {() => void} params.callback
     * @returns {() => void}
     */
    validateInitialization({ validation, callback: callback2 }) {
      const valuesUpdated = [
        ...this.#externalValidations,
        { validation, callback: callback2 }
      ];
      this.#externalValidations = valuesUpdated;
      return () => this.#externalValidations = [];
    }
    /**
     * Similar to subscribe this callBack is launched when the data calculation stops (when the timeline ends or the
     * scroll trigger is inactive). Useful for applying a different style to an inactive element. A typical example is
     * to remove the teansform3D property:
     *
     * @type {import('./type.js').LerpOnComplete}
     */
    onComplete(cb) {
      const { arrayOfCallbackUpdated, unsubscribeCb } = updateSubScribers(
        cb,
        this.#callbackOnComplete
      );
      this.#callbackOnComplete = arrayOfCallbackUpdated;
      return () => this.#callbackOnComplete = unsubscribeCb(
        this.#callbackOnComplete
      );
    }
    /**
     * Destroy tween
     */
    destroy() {
      if (this.#currentPromise) this.stop();
      this.#callbackOnComplete = [];
      this.#externalValidations = [];
      this.#callback = [];
      this.#callbackCache = [];
      this.#values = [];
      this.#currentPromise = void 0;
      this.#unsubscribeCache.forEach((unsubscribe3) => unsubscribe3());
      this.#unsubscribeCache = [];
    }
  };

  // src/js/mob/mob-motion/animation/utils/callbacks/sync-callback.js
  var syncCallback = ({
    each,
    useStagger,
    isLastDraw,
    callBackObject,
    callback: callback2,
    callbackCache,
    callbackOnStop
  }) => {
    if (each === 0 || useStagger === false) {
      modules_exports.useFrame(() => {
        callback2.forEach(({ cb }) => cb(callBackObject));
      });
      modules_exports.useFrame(() => {
        callbackCache.forEach(({ cb }) => {
          modules_exports.useCache.fireObject({ id: cb, obj: callBackObject });
        });
      });
    } else {
      callback2.forEach(({ cb, frame }) => {
        modules_exports.useFrameIndex(() => cb(callBackObject), frame);
      });
      callbackCache.forEach(({ cb, frame }) => {
        modules_exports.useCache.update({ id: cb, callBackObject, frame });
      });
    }
    if (isLastDraw) {
      if (each === 0 || useStagger === false) {
        modules_exports.useFrame(() => {
          callbackOnStop.forEach(({ cb }) => cb(callBackObject));
        });
      } else {
        callbackOnStop.forEach(({ cb, frame }) => {
          modules_exports.useFrameIndex(() => cb(callBackObject), frame + 1);
        });
      }
    }
  };

  // src/js/mob/mob-motion/animation/scroller/mob-scroller-tween.js
  var MobScrollerTween = class {
    /**
     * @type {Function}
     */
    #ease;
    /**
     * @type {number}
     */
    #duration;
    /**
     * @type {import('../utils/stagger/type.js').StaggerObject}
     */
    #stagger;
    /**
     * @type {import('./type.js').MobScrollerTweenValue[]}
     */
    #values;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackDefault}
     */
    #callbackOnStop;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackDefault}
     */
    #callback;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackCache}
     */
    #callbackCache;
    /**
     * @type {(() => void)[]}
     */
    #unsubscribeCache;
    /**
     * @type {string}
     */
    #type;
    /**
     * Simplified tween specific to be used with scrollTrigger as an alternative to the more complex sequencer,
     * ParallaxTween requires only one mutation step (from / to).
     *
     * Available methods:
     *
     * ```js
     * myParallaxTween.subscribe();
     * myParallaxTween.subscribeCache();
     * myParallaxTween.onStop();
     * ```
     *
     * @example
     *     ```js
     *     const myParallaxTween = new MobScrollerTween({
     *       from: Object.<string, number>,
     *       to: Object.<string, number>,
     *       ease: [ String ],
     *       stagger:{
     *          each: [ Number ],
     *          from: [ Number|String|{x:number,y:number} ],
     *          grid: {
     *              col: [ Number ],
     *              row: [ Number ],
     *              direction: [ String ]
     *          },
     *       },
     *     })
     *
     *
     *     ```;
     *
     * @param {import('./type.js').MobScrollerTween} data
     */
    constructor(data) {
      this.#ease = easeScrollerTweenIsValid(data?.ease);
      this.#duration = durationIsValid(data?.duration);
      this.#stagger = getStaggerFromProps(data);
      this.#values = [];
      this.#callbackOnStop = [];
      this.#callback = [];
      this.#callbackCache = [];
      this.#unsubscribeCache = [];
      this.#type = "parallaxTween";
      const props = data?.from || null;
      if (props) this.setData(props);
      if (data?.to) {
        this.goTo(data.to);
      }
    }
    /**
     * Inzialize stagger array
     *
     * @returns {void}
     */
    inzializeStagger() {
      if (this.#stagger.each > 0 && (this.#callbackCache.length > 0 || this.#callback.length > 0)) {
        const cb = getStaggerArray(this.#callbackCache, this.#callback);
        if (this.#stagger.grid.col > cb.length) {
          staggerIsOutOfRangeWarning(cb.length);
          return;
        }
        const { staggerArray, staggerArrayOnComplete } = setStagger({
          arrayDefault: cb,
          arrayOnStop: this.#callbackOnStop,
          stagger: this.#stagger,
          slowlestStagger: STAGGER_DEFAULT_INDEX_OBJ,
          //sequencer doesn't support fastestStagger
          fastestStagger: STAGGER_DEFAULT_INDEX_OBJ
          //sequencer doesn't support fastestStagger
        });
        if (this.#callbackCache.length > this.#callback.length) {
          this.#callbackCache = /** @type {import('../utils/callbacks/type.js').CallbackCache} */
          staggerArray;
        } else {
          this.#callback = /** @type {import('../utils/callbacks/type.js').CallbackDefault} */
          staggerArray;
        }
        this.#callbackOnStop = staggerArrayOnComplete;
      }
    }
    /**
     * @example
     *     ```js
     *     myParallaxTween.draw(
     *          partial: 200,
     *          isLastDraw: true,
     *     );
     *
     *
     *     ```;
     *
     * @param {object} obj
     * @param {number} obj.partial - Render at specific partial between 0 and duration
     * @param {boolean} obj.isLastDraw - Use the callback defined by the onStop method
     * @param {boolean} obj.isLastDraw - Compatibiliey with sequencer for Parallxx
     * @param {boolean} obj.useFrame - Compatibiliey with sequencer for Parallxx
     */
    draw({ partial, isLastDraw }) {
      this.#values = [...this.#values].map((item) => {
        const { toIsFn, toFn, toValue, fromIsFn, fromFn, fromValue } = item;
        const toValueParsed = toIsFn ? toFn() : toValue;
        const fromValueParsed = fromIsFn ? fromFn() : fromValue;
        const toValFinal = toValueParsed - fromValueParsed;
        const currentValue = this.#ease(
          partial,
          fromValueParsed,
          toValFinal,
          this.#duration
        );
        return {
          ...item,
          currentValue: getRoundedValue(currentValue)
        };
      });
      const callBackObject = getValueObj(this.#values, "currentValue");
      modules_exports.useNextTick(() => {
        syncCallback({
          each: this.#stagger.each,
          useStagger: true,
          isLastDraw,
          callBackObject,
          callback: this.#callback,
          callbackCache: this.#callbackCache,
          callbackOnStop: this.#callbackOnStop
        });
      });
    }
    /**
     * @type {import('./type.js').MobScrollerTweenSetData}
     */
    setData(obj) {
      const valToArray = Object.entries(obj);
      this.#values = valToArray.map((item) => {
        const [prop, value] = item;
        return {
          prop,
          toValue: value,
          toValProcessed: value,
          fromValue: value,
          currentValue: value,
          settled: false,
          /**
           * Only for type check.
           */
          fromFn: () => 0,
          toFn: () => 0
        };
      });
      return this;
    }
    /**
     * Return the new array maeged with main array created in setData
     *
     * @param {import('../utils/tween-action/type.js').GoToParamsType[]} newData New datato merge
     * @returns {void}
     */
    #mergeData(newData) {
      this.#values = this.#values.map((item) => {
        const itemToMerge = newData.find((newItem) => {
          return newItem.prop === item.prop;
        });
        return itemToMerge ? { ...item, ...itemToMerge } : { ...item };
      });
    }
    /**
     * Transform some properties of your choice from the `current value` to the `entered value`. The target value can be
     * a number or a function that returns a number, when using a function the target value will become dynamic and will
     * change in real time as the result of the function changes
     *
     * @type {import('./type.js').MobScrollerTweenGoTo}
     */
    goTo(obj) {
      const data = parseGoToObject(obj);
      this.#mergeData(data);
      return this;
    }
    /**
     * Callback that returns updated values ready to be usable, it is advisable to use it for single elements, although
     * it works well on a not too large number of elements (approximately 100-200 elements) for large staggers it is
     * advisable to use the subscribeCache method .
     *
     * @type {import('./type.js').MobScrollerTweenSubscribe}
     */
    subscribe(cb) {
      const { arrayOfCallbackUpdated, unsubscribeCb } = updateSubScribers(
        cb,
        this.#callback
      );
      this.#callback = arrayOfCallbackUpdated;
      return () => this.#callback = unsubscribeCb(this.#callback);
    }
    /**
     * Similar to subscribe this callBack is launched when the data calculation stops (when the timeline ends or the
     * scroll trigger is inactive). Useful for applying a different style to an inactive element. A typical example is
     * to remove the teansform3D property:
     *
     * @type {import('./type.js').MobScrollerTweenOnStop}
     */
    onStop(cb) {
      const { arrayOfCallbackUpdated, unsubscribeCb } = updateSubScribers(
        cb,
        this.#callbackOnStop
      );
      this.#callbackOnStop = arrayOfCallbackUpdated;
      return () => this.#callbackOnStop = unsubscribeCb(this.#callbackOnStop);
    }
    /**
     * @type {import('./type.js').MobScrollerTweenSubscribeCache}
     */
    subscribeCache(item, fn) {
      const { arrayOfCallbackUpdated, unsubscribeCb, unsubscribeCache } = updateSubscribersCache(
        item,
        fn,
        this.#callbackCache,
        this.#unsubscribeCache
      );
      this.#callbackCache = arrayOfCallbackUpdated;
      this.#unsubscribeCache = unsubscribeCache;
      return () => this.#callbackCache = unsubscribeCb(this.#callbackCache);
    }
    /**
     * Get duration
     *
     * @type {import('./type.js').MobScrollerTweenGetDuration}
     */
    getDuration() {
      return this.#duration;
    }
    /**
     * Get tween type - 'parallaxTween'
     *
     * @type {import('./type.js').MobScrollerTweenGet}
     */
    getType() {
      return this.#type;
    }
    /**
     * Destroy sequencer
     *
     * @type {() => void}
     */
    destroy() {
      this.#values = [];
      this.#callbackOnStop = [];
      this.#callback = [];
      this.#callbackCache = [];
      this.#unsubscribeCache.forEach((unsubscribe3) => unsubscribe3());
      this.#unsubscribeCache = [];
    }
  };

  // src/js/mob/mob-motion/animation/sequencer/mob-master-sequencer.js
  var MobMasterSequencer = class {
    /**
     * @trype {string}
     */
    #type;
    /**
     * @type {import('./type').MasterSequencerItem[]}
     */
    #children;
    constructor() {
      this.#type = "sequencer";
      this.#children = [];
    }
    /**
     * @param {object} obj
     * @param {number} obj.partial
     * @param {boolean} obj.isLastDraw
     * @param {boolean} obj.useFrame
     * @returns {void}
     */
    draw({ partial, isLastDraw, useFrame: useFrame2 }) {
      this.#children.forEach((item) => {
        item.draw({ partial, isLastDraw, useFrame: useFrame2 });
      });
    }
    /**
     * @param {import('./type').MasterSequencerItem} item
     * @returns {void}
     */
    add(item) {
      this.#children.push(item);
    }
    /**
     * @returns {void}
     */
    inzializeStagger() {
      this.#children.forEach((item) => {
        item.inzializeStagger();
      });
    }
    /**
     * @param {number} val
     * @returns {void}
     */
    setDuration(val2) {
      this.#children.forEach((item) => {
        item.setDuration(val2);
      });
    }
    /**
     * @returns {number}
     */
    getDuration() {
      return this.#children.length > 0 ? this.#children[0].getDuration() : 0;
    }
    /**
     * @param {number} val
     * @returns {void}
     */
    setStretchFactor(val2) {
      this.#children.forEach((item) => {
        item.setStretchFactor(val2);
      });
    }
    /**
     * @returns {import('./type').LabelType[]}
     */
    getLabels() {
      return this.#children.flatMap((item) => item.getLabels());
    }
    /**
     * @returns {void}
     */
    resetLastValue() {
      this.#children.forEach((item) => item.resetLastValue());
    }
    /**
     * @returns {void}
     */
    disableStagger() {
      this.#children.forEach((item) => {
        item.disableStagger();
      });
    }
    /**
     * @returns {void}
     */
    cleanCachedId() {
      this.#children.forEach((item) => {
        item.cleanCachedId();
      });
    }
    /**
     * @returns {void}
     */
    freezeCachedId() {
      this.#children.forEach((item) => {
        item.freezeCachedId();
      });
    }
    /**
     * @returns {void}
     */
    unFreezeCachedId() {
      this.#children.forEach((item) => {
        item.unFreezeCachedId();
      });
    }
    /**
     * @returns {string}
     */
    getType() {
      return this.#type;
    }
    /**
     * @returns {void}
     */
    destroy() {
      this.#children.forEach((item) => {
        item.destroy();
      });
      this.#children = [];
    }
  };

  // src/js/mob/mob-motion/animation/sequencer/sync-actions.js
  var goToSyncUtils = (obj, ease) => {
    return Object.keys(obj).map((item) => {
      if (!dataTweenValueIsValid(obj[item])) {
        dataTweenValueIsNotValidWarning(`${item}: ${obj[item]}`);
        return {
          prop: item,
          toValue: 0,
          ease: getTweenFn(ease)
        };
      }
      return {
        prop: item,
        toValue: obj[item],
        ease: getTweenFn(ease)
      };
    });
  };
  var goFromSyncUtils = (obj, ease) => {
    return Object.keys(obj).map((item) => {
      if (!dataTweenValueIsValid(obj[item])) {
        dataTweenValueIsNotValidWarning(`${item}: ${obj[item]}`);
        return {
          prop: item,
          fromValue: 0,
          ease: getTweenFn(ease)
        };
      }
      return {
        prop: item,
        fromValue: obj[item],
        ease: getTweenFn(ease)
      };
    });
  };
  var goFromToSyncUtils = (fromObj, toObj, ease) => {
    return Object.keys(fromObj).map((item) => {
      if (!dataTweenValueIsValid(toObj[item]) || !dataTweenValueIsValid(fromObj[item])) {
        dataTweenValueIsNotValidWarning(
          `${item}: ${toObj[item]} || ${item}: ${fromObj[item]}`
        );
        return {
          prop: item,
          fromValue: 0,
          toValue: 0,
          ease: getTweenFn(ease)
        };
      }
      return {
        prop: item,
        fromValue: fromObj[item],
        toValue: toObj[item],
        ease: getTweenFn(ease)
      };
    });
  };

  // src/js/mob/mob-motion/animation/utils/timeline/timeline-constant.js
  var directionConstant = {
    BACKWARD: "backward",
    FORWARD: "forward",
    NONE: "none"
  };

  // src/js/mob/mob-motion/animation/sequencer/reduce-function.js
  var propToSet = {
    fromValue: {
      get: "toValue",
      set: "fromValue"
    },
    toValue: {
      get: "toValue",
      set: "toValue"
    }
  };
  var getFirstValidValueBack = (arr, index, prop, propToFind) => {
    return arr.slice(0, index).reduceRight((previous, { values: valuesForward }) => {
      const result = valuesForward.find(
        ({ prop: propToCompare, active: active2 }) => {
          return active2 && propToCompare === prop;
        }
      );
      return result && !previous && previous !== 0 ? result[propToSet[propToFind].get] : previous;
    }, void 0);
  };
  var checkIsLastUsableProp = (arr, index, prop, partial) => {
    return arr.slice(index + 1).reduce((p, { start, values }) => {
      const nextActiveItem = values.find((nextItem) => {
        return nextItem.prop === prop && nextItem.active;
      });
      return nextActiveItem && start <= partial ? false : p;
    }, true);
  };

  // src/js/mob/mob-motion/animation/sequencer/get-values-on-draw.js
  var sequencerGetValusOnDraw = ({ timeline, valuesState, partial }) => {
    return valuesState.map((valueItem) => {
      const item = timeline.reduce(
        (previous, { start: start2, end: end2, values }, index) => {
          const currentValuesItem = values.find(
            ({ prop: prop2 }) => prop2 === valueItem.prop
          );
          if (!currentValuesItem || !currentValuesItem?.active || Object.keys(previous).length > 0 || valueItem.settled)
            return previous;
          const { prop, toValue: toValue2, fromValue: fromValue2, ease: ease2 } = currentValuesItem;
          const isLastUsableProp = checkIsLastUsableProp(
            timeline,
            index,
            prop,
            partial
          );
          if (!isLastUsableProp) return previous;
          return {
            toValue: toValue2,
            fromValue: fromValue2,
            start: start2,
            end: end2,
            ease: ease2
          };
        },
        {}
      );
      if (Object.keys(item).length === 0) return valueItem;
      const { start, end, toValue, fromValue, ease } = item;
      const newToValue = modules_exports.checkType(Number, toValue) ? toValue : (
        // @ts-ignore
        toValue()
      );
      const newFromValue = modules_exports.checkType(Number, fromValue) ? fromValue : (
        // @ts-ignore
        fromValue()
      );
      const duration2 = end - start;
      const inactivePosition = partial < end ? newFromValue : newToValue;
      const newCurrentValue = partial >= start && partial <= end ? ease(
        partial - start,
        newFromValue,
        newToValue - newFromValue,
        duration2
      ) : inactivePosition;
      const newCurrentValueSanitize = Number.isNaN(newCurrentValue) ? inactivePosition : newCurrentValue;
      const currentValueRoudned = getRoundedValue(newCurrentValueSanitize);
      return {
        ...valueItem,
        currentValue: currentValueRoudned,
        settled: true
      };
    });
  };

  // src/js/mob/mob-motion/animation/sequencer/set-prop-from-ancestor.js
  var setPropFromAncestor = ({ timeline, activeProp }) => {
    return timeline.map((item, index) => {
      const { values, propToFind } = item;
      const newValues = values.map((valueItem) => {
        const { prop, active: active2 } = valueItem;
        if (!active2 || !activeProp.includes(prop) || !propToFind || propToFind.length === 0)
          return valueItem;
        const previousValidValue = getFirstValidValueBack(
          timeline,
          index,
          prop,
          propToFind
        );
        if (!previousValidValue && previousValidValue !== 0) {
          return valueItem;
        }
        const newValueItem = {
          ...valueItem,
          [propToSet[propToFind].set]: previousValidValue
        };
        return newValueItem;
      });
      return {
        ...item,
        values: newValues
      };
    });
  };

  // src/js/mob/mob-motion/animation/sequencer/order-row.js
  var orderByProp = (arr, prop) => {
    return arr.sort((a, b) => {
      return a?.[prop] - b?.[prop];
    });
  };

  // src/js/mob/mob-motion/animation/sequencer/insert-new-row.js
  var insertNewRow = ({
    timeline,
    values,
    start,
    end,
    duration: duration2,
    propToFind
  }) => {
    const priority = timeline.length === 0 ? 0 : 1;
    const newTimeline = [
      ...timeline,
      {
        values,
        start: start ?? 0,
        end: end ?? duration2,
        priority,
        propToFind
      }
    ];
    const timelineOrderByStart = orderByProp(newTimeline, "start");
    return orderByProp(timelineOrderByStart, "priority");
  };

  // src/js/mob/mob-motion/animation/sequencer/merge-new-values.js
  var mergeNewValues = ({ data, values }) => {
    return values.map((item) => {
      const itemToMerge = data.find((newItem) => {
        return newItem.prop === item.prop;
      });
      return itemToMerge ? { ...item, ...itemToMerge, active: true } : {
        prop: item.prop,
        active: false
      };
    });
  };

  // src/js/mob/mob-motion/animation/sequencer/mob-sequencer.js
  var MobSequencer = class {
    /**
     * Basic array with all the propierties, is created in setData methods in draw methods currentValue and settled will
     * be updated for each prop
     *
     * It is used as a mock to create the array to add to the timeline
     *
     * @type {import('./type.js').SequencerValue[]}
     */
    #values;
    /**
     * Timeline array
     *
     * @type {import('./type.js').SequencerRow[]}
     */
    #timeline;
    /**
     * @type {import('./type.js').LabelType[]}
     */
    #labels;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackDefault}
     */
    #callback;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackCache}
     */
    #callbackCache;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackDefault}
     */
    #callbackOnStop;
    /**
     * @type {import('./type.js').AddType[]}
     */
    #callbackAdd;
    /**
     * @type {(() => void)[]}
     */
    #unsubscribeCache;
    /**
     * @type {number}
     */
    #duration;
    /**
     * @type {string}
     */
    #type;
    /**
     * @type {import('./type.js').SequencerDefault}
     */
    #defaultProp;
    /**
     * @type {boolean}
     */
    #firstRun;
    /**
     * @type {boolean}
     */
    #forceAddFnAtFirstRun;
    /**
     * @type {import('../utils/timeline/type.js').DirectionType}
     */
    #direction;
    /**
     * @type {number}
     */
    #lastPartial;
    /**
     * @type {import('../utils/stagger/type.js').StaggerObject}
     */
    #stagger;
    /**
     * @type {boolean}
     */
    #useStagger;
    /**
     * @type {boolean}
     */
    #staggerIsReady;
    /**
     * Available methods:
     *
     * ```javascript
     * mySequencer.goTo();
     * mySequencer.goFrom();
     * mySequencer.goFromTo();
     * mySequencer.add();
     * mySequencer.label();
     * mySequencer.subscribe();
     * mySequencer.subscribeCache();
     * mySequencer.onStop();
     * ```
     *
     * @example
     *     ```javascript
     *     const mySequencer = new MobSequencer({
     *       data: Object.<string, number>,
     *       duration: [ Number ],
     *       ease: [ String ],
     *       stagger:{
     *          each: [ Number ],
     *          from: [ Number|String|{x:number,y:number} ],
     *          grid: {
     *              col: [ Number ],
     *              row: [ Number ],
     *              direction: [ String ]
     *          },
     *       },
     *     })
     *
     *
     *     ```;
     *
     * @param {import('./type.js').SequencerProps} data
     */
    constructor(data) {
      this.#values = [];
      this.#timeline = [];
      this.#labels = [];
      this.#callback = [];
      this.#callbackCache = [];
      this.#callbackOnStop = [];
      this.#callbackAdd = [];
      this.#unsubscribeCache = [];
      this.#duration = durationIsValid(data?.duration);
      this.#type = "sequencer";
      this.#defaultProp = {
        start: 0,
        end: this.#duration,
        ease: easeIsValid(data?.ease)
      };
      this.#firstRun = true;
      this.#forceAddFnAtFirstRun = true;
      this.#direction = "none";
      this.#lastPartial = 0;
      this.#stagger = getStaggerFromProps(data);
      this.#useStagger = true;
      this.#staggerIsReady = false;
      const props = data?.data || null;
      if (props) this.setData(props);
    }
    /**
     * Inzialize stagger array
     */
    inzializeStagger() {
      if (this.#staggerIsReady) return;
      if (this.#stagger.each > 0 && (this.#callbackCache.length > 0 || this.#callback.length > 0)) {
        const cb = getStaggerArray(this.#callbackCache, this.#callback);
        if (this.#stagger.grid.col > cb.length) {
          staggerIsOutOfRangeWarning(cb.length);
          return;
        }
        const { staggerArray, staggerArrayOnComplete } = setStagger({
          arrayDefault: cb,
          arrayOnStop: this.#callbackOnStop,
          stagger: this.#stagger,
          slowlestStagger: STAGGER_DEFAULT_INDEX_OBJ,
          //sequencer doesn't support fastestStagger
          fastestStagger: STAGGER_DEFAULT_INDEX_OBJ
          //sequencer doesn't support fastestStagger
        });
        if (this.#callbackCache.length > this.#callback.length) {
          this.#callbackCache = /** @type {import('../utils/callbacks/type.js').CallbackCache} */
          staggerArray;
        } else {
          this.#callback = /** @type {import('../utils/callbacks/type.js').CallbackDefault} */
          staggerArray;
        }
        this.#callbackOnStop = staggerArrayOnComplete;
      }
      this.#staggerIsReady = true;
    }
    /**
     * @example
     *     ```javascript
     *     mySequencer.draw(
     *          partial: 200,
     *          isLastDraw: true,
     *          useFrame: false,
     *          direction: ('backward'|'forward'|'none')
     *     );
     *
     *
     *     ```;
     *
     * @param {object} obj
     * @param {number} obj.partial
     * @param {boolean} obj.isLastDraw
     * @param {boolean} obj.useFrame
     * @param {import('../utils/timeline/type.js').DirectionType} [obj.direction]
     */
    draw({
      partial = 0,
      isLastDraw = false,
      useFrame: useFrame2 = false,
      direction: direction2 = directionConstant.NONE
    }) {
      if (useFrame2) {
        this.#onDraw({
          partial,
          isLastDraw,
          direction: direction2
        });
        return;
      }
      modules_exports.useNextTick(
        () => this.#onDraw({
          partial,
          isLastDraw,
          direction: direction2
        })
      );
    }
    /**
     * @param {object} obj
     * @param {number} obj.partial
     * @param {boolean} obj.isLastDraw
     * @param {import('../utils/timeline/type.js').DirectionType} [obj.direction]
     */
    #onDraw({
      partial = 0,
      isLastDraw = false,
      direction: direction2 = directionConstant.NONE
    }) {
      if (this.#firstRun) {
        this.#lastPartial = partial;
        this.#actionAtFirstRender(partial);
      }
      if (!this.#firstRun && this.#lastPartial && (!direction2 || direction2 === directionConstant.NONE)) {
        this.#direction = partial >= this.#lastPartial ? directionConstant.FORWARD : directionConstant.BACKWARD;
      }
      if (!this.#firstRun && (direction2 === directionConstant.BACKWARD || direction2 === directionConstant.FORWARD)) {
        this.#direction = direction2;
      }
      this.#values = [...this.#values].map((item) => {
        return {
          ...item,
          settled: false
        };
      });
      this.#values = sequencerGetValusOnDraw({
        timeline: this.#timeline,
        valuesState: this.#values,
        partial
      });
      const callBackObject = getValueObj(this.#values, "currentValue");
      syncCallback({
        each: this.#stagger.each,
        useStagger: this.#useStagger,
        isLastDraw,
        callBackObject,
        callback: this.#callback,
        callbackCache: this.#callbackCache,
        callbackOnStop: this.#callbackOnStop
      });
      this.#fireAddCallBack(partial);
      this.#useStagger = true;
      this.#lastPartial = partial;
      this.#firstRun = false;
    }
    /**
     * Methods call by syncTimeline, everty time user use play, playFrom etc.. or loop end. Reset the data that control
     * add callback to have a new clean state
     */
    resetLastValue() {
      this.#firstRun = true;
      this.#lastPartial = 0;
    }
    /**
     * Fire addCallback first time without check the previous position. because first time we can start from any
     * position and we doesn't a have previous position So we fire the callback once To skip this callback, check
     * isForce prop in callback
     *
     * @property {number} [time=0] Default is `0`
     */
    #actionAtFirstRender(time2 = 0) {
      if (!this.#forceAddFnAtFirstRun) return;
      this.#callbackAdd.forEach(({ fn, time: fnTime }) => {
        const mustFireForward = {
          shouldFire: time2 >= fnTime,
          direction: directionConstant.FORWARD
        };
        const mustFireBackward = {
          shouldFire: time2 <= fnTime,
          direction: directionConstant.BACKWARD
        };
        const mustFire = mustFireForward.shouldFire || mustFireBackward.shouldFire;
        if (!mustFire) return;
        const direction2 = mustFireForward.shouldFire ? mustFireForward.direction : mustFireBackward.direction;
        fn({ direction: direction2, value: time2, isForced: true });
      });
      this.#forceAddFnAtFirstRun = false;
    }
    /**
     * Fire callBack at specific time
     *
     * @property {number} [time=0] Default is `0`
     */
    #fireAddCallBack(time2 = 0) {
      this.#callbackAdd.forEach(({ fn, time: fnTime }) => {
        const mustFireForward = this.#direction === directionConstant.FORWARD && time2 > fnTime && this.#lastPartial <= fnTime;
        const mustFireBackward = this.#direction === directionConstant.BACKWARD && time2 < fnTime && this.#lastPartial >= fnTime;
        const mustFire = mustFireForward || mustFireBackward;
        if (!mustFire) return;
        fn({ direction: this.#direction, value: time2, isForced: false });
      });
    }
    /**
     * Set factor between timeline duration and sequencer getDuration So start and end propierties will be proportionate
     * to the duration of the timeline This methods is called by SyncTimeline
     *
     * @type {import('./type.js').CequencerSetStretchFacor}
     */
    setStretchFactor(duration2 = 0) {
      const stretchFactor = duration2 / this.#duration;
      this.#timeline = [...this.#timeline].map((item) => {
        const { start, end } = item;
        return {
          ...item,
          start: getRoundedValue(start * stretchFactor),
          end: getRoundedValue(end * stretchFactor)
        };
      });
      this.#labels = [...this.#labels].map((item) => {
        const { time: time2 } = item;
        return {
          ...item,
          time: getRoundedValue(time2 * stretchFactor)
        };
      });
      this.#callbackAdd = [...this.#callbackAdd].map((item) => {
        const { time: time2 } = item;
        return {
          ...item,
          time: getRoundedValue(time2 * stretchFactor)
        };
      });
    }
    /**
     * @type {import('./type.js').SequencerSetData}
     */
    setData(obj = {}) {
      this.#values = Object.entries(obj).map((item) => {
        const [prop, value] = item;
        const isValid = initialDataPropValidate(prop, value);
        const valueSanitized = isValid ? value : 0;
        return {
          prop: isValid ? prop : "invalidProp",
          toValue: valueSanitized,
          fromValue: valueSanitized,
          currentValue: valueSanitized,
          active: false,
          settled: false,
          ease: getTweenFn(handleSetUp.get("sequencer").ease)
        };
      });
      this.goTo(obj, { start: 0, end: 0 });
      return this;
    }
    /**
     * Transform some properties of your choice from the `current value` to the `entered value`, the transformation will
     * start from the value associated with start and will end in the value associated with end. The target value can be
     * a number or a function that returns a number, when using a function the target value will become dynamic and will
     * change in real time as the result of the function changes It is possible to associate an easing to the
     * transformation, this easing will be applied only in this transformation.
     *
     * @example
     *     ```javascript
     *     mySequencer.goTo(
     *         { string: number|function, ... },
     *         { start: number, end: number, ease: string }
     *     );
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SequencerGoTo}
     */
    goTo(obj, props) {
      const propMerged = { ...this.#defaultProp, ...props };
      const { start, end, ease } = propMerged;
      if (!sequencerRangeValidate({ start, end })) return this;
      const data = goToSyncUtils(obj, ease);
      const newValues = mergeNewValues({ data, values: this.#values });
      const activeProp = Object.keys(obj);
      const newTimeline = insertNewRow({
        timeline: this.#timeline,
        values: newValues,
        start,
        end,
        duration: this.#duration,
        propToFind: "fromValue"
      });
      this.#timeline = setPropFromAncestor({
        timeline: newTimeline,
        activeProp
      });
      return this;
    }
    /**
     * Transform some properties of your choice from the `entered value` to the `current value`, the transformation will
     * start from the value associated with start and will end in the value associated with end. The target value can be
     * a number or a function that returns a number, when using a function the target value will become dynamic and will
     * change in real time as the result of the function changes It is possible to associate an easing to the
     * transformation, this easing will be applied only in this transformation.
     *
     * @example
     *     ```javascript
     *     mySequencer.goFrom(
     *         { string: number|function, ... },
     *         { start: number, end: number, ease: string }
     *     );
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SequencerGoFrom} obj To values
     */
    goFrom(obj, props) {
      const propMerged = { ...this.#defaultProp, ...props };
      const { start, end, ease } = propMerged;
      if (!sequencerRangeValidate({ start, end })) return this;
      const data = goFromSyncUtils(obj, ease);
      const newValues = mergeNewValues({ data, values: this.#values });
      const activeProp = Object.keys(obj);
      const newTimeline = insertNewRow({
        timeline: this.#timeline,
        values: newValues,
        start,
        end,
        duration: this.#duration,
        propToFind: "toValue"
      });
      this.#timeline = setPropFromAncestor({
        timeline: newTimeline,
        activeProp
      });
      return this;
    }
    /**
     * Transform some properties of your choice from the `first entered value` to the `second entered value`, the
     * transformation will start from the value associated with start and will end in the value associated with end. The
     * target value can be a number or a function that returns a number, when using a function the target value will
     * become dynamic and will change in real time as the result of the function changes It is possible to associate an
     * easing to the transformation, this easing will be applied only in this transformation.
     *
     * @example
     *     ```javascript
     *     mySequencer.goFromTo(
     *         { string: number|function, ... },
     *         { string: number|function, ... },
     *         { start: number, end: number, ease: string }
     *     );
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SequencerGoFromTo}
     */
    goFromTo(fromObj, toObj, props) {
      const propMerged = { ...this.#defaultProp, ...props };
      const { start, end, ease } = propMerged;
      if (!sequencerRangeValidate({ start, end })) return this;
      if (!compareKeys(fromObj, toObj)) {
        compareKeysWarning("sequencer goFromTo:", fromObj, toObj);
        return this;
      }
      const data = goFromToSyncUtils(fromObj, toObj, ease);
      const newValues = mergeNewValues({ data, values: this.#values });
      this.#timeline = insertNewRow({
        timeline: this.#timeline,
        values: newValues,
        start,
        end,
        duration: this.#duration,
        propToFind: ""
      });
      return this;
    }
    /**
     * Adds a label associated with a specific step in a range between 0 and duration (default: 10). Both syncTimeline
     * and scrollTrigger will take care of processing the value as needed
     *
     * @example
     *     ```javascript
     *     mySequencer.label('mylabel',5);
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SequencerLabel}
     */
    label(name = "", time2 = 0) {
      this.#labels.push({ name, time: time2 });
      return this;
    }
    /**
     * Return the array of entered labels
     *
     * @type {import('./type.js').SequencerGetLabels}
     */
    getLabels() {
      return this.#labels;
    }
    /**
     * Fire a function at a step in a range greater the 0 and minor duration. Both syncTimeline and scrollTrigger will
     * take care of processing the value as needed.
     *
     * To interpect both end ( 0 and duration ) use the syncTimeline/scrollTrigger built in function:
     *
     * @type {import('./type.js').SequencerAdd}
     */
    add(fn = () => {
    }, time2 = 0) {
      const fnIsValid = modules_exports.checkType(Function, fn);
      const timeIsValid = modules_exports.checkType(Number, time2);
      const addIsValid = fnIsValid && timeIsValid;
      if (!fnIsValid) syncTimelineAddFnWarning(fn);
      if (!timeIsValid) syncTimelineAddTimeWarning(time2);
      if (!addIsValid) return this;
      this.#callbackAdd.push({ fn, time: time2 });
      return this;
    }
    /**
     * Callback that returns updated values ready to be usable, it is advisable to use it for single elements, although
     * it works well on a not too large number of elements (approximately 100-200 elements) for large staggers it is
     * advisable to use the subscribeCache method.
     *
     * @type {import('./type.js').SequencerSubscribe}
     */
    subscribe(cb = () => {
    }) {
      const { arrayOfCallbackUpdated, unsubscribeCb } = updateSubScribers(
        cb,
        this.#callback
      );
      this.#callback = arrayOfCallbackUpdated;
      return () => this.#callback = unsubscribeCb(this.#callback);
    }
    /**
     * Similar to subscribe this callBack is launched when the data calculation stops (when the timeline ends or the
     * scroll trigger is inactive). Useful for applying a different style to an inactive element. A typical example is
     * to remove the teansform3D property:
     *
     * @type {import('./type.js').SequencerOnStop}
     */
    onStop(cb) {
      const { arrayOfCallbackUpdated, unsubscribeCb } = updateSubScribers(
        cb,
        this.#callbackOnStop
      );
      this.#callbackOnStop = arrayOfCallbackUpdated;
      return () => this.#callbackOnStop = unsubscribeCb(this.#callbackOnStop);
    }
    /**
     * Callback that returns updated values ready to be usable, specific to manage large staggers.
     *
     * @type {import('./type.js').SequencerSubscribeCache}
     */
    subscribeCache(item, fn = () => {
    }) {
      const { arrayOfCallbackUpdated, unsubscribeCb, unsubscribeCache } = updateSubscribersCache(
        item,
        fn,
        this.#callbackCache,
        this.#unsubscribeCache
      );
      this.#callbackCache = arrayOfCallbackUpdated;
      this.#unsubscribeCache = unsubscribeCache;
      return () => this.#callbackCache = unsubscribeCb(this.#callbackCache);
    }
    /**
     * Get duration
     *
     * @type {import('./type.js').SequencerGetDuration}
     */
    getDuration() {
      return this.#duration;
    }
    /**
     * Set duration
     *
     * @type {import('./type.js').SequencerSetDuration}
     */
    setDuration(val2 = 0) {
      this.#duration = val2;
    }
    /**
     * Get tween type - 'sequencer'
     *
     * @type {import('./type.js').SequencerGetType}
     */
    getType() {
      return this.#type;
    }
    /**
     * Removes all references of staggers not yet started by the handleCache function, method used by HandleSyncTimeline
     * when it is stopped
     */
    cleanCachedId() {
      this.#callbackCache.forEach(({ cb }) => modules_exports.useCache.clean(cb));
    }
    /**
     * ...
     */
    freezeCachedId() {
      this.#callbackCache.forEach(({ cb }) => modules_exports.useCache.freeze(cb));
    }
    /**
     * ...
     */
    unFreezeCachedId() {
      this.#callbackCache.forEach(
        ({ cb }) => modules_exports.useCache.unFreeze({ id: cb, update: true })
      );
    }
    /**
     * Disable stagger for one run
     */
    disableStagger() {
      this.#useStagger = false;
    }
    /**
     * Destroy sequencer
     *
     * @type {() => void}
     */
    destroy() {
      this.#values = [];
      this.#timeline = [];
      this.#callback = [];
      this.#callbackCache = [];
      this.#callbackOnStop = [];
      this.#callbackAdd = [];
      this.#unsubscribeCache.forEach((unsubscribe3) => unsubscribe3());
      this.#unsubscribeCache = [];
    }
  };

  // src/js/mob/mob-motion/animation/spring/get-values-on-draw.js
  var springGetValuesOndraw = ({
    values,
    tension,
    friction,
    mass,
    precision,
    fps: fps2
  }) => {
    return values.map((item) => {
      const { currentValue, toValue, velocity } = item;
      const tensionForce = -tension * (currentValue - toValue);
      const dampingForce = -friction * velocity;
      const acceleration = (tensionForce + dampingForce) / mass;
      const newVelocity = velocity + acceleration * 1 / fps2;
      const rawCurrentValue = currentValue + newVelocity * 1 / fps2;
      const newCurrentValue = getRoundedValue(rawCurrentValue);
      const isVelocity = Math.abs(newVelocity) <= 0.1;
      const isDisplacement = tension === 0 ? true : Math.abs(toValue - newCurrentValue) <= precision;
      const settled = isVelocity && isDisplacement;
      if (settled) {
        return {
          ...item,
          currentValue: toValue,
          velocity: newVelocity,
          settled: true
        };
      }
      return {
        ...item,
        currentValue: newCurrentValue,
        velocity: newVelocity,
        settled: false
      };
    });
  };

  // src/js/mob/mob-motion/animation/spring/mob-spring.js
  var MobSpring = class {
    /**
     * @type {import('../utils/stagger/type.js').StaggerObject}
     */
    #stagger;
    /**
     * @type {boolean}
     */
    #relative;
    /**
     * @type {import('./type.js').SpringProps}
     *
     *   This value lives from user call ( goTo etc..) until next call
     */
    #configProps;
    /**
     * @type {string}
     */
    #uniqueId;
    /**
     * @type {boolean}
     */
    #isRunning;
    /**
     * @type{((value:any) => void)|undefined }
     */
    #currentResolve;
    /**
     * @type{((value:any) => void)|undefined }
     */
    #currentReject;
    /**
     * @type {Promise<void> | undefined}
     */
    #currentPromise;
    /**
     * @type {import('./type.js').SpringValues[] | []}
     */
    #values;
    /**
     * @type {import('./type.js').SpringInitialData[]}
     */
    #initialData;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackDefault}
     */
    #callback;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackCache}
     */
    #callbackCache;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackDefault}
     */
    #callbackOnComplete;
    /**
     * @type {{ validation: () => boolean; callback: () => void }[]}
     */
    #externalValidations;
    /**
     * @type {(() => void)[]}
     */
    #unsubscribeCache;
    /**
     * @type {boolean}
     */
    #pauseStatus;
    /**
     * @type {boolean}
     */
    #firstRun;
    /**
     * @type {boolean}
     */
    #useStagger;
    /**
     * @type {boolean}
     */
    #staggerIsFreezed;
    /**
     * @type {boolean}
     */
    #fpsInLoading;
    /**
     * This value is the base value merged with new value in custom prop passed form user in goTo etc..
     *
     * @type {import('./type.js').SpringDefault}
     */
    #defaultProps;
    /**
     * @type {import('../utils/stagger/type.js').StaggerFrameIndexObject}
     */
    #slowlestStagger;
    /**
     * @type {import('../utils/stagger/type.js').StaggerFrameIndexObject}
     */
    #fastestStagger;
    /**
     * Available methods:
     *
     * ```javascript
     * mySpring.set();
     * mySpring.goTo();
     * mySpring.goFrom();
     * mySpring.goFromTo();
     * mySpring.subscribe();
     * mySpring.subscribeCache();
     * mySpring.onComplete();
     * mySpring.updateConfigProp();
     * mySpring.updateConfig();
     * mySpring.getId();
     * mySpring.get();
     * mySpring.getTo();
     * mySpring.getFrom();
     * mySpring.getToNativeType();
     * mySpring.getFromNativeType();
     * ```
     *
     * @example
     *     ```javascript
     *     const mySpring = new HandleSpring({
     *       data: Object.<string, number>,
     *       config: String,
     *       configProps: {
     *          tension: Number,
     *          mass: Number,
     *          friction: Number,
     *          velocity: Number,
     *          precision: Number,
     *       },
     *       relative: Boolean
     *       stagger:{
     *          each: Number,
     *          from: Number|String|{x:number,y:number},
     *          grid: {
     *              col: Number,
     *              row: Number,
     *              direction: String,
     *          },
     *          waitComplete: Boolean,
     *       },
     *     })
     *
     *
     *     ```;
     *
     * @param {import('./type.js').SpringTweenProps} [data]
     */
    constructor(data) {
      this.#stagger = getStaggerFromProps(data ?? {});
      this.#relative = relativeIsValid(data?.relative, "spring");
      this.#configProps = springConfigIsValidAndGetNew(data?.config);
      this.updateConfigProp(data?.configProps ?? {});
      this.#uniqueId = modules_exports.getUnivoqueId();
      this.#isRunning = false;
      this.#currentResolve = void 0;
      this.#currentReject = void 0;
      this.#currentPromise = void 0;
      this.#values = [];
      this.#initialData = [];
      this.#callback = [];
      this.#callbackCache = [];
      this.#callbackOnComplete = [];
      this.#externalValidations = [];
      this.#unsubscribeCache = [];
      this.#pauseStatus = false;
      this.#firstRun = true;
      this.#useStagger = true;
      this.#staggerIsFreezed = false;
      this.#fpsInLoading = false;
      this.#defaultProps = {
        reverse: false,
        configProps: this.#configProps,
        relative: this.#relative,
        immediate: false
      };
      this.#slowlestStagger = STAGGER_DEFAULT_INDEX_OBJ;
      this.#fastestStagger = STAGGER_DEFAULT_INDEX_OBJ;
      const props = data?.data;
      if (props) this.setData(props);
    }
    /**
     * @param {number} _time
     * @param {number} fps
     * @param {number} tension
     * @param {number} friction
     * @param {number} mass
     * @param {number} precision
     * @returns {void}
     */
    #draw(_time, fps2, tension, friction, mass, precision) {
      this.#isRunning = true;
      this.#values = springGetValuesOndraw({
        values: this.#values,
        tension,
        friction,
        mass,
        precision,
        fps: fps2
      });
      const callBackObject = getValueObj(this.#values, "currentValue");
      if (!this.#pauseStatus) {
        defaultCallback({
          stagger: this.#stagger,
          callback: this.#callback,
          callbackCache: this.#callbackCache,
          callBackObject,
          useStagger: this.#useStagger
        });
      }
      const allSettled = this.#values.every((item) => item.settled === true);
      if (allSettled) {
        const onComplete2 = () => {
          this.#values = [...this.#values].map((item) => {
            return {
              ...item,
              fromValue: item.toValue
            };
          });
          this.#currentResolve?.(true);
          this.#currentPromise = void 0;
          this.#currentReject = void 0;
          this.#currentResolve = void 0;
          this.#pauseStatus = false;
          this.#isRunning = false;
        };
        const cbObjectSettled = getValueObj(this.#values, "toValue");
        defaultCallbackOnComplete({
          onComplete: onComplete2,
          callback: this.#callback,
          callbackCache: this.#callbackCache,
          callbackOnComplete: this.#callbackOnComplete,
          callBackObject: cbObjectSettled,
          stagger: this.#stagger,
          slowlestStagger: this.#slowlestStagger,
          fastestStagger: this.#fastestStagger,
          useStagger: this.#useStagger
        });
        return;
      }
      modules_exports.useFrame(() => {
        modules_exports.useNextTick(({ time: time2, fps: fps3 }) => {
          if (this.#isRunning)
            this.#draw(time2, fps3, tension, friction, mass, precision);
        });
      });
    }
    /**
     * @param {number} time Current global time
     * @param {number} fps Current FPS
     */
    #onReuqestAnim(time2, fps2) {
      this.#values = [...this.#values].map((item) => {
        return {
          ...item,
          velocity: Math.trunc(this.#configProps.velocity)
        };
      });
      const tension = this.#configProps.tension;
      const friction = this.#configProps.friction;
      const mass = Math.max(1, this.#configProps.mass);
      const precision = this.#configProps.precision;
      this.#draw(time2, fps2, tension, friction, mass, precision);
    }
    /**
     * Inzialize stagger array
     *
     * @returns {Promise<any>}
     */
    async #inzializeStagger() {
      if (shouldInizializzeStagger(
        this.#stagger.each,
        this.#firstRun,
        this.#callbackCache,
        this.#callback
      )) {
        const { averageFPS } = await modules_exports.useFps();
        fpsLoadedLog("spring", averageFPS);
        const cb = getStaggerArray(this.#callbackCache, this.#callback);
        if (this.#stagger.grid.col > cb.length) {
          staggerIsOutOfRangeWarning(cb.length);
          this.#firstRun = false;
          return;
        }
        const {
          staggerArray,
          staggerArrayOnComplete,
          fastestStagger,
          slowlestStagger
        } = setStagger({
          arrayDefault: cb,
          arrayOnStop: this.#callbackOnComplete,
          stagger: this.#stagger,
          slowlestStagger: this.#slowlestStagger,
          fastestStagger: this.#fastestStagger
        });
        if (this.#callbackCache.length > this.#callback.length) {
          this.#callbackCache = /** @type {import('../utils/callbacks/type.js').CallbackCache} */
          staggerArray;
        } else {
          this.#callback = /** @type {import('../utils/callbacks/type.js').CallbackDefault} */
          staggerArray;
        }
        this.#callbackOnComplete = staggerArrayOnComplete;
        this.#slowlestStagger = slowlestStagger;
        this.#fastestStagger = fastestStagger;
        this.#firstRun = false;
      }
      return { ready: true };
    }
    /**
     * @param {(value: any) => void} resolve
     * @param {(value: any) => void} reject
     * @returns {Promise<any>}
     */
    async #startRaf(resolve, reject) {
      if (this.#fpsInLoading) return;
      this.#currentResolve = resolve;
      this.#currentReject = reject;
      if (this.#firstRun) {
        this.#fpsInLoading = true;
        await this.#inzializeStagger();
        this.#fpsInLoading = false;
      }
      initRaf({
        validationFunction: this.#externalValidations,
        defaultRafInit: (time2, fps2) => this.#onReuqestAnim(time2, fps2)
      });
    }
    /**
     * AsyncTimeline utils.
     *
     * - We perform a Promise.reject() of the tween. We are sure that the tween can start with a new promise to resolve.
     *   If in a Promise.race(), a tween continues because it is slower and risks not resolving its promise, we force
     *   manual cleanup. Importantly, this must not happen when the tween is paused—forcing the this.#isRunning
     *   parameter could interfere with the pause mechanism.
     *
     * @returns {void}
     */
    clearCurretPromise() {
      if (!this.#pauseStatus) {
        this.#currentReject?.(modules_exports.ANIMATION_STOP_REJECT);
        this.#currentPromise = void 0;
        this.#currentReject = void 0;
        this.#currentResolve = void 0;
        this.#isRunning = false;
      }
    }
    /**
     * @type {import('./type.js').SpringStop}
     */
    stop({ clearCache = true, updateValues = true } = {}) {
      if (this.#pauseStatus) this.#pauseStatus = false;
      if (updateValues) this.#values = setFromToByCurrent(this.#values);
      this.unFreezeStagger();
      if (clearCache)
        this.#callbackCache.forEach(({ cb }) => modules_exports.useCache.clean(cb));
      if (this.#currentReject) {
        this.#currentReject(modules_exports.ANIMATION_STOP_REJECT);
        this.#currentPromise = void 0;
        this.#currentReject = void 0;
        this.#currentResolve = void 0;
      }
      this.#isRunning = false;
    }
    /**
     * @returns {void}
     */
    freezeStagger() {
      if (this.#staggerIsFreezed) return;
      this.#callbackCache.forEach(({ cb }) => modules_exports.useCache.freeze(cb));
      this.#staggerIsFreezed = true;
    }
    /**
     * @param {object} [params]
     * @param {boolean} [params.updateFrame]
     * @returns {void}
     */
    unFreezeStagger({ updateFrame = true } = {}) {
      if (!this.#staggerIsFreezed) return;
      this.#callbackCache.forEach(
        ({ cb }) => modules_exports.useCache.unFreeze({ id: cb, update: updateFrame })
      );
      this.#staggerIsFreezed = false;
    }
    /**
     * @type {import('./type.js').SpringPause}
     */
    pause() {
      if (this.#pauseStatus) return;
      this.#pauseStatus = true;
      this.#isRunning = false;
      this.#values = setFromByCurrent(this.#values);
      this.freezeStagger();
    }
    /**
     * @type {import('./type.js').SpringResume}
     */
    resume() {
      if (!this.#pauseStatus) return;
      this.#pauseStatus = false;
      this.unFreezeStagger();
      if (!this.#isRunning && this.#currentResolve) {
        resume((time2, fps2) => this.#onReuqestAnim(time2, fps2));
      }
    }
    /**
     * Set initial data structure, the method is call by data prop in constructor. In case of need it can be called
     * after creating the instance
     *
     * @example
     *     ```javascript
     *
     *
     *     mySpring.setData({ val: 100 });
     *     ```;
     *
     * @type {import('../../utils/type.js').SetData} obj Initial data structure
     */
    setData(obj) {
      this.#values = Object.entries(obj).map((item) => {
        const [prop, value] = item;
        return {
          prop,
          toValue: value,
          fromValue: value,
          velocity: this.#configProps.velocity,
          currentValue: value,
          fromFn: () => 0,
          fromIsFn: false,
          toFn: () => 0,
          toIsFn: false,
          settled: false
        };
      });
      this.#initialData = this.#values.map((item) => {
        return {
          prop: item.prop,
          toValue: item.toValue,
          fromValue: item.fromValue,
          currentValue: item.currentValue,
          fromFn: () => 0,
          fromIsFn: false,
          toFn: () => 0,
          toIsFn: false,
          settled: false
        };
      });
    }
    /**
     * @type {import('./type.js').SpringResetData}
     */
    resetData() {
      this.#values = mergeDeep(this.#values, this.#initialData);
    }
    /**
     * Merge special props with default props
     *
     * @type {import('./type.js').SpringMergeProps}
     */
    #mergeProps(props) {
      const springParams = handleSetUp.get("spring");
      const allPresetConfig = springParams.config;
      const configPreset = springConfigIsValid(props?.config) ? allPresetConfig?.[props?.config ?? "default"] ?? springPresetConfig.default : this.#defaultProps.configProps;
      const configPropsToMerge = springConfigPropIsValid(props?.configProps);
      const configProps = {
        ...configPreset,
        ...configPropsToMerge
      };
      const newProps = {
        reverse: props?.reverse ?? this.#defaultProps.reverse,
        relative: props?.relative ?? this.#defaultProps.relative,
        immediate: props?.immediate ?? this.#defaultProps.immediate,
        configProps
      };
      const { relative } = newProps;
      this.#configProps = configProps;
      this.#relative = relative;
      return newProps;
    }
    /**
     * @type {import('../../utils/type.js').GoTo<import('./type.js').SpringActions>} obj To Values
     */
    goTo(toObject, specialProps = {}) {
      if (this.#pauseStatus)
        return Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
      this.#useStagger = true;
      const toObjectParsed = parseGoToObject(toObject);
      return this.#doAction(toObjectParsed, toObject, specialProps);
    }
    /**
     * @type {import('../../utils/type.js').GoFrom<import('./type.js').SpringActions>} obj To Values
     */
    goFrom(fromObject, spacialProps = {}) {
      if (this.#pauseStatus)
        return Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
      this.#useStagger = true;
      const fromObjectParsed = parseGoFromObject(fromObject);
      return this.#doAction(fromObjectParsed, fromObject, spacialProps);
    }
    /**
     * @type {import('../../utils/type.js').GoFromTo<import('./type.js').SpringActions>} obj To Values
     */
    goFromTo(fromObject, toObject, specialProps = {}) {
      if (this.#pauseStatus)
        return Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
      this.#useStagger = true;
      if (!compareKeys(fromObject, toObject)) {
        compareKeysWarning("spring goFromTo:", fromObject, toObject);
        return new Promise((resolve) => resolve);
      }
      const objectParsed = parseGoFromToObject(fromObject, toObject);
      return this.#doAction(objectParsed, fromObject, specialProps);
    }
    /**
     * @type {import('../../utils/type.js').Set<import('./type.js').SpringActions>} obj To Values
     */
    set(setObject, specialProps = {}) {
      if (this.#pauseStatus)
        return Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
      this.#useStagger = false;
      const setObjectParsed = parseSetObject(setObject);
      return this.#doAction(setObjectParsed, setObject, specialProps);
    }
    /**
     * @type {import('../../utils/type.js').SetImmediate<import('./type.js').SpringActions>} obj To Values
     */
    setImmediate(setObject, specialProps = {}) {
      if (this.#isRunning)
        this.stop({ clearCache: false, updateValues: false });
      if (this.#pauseStatus) return;
      this.#useStagger = false;
      const setObjectParsed = parseSetObject(setObject);
      this.#values = mergeArray(setObjectParsed, this.#values);
      const { reverse } = this.#mergeProps(specialProps ?? {});
      if (valueIsBooleanAndTrue(reverse, "reverse"))
        this.#values = setReverseValues(setObject, this.#values);
      this.#values = setRelative(this.#values, this.#relative);
      this.#values = setFromCurrentByTo(this.#values);
      return;
    }
    /**
     * @type {import('../../utils/type.js').DoAction<import('./type.js').SpringActions>} obj To Values
     */
    #doAction(newObjectParsed, newObjectRaw, spacialProps = {}) {
      this.#values = mergeArray(newObjectParsed, this.#values);
      const { reverse, immediate } = this.#mergeProps(spacialProps);
      if (valueIsBooleanAndTrue(reverse, "reverse"))
        this.#values = setReverseValues(newObjectRaw, this.#values);
      this.#values = setRelative(this.#values, this.#relative);
      if (valueIsBooleanAndTrue(immediate, "immediate ")) {
        if (this.#isRunning) this.stop({ updateValues: false });
        this.#values = setFromCurrentByTo(this.#values);
        return Promise.resolve();
      }
      const shouldInitializeRAF = !this.#isRunning && !this.#currentPromise;
      if (shouldInitializeRAF) {
        this.#currentPromise = new Promise((resolve, reject) => {
          this.#startRaf(resolve, reject);
        });
      }
      return shouldInitializeRAF && this.#currentPromise ? this.#currentPromise : Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
    }
    /**
     * Get current values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = mySpring.get();
     *     ```;
     *
     * @type {import('./type.js').SpringGetValue}
     */
    get() {
      return getValueObj(this.#values, "currentValue");
    }
    /**
     * Get initial values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = mySpring.getIntialData();
     *     ```;
     *
     * @type {import('./type.js').SpringGetValue}
     */
    getInitialData() {
      return getValueObj(this.#initialData, "currentValue");
    }
    /**
     * Get from values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = mySpring.getFrom();
     *     ```;
     *
     * @type {import('./type.js').SpringGetValue}
     */
    getFrom() {
      return getValueObj(this.#values, "fromValue");
    }
    /**
     * Get to values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = mySpring.getTo();
     *     ```;
     *
     * @type {import('./type.js').SpringGetValue}
     */
    getTo() {
      return getValueObj(this.#values, "toValue");
    }
    /**
     * Get From values, if the single value is a function it returns the same function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = mySpring.getFromNativeType();
     *     ```;
     *
     * @type {import('./type.js').SpringGetValueNative}
     */
    getFromNativeType() {
      return getValueObjFromNative(this.#values);
    }
    /**
     * Get To values, if the single value is a function it returns the same function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = mySpring.getToNativeType();
     *     ```;
     *
     * @type {import('./type.js').SpringGetValueNative}
     */
    getToNativeType() {
      return getValueObjToNative(this.#values);
    }
    /**
     * Get tween type
     *
     * @example
     *     ```javascript
     *
     *
     *     const type = mySpring.getType();
     *     ```;
     *
     * @type {import('./type.js').SpringGetType} tween Type
     */
    getType() {
      return "SPRING";
    }
    /**
     * Get univoque Id
     *
     * @example
     *     ```javascript
     *
     *
     *     const type = mySpring.getId();
     *     ```;
     *
     * @type {import('./type.js').SpringGetId}
     */
    getId() {
      return this.#uniqueId;
    }
    /**
     * Return active state.
     *
     * @returns {boolean}
     */
    isActive() {
      return this.#isRunning;
    }
    /**
     * Update config object, every || some properties The change will be persistent
     *
     * @example
     *     ```javascript
     *      mySpring.updateConfigProp({
     *          mass: 2,
     *          friction: 5
     *      })
     *
     *
     *      ```;
     *
     * @type {import('./type.js').SpringUdateConfigProp}
     */
    updateConfigProp(configProps = {}) {
      const configToMerge = springConfigPropIsValid(configProps);
      this.#configProps = { ...this.#configProps, ...configToMerge };
      this.#defaultProps = mergeDeep(this.#defaultProps, {
        configProps: configToMerge
      });
    }
    /**
     * UpdateConfig - Update config object with new preset
     *
     * @type {import('./type.js').SpringUdateConfig}
     */
    updateConfig(config) {
      this.#configProps = springConfigIsValidAndGetNew(config);
      this.#defaultProps = mergeDeep(this.#defaultProps, {
        configProps: this.#configProps
      });
    }
    /**
     * Callback that returns updated values ready to be usable, it is advisable to use it for single elements, although
     * it works well on a not too large number of elements (approximately 100-200 elements) for large staggers it is
     * advisable to use the subscribeCache method .
     *
     * @type {import('./type.js').SpringSubscribe}
     */
    subscribe(cb) {
      const { arrayOfCallbackUpdated, unsubscribeCb } = updateSubScribers(
        cb,
        this.#callback
      );
      this.#callback = arrayOfCallbackUpdated;
      return () => this.#callback = unsubscribeCb(this.#callback);
    }
    /**
     * Callback that returns updated values ready to be usable, specific to manage large staggers.
     *
     * @type {import('./type.js').SpringSubscribeCache}
     */
    subscribeCache(item, fn) {
      const { arrayOfCallbackUpdated, unsubscribeCb, unsubscribeCache } = updateSubscribersCache(
        item,
        fn,
        this.#callbackCache,
        this.#unsubscribeCache
      );
      this.#callbackCache = arrayOfCallbackUpdated;
      this.#unsubscribeCache = unsubscribeCache;
      return () => this.#callbackCache = unsubscribeCb(this.#callbackCache);
    }
    /**
     * Support callback to asyncTimeline. Callback to manage the departure of tweens in a timeline. If a delay is
     * applied to the tween and before the delay ends the timeline pauses the tween at the end of the delay will
     * automatically pause. Add callback to start in pause to stack
     *
     * @param {object} params
     * @param {() => boolean} params.validation
     * @param {() => void} params.callback
     * @returns {() => void}
     */
    validateInitialization({ validation, callback: callback2 }) {
      const valuesUpdated = [
        ...this.#externalValidations,
        { validation, callback: callback2 }
      ];
      this.#externalValidations = valuesUpdated;
      return () => this.#externalValidations = [];
    }
    /**
     * Similar to subscribe this callBack is launched when the data calculation stops (when the timeline ends or the
     * scroll trigger is inactive). Useful for applying a different style to an inactive element. A typical example is
     * to remove the teansform3D property:
     *
     * @type {import('./type.js').SpringOnComplete}
     */
    onComplete(cb) {
      const { arrayOfCallbackUpdated, unsubscribeCb } = updateSubScribers(
        cb,
        this.#callbackOnComplete
      );
      this.#callbackOnComplete = arrayOfCallbackUpdated;
      return () => this.#callbackOnComplete = unsubscribeCb(
        this.#callbackOnComplete
      );
    }
    /**
     * Destroy tween
     */
    destroy() {
      if (this.#currentPromise) this.stop();
      this.#callbackOnComplete = [];
      this.#externalValidations = [];
      this.#callback = [];
      this.#callbackCache = [];
      this.#values = [];
      this.#currentPromise = void 0;
      this.#unsubscribeCache.forEach((unsubscribe3) => unsubscribe3());
      this.#unsubscribeCache = [];
    }
  };

  // src/js/mob/mob-motion/animation/tween/get-values-on-draw.js
  var tweenGetValueOnDraw = ({
    values,
    timeElapsed: timeElapsed2,
    duration: duration2,
    ease
  }) => {
    return values.map((item) => {
      if (item.shouldUpdate) {
        const rawCurrentValue = ease(
          timeElapsed2,
          item.fromValue,
          item.toValProcessed,
          duration2
        );
        return {
          ...item,
          currentValue: getRoundedValue(rawCurrentValue)
        };
      }
      return {
        ...item,
        currentValue: item.fromValue
      };
    });
  };

  // src/js/mob/mob-motion/animation/tween/mob-time-tween.js
  var MobTimeTween = class {
    /**
     * @type {Function} This Value lives from user call ( goTo etc..) until next call
     */
    #ease;
    /**
     * @type {number}
     */
    #duration;
    /**
     * @type {boolean}
     */
    #relative;
    /**
     * @type {import('../utils/stagger/type.js').StaggerObject}
     */
    #stagger;
    /**
     * @type {string}
     */
    #uniqueId;
    /**
     * @type {boolean}
     */
    #isRunning;
    /**
     * @type{((value:any) => void)|undefined }
     */
    #currentResolve;
    /**
     * @type{((value:any) => void)|undefined }
     */
    #currentReject;
    /**
     * @type {Promise<void> | undefined}
     */
    #currentPromise;
    /**
     * @type {import('./type.js').TimeTweenStoreData[]}
     */
    #values;
    /**
     * @type {import('./type.js').TimeTweenInitialData[]}
     */
    #initialData;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackDefault}
     */
    #callback;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackCache}
     */
    #callbackCache;
    /**
     * @type {import('../utils/callbacks/type.js').CallbackDefault}
     */
    #callbackOnComplete;
    /**
     * @type {{ validation: () => boolean; callback: () => void }[]}
     */
    #externalValidations;
    /**
     * @type {(() => void)[]}
     */
    #unsubscribeCache;
    /**
     * @type {boolean}
     */
    #pauseStatus;
    /**
     * @type {number}
     */
    #startTime;
    /**
     * @type {number}
     */
    #timeElapsed;
    /**
     * @type {number}
     */
    #pauseTime;
    /**
     * @type {boolean}
     */
    #firstRun;
    /**
     * @type {boolean}
     */
    #useStagger;
    /**
     * @type {boolean}
     */
    #staggerIsFreezed;
    /**
     * @type {boolean}
     */
    #fpsInLoading;
    /**
     * This value is the base value merged with new value in custom prop passed form user in goTo etc..
     *
     * @type {import('./type.js').TimeTweenDefault}
     */
    #defaultProps;
    /**
     * @type {import('../utils/stagger/type.js').StaggerFrameIndexObject}
     */
    #slowlestStagger;
    /**
     * @type {import('../utils/stagger/type.js').StaggerFrameIndexObject}
     */
    #fastestStagger;
    /**
     * Available methods:
     *
     * ```javascript
     * myTween.set();
     * myTween.goTo();
     * myTween.goFrom();
     * myTween.goFromTo();
     * myTween.subscribe();
     * myTween.subscribeCache();
     * myTween.onComplete();
     * myTween.updateEase();
     * myTween.getId();
     * myTween.get();
     * myTween.getTo();
     * myTween.getFrom();
     * myTween.getToNativeType();
     * myTween.getFromNativeType();
     * ```
     *
     * @example
     *     ```javascript
     *     const myTween = new HandleTween({
     *       data: Object.<string, number>,
     *       duration: Number,
     *       ease: String,
     *       relative: Boolean
     *       stagger:{
     *          each: Number,
     *          from: Number|String|{x:number,y:number},
     *          grid: {
     *              col: Number,
     *              row: Number,
     *              direction: String
     *          },
     *          waitComplete: Boolean,
     *       },
     *     })
     *
     *
     *     ```;
     *
     * @param {import('./type.js').TimeTweenProps} [data]
     */
    constructor(data) {
      this.#ease = easeTweenIsValidGetFunction(data?.ease);
      this.#duration = durationIsNumberOrFunctionIsValid(data?.duration);
      this.#relative = relativeIsValid(data?.relative, "tween");
      this.#stagger = getStaggerFromProps(data ?? {});
      this.#uniqueId = modules_exports.getUnivoqueId();
      this.#isRunning = false;
      this.#currentResolve = void 0;
      this.#currentReject = void 0;
      this.#currentPromise = void 0;
      this.#values = [];
      this.#initialData = [];
      this.#callback = [];
      this.#callbackCache = [];
      this.#callbackOnComplete = [];
      this.#externalValidations = [];
      this.#unsubscribeCache = [];
      this.#pauseStatus = false;
      this.#startTime = 0;
      this.#timeElapsed = 0;
      this.#pauseTime = 0;
      this.#firstRun = true;
      this.#useStagger = true;
      this.#staggerIsFreezed = false;
      this.#fpsInLoading = false;
      this.#defaultProps = {
        duration: this.#duration,
        ease: easeTweenIsValid(data?.ease),
        relative: this.#relative,
        reverse: false,
        immediate: false
      };
      this.#slowlestStagger = STAGGER_DEFAULT_INDEX_OBJ;
      this.#fastestStagger = STAGGER_DEFAULT_INDEX_OBJ;
      const props = data?.data;
      if (props) this.setData(props);
    }
    /**
     * @param {number} time
     * @returns {void}
     */
    #draw(time2) {
      this.#isRunning = true;
      if (this.#pauseStatus) {
        this.#pauseTime = time2 - this.#startTime - this.#timeElapsed;
      }
      this.#timeElapsed = time2 - this.#startTime - this.#pauseTime;
      if (Math.round(this.#timeElapsed) >= this.#duration) {
        this.#timeElapsed = this.#duration;
      }
      this.#values = tweenGetValueOnDraw({
        values: this.#values,
        timeElapsed: this.#timeElapsed,
        duration: this.#duration,
        ease: this.#ease
      });
      const isSettled = Math.round(this.#timeElapsed) === this.#duration;
      const callBackObject = getValueObj(this.#values, "currentValue");
      if (!this.#pauseStatus) {
        defaultCallback({
          stagger: this.#stagger,
          callback: this.#callback,
          callbackCache: this.#callbackCache,
          callBackObject,
          useStagger: this.#useStagger
        });
      }
      if (isSettled) {
        const onComplete2 = () => {
          this.#values = [...this.#values].map((item) => {
            if (!item.shouldUpdate) return item;
            return {
              ...item,
              toValue: item.currentValue,
              fromValue: item.currentValue
            };
          });
          this.#currentResolve?.(true);
          this.#currentPromise = void 0;
          this.#currentReject = void 0;
          this.#currentResolve = void 0;
          this.#pauseTime = 0;
          this.#pauseStatus = false;
          this.#isRunning = false;
        };
        defaultCallbackOnComplete({
          onComplete: onComplete2,
          callback: this.#callback,
          callbackCache: this.#callbackCache,
          callbackOnComplete: this.#callbackOnComplete,
          callBackObject,
          stagger: this.#stagger,
          slowlestStagger: this.#slowlestStagger,
          fastestStagger: this.#fastestStagger,
          useStagger: this.#useStagger
        });
        return;
      }
      modules_exports.useFrame(() => {
        modules_exports.useNextTick(({ time: time3 }) => {
          if (this.#isRunning) this.#draw(time3);
        });
      });
    }
    /**
     * @param {number} time Current global time
     * @returns {void}
     */
    #onReuqestAnim(time2) {
      this.#startTime = time2;
      this.#draw(time2);
    }
    /**
     * Inzialize stagger array
     *
     * @returns {Promise<any>}
     */
    async #inzializeStagger() {
      if (shouldInizializzeStagger(
        this.#stagger.each,
        this.#firstRun,
        this.#callbackCache,
        this.#callback
      )) {
        const { averageFPS } = await modules_exports.useFps();
        fpsLoadedLog("tween", averageFPS);
        const cb = getStaggerArray(this.#callbackCache, this.#callback);
        if (this.#stagger.grid.col > cb.length) {
          staggerIsOutOfRangeWarning(cb.length);
          this.#firstRun = false;
          return;
        }
        const {
          staggerArray,
          staggerArrayOnComplete,
          fastestStagger,
          slowlestStagger
        } = setStagger({
          arrayDefault: cb,
          arrayOnStop: this.#callbackOnComplete,
          stagger: this.#stagger,
          slowlestStagger: this.#slowlestStagger,
          fastestStagger: this.#fastestStagger
        });
        if (this.#callbackCache.length > this.#callback.length) {
          this.#callbackCache = /** @type {import('../utils/callbacks/type.js').CallbackCache} */
          staggerArray;
        } else {
          this.#callback = /** @type {import('../utils/callbacks/type.js').CallbackDefault} */
          staggerArray;
        }
        this.#callbackOnComplete = staggerArrayOnComplete;
        this.#slowlestStagger = slowlestStagger;
        this.#fastestStagger = fastestStagger;
        this.#firstRun = false;
      }
      return { ready: true };
    }
    /**
     * @param {(value: any) => void} resolve
     * @param {(value: any) => void} reject
     * @returns {Promise<any>}
     */
    async #startRaf(resolve, reject) {
      if (this.#fpsInLoading) return;
      this.#currentResolve = resolve;
      this.#currentReject = reject;
      if (this.#firstRun) {
        this.#fpsInLoading = true;
        await this.#inzializeStagger();
        this.#fpsInLoading = false;
      }
      initRaf({
        validationFunction: this.#externalValidations,
        defaultRafInit: (time2) => this.#onReuqestAnim(time2)
      });
    }
    /**
     * AsyncTimeline utils.
     *
     * - We perform a Promise.reject() of the tween. We are sure that the tween can start with a new promise to resolve.
     *   If in a Promise.race(), a tween continues because it is slower and risks not resolving its promise, we force
     *   manual cleanup. Importantly, this must not happen when the tween is paused—forcing the this.#isRunning
     *   parameter could interfere with the pause mechanism.
     *
     * @returns {void}
     */
    clearCurretPromise() {
      if (!this.#pauseStatus) {
        this.#currentReject?.(modules_exports.ANIMATION_STOP_REJECT);
        this.#currentPromise = void 0;
        this.#currentReject = void 0;
        this.#currentResolve = void 0;
        this.#isRunning = false;
      }
    }
    /**
     * @type {import('./type.js').TimeTweenStop}
     */
    stop({ clearCache = true, updateValues = true } = {}) {
      this.#pauseTime = 0;
      this.#pauseStatus = false;
      if (updateValues) this.#values = setFromToByCurrent(this.#values);
      this.unFreezeStagger();
      if (clearCache)
        this.#callbackCache.forEach(({ cb }) => modules_exports.useCache.clean(cb));
      if (this.#currentReject) {
        this.#currentReject(modules_exports.ANIMATION_STOP_REJECT);
        this.#currentPromise = void 0;
        this.#currentReject = void 0;
        this.#currentResolve = void 0;
      }
      this.#isRunning = false;
    }
    /**
     * @returns {void}
     */
    freezeStagger() {
      if (this.#staggerIsFreezed) return;
      this.#callbackCache.forEach(({ cb }) => modules_exports.useCache.freeze(cb));
      this.#staggerIsFreezed = true;
    }
    /**
     * @param {object} [params]
     * @param {boolean} [params.updateFrame]
     * @returns {void}
     */
    unFreezeStagger({ updateFrame = true } = {}) {
      if (!this.#staggerIsFreezed) return;
      this.#callbackCache.forEach(
        ({ cb }) => modules_exports.useCache.unFreeze({ id: cb, update: updateFrame })
      );
      this.#staggerIsFreezed = false;
    }
    /**
     * @type {import('./type.js').TimeTweenPause}
     */
    pause() {
      if (this.#pauseStatus) return;
      this.#pauseStatus = true;
      this.freezeStagger();
    }
    /**
     * @type {import('./type.js').TimeTweenResume}
     */
    resume() {
      if (!this.#pauseStatus) return;
      this.#pauseStatus = false;
      this.unFreezeStagger();
    }
    /**
     * @type {import('../../utils/type.js').SetData}
     */
    setData(obj) {
      this.#values = Object.entries(obj).map((item) => {
        const [prop, value] = item;
        return {
          prop,
          toValue: value,
          toValueOnPause: value,
          toValProcessed: value,
          fromValue: value,
          currentValue: value,
          shouldUpdate: false,
          fromFn: () => 0,
          fromIsFn: false,
          toFn: () => 0,
          toIsFn: false,
          settled: false
          // not used, only for uniformity with lerp and spring
        };
      });
      this.#initialData = this.#values.map((item) => {
        return {
          prop: item.prop,
          toValue: item.toValue,
          fromValue: item.fromValue,
          currentValue: item.currentValue,
          shouldUpdate: false,
          fromFn: () => 0,
          fromIsFn: false,
          toFn: () => 0,
          toIsFn: false,
          settled: false
          // not used, only for uniformity with lerp and spring
        };
      });
    }
    /**
     * @type {import('./type.js').TimeTweenResetData}
     */
    resetData() {
      this.#values = mergeDeep(this.#values, this.#initialData);
    }
    /**
     * Reject promise and update form value with current
     *
     * @returns {void}
     */
    #updateDataWhileRunning() {
      this.#values = [...this.#values].map((item) => {
        if (!item.shouldUpdate) return item;
        return {
          ...item,
          fromValue: item.currentValue
        };
      });
    }
    /**
     * Merge special props with default props
     *
     * @type {import('./type.js').TimeTweenMergeProps}
     */
    #mergeProps(props) {
      const newProps = { ...this.#defaultProps, ...props };
      const { ease, duration: duration2, relative } = newProps;
      this.#ease = easeTweenIsValidGetFunction(ease);
      this.#relative = relativeIsValid(relative, "tween");
      this.#duration = durationIsNumberOrFunctionIsValid(duration2);
      return newProps;
    }
    /**
     * @type {import('../../utils/type.js').GoTo<import('./type.js').TimeTweenAction>} obj To Values
     */
    goTo(toObject, specialProps = {}) {
      this.stop({ clearCache: false, updateValues: true });
      this.#useStagger = true;
      const toObjectparsed = parseGoToObject(toObject);
      return this.#doAction(toObjectparsed, toObject, specialProps);
    }
    /**
     * @type {import('../../utils/type.js').GoFrom<import('./type.js').TimeTweenAction>} obj To Values
     */
    goFrom(fromObject, specialProps = {}) {
      this.stop({ clearCache: false, updateValues: true });
      this.#useStagger = true;
      const fromObjectParsed = parseGoFromObject(fromObject);
      return this.#doAction(fromObjectParsed, fromObject, specialProps);
    }
    /**
     * @type {import('../../utils/type.js').GoFromTo<import('./type.js').TimeTweenAction>} obj To Values
     */
    goFromTo(fromObject, toObject, specialProps = {}) {
      this.stop({ clearCache: false, updateValues: true });
      this.#useStagger = true;
      if (!compareKeys(fromObject, toObject)) {
        compareKeysWarning("tween goFromTo:", fromObject, toObject);
        return new Promise((resolve) => resolve);
      }
      const objectParsed = parseGoFromToObject(fromObject, toObject);
      return this.#doAction(objectParsed, fromObject, specialProps);
    }
    /**
     * @type {import('../../utils/type.js').Set<import('./type.js').TimeTweenAction>} obj To Values
     */
    set(setObject, specialProps = {}) {
      this.stop({ clearCache: false, updateValues: true });
      this.#useStagger = false;
      const setObjectParsed = parseSetObject(setObject);
      const propsParsed = specialProps ? { ...specialProps, duration: 1 } : { duration: 1 };
      return this.#doAction(setObjectParsed, setObject, propsParsed);
    }
    /**
     * @type {import('../../utils/type.js').SetImmediate<import('./type.js').TimeTweenAction>} obj To Values
     */
    setImmediate(setObject, specialProps = {}) {
      this.stop({ clearCache: false, updateValues: false });
      if (this.#pauseStatus) return;
      this.#useStagger = false;
      const setObjectParsed = parseSetObject(setObject);
      const propsParsed = specialProps ? { ...specialProps, duration: 1 } : { duration: 1 };
      this.#values = mergeArrayTween(setObjectParsed, this.#values);
      const { reverse } = this.#mergeProps(propsParsed);
      if (valueIsBooleanAndTrue(reverse, "reverse"))
        this.#values = setReverseValues(setObject, this.#values);
      this.#values = setRelativeTween(this.#values, this.#relative);
      this.#values = setFromCurrentByTo(this.#values);
      return;
    }
    /**
     * @type {import('../../utils/type.js').DoAction<import('./type.js').TimeTweenAction>} obj To Values
     */
    #doAction(newObjectParsed, newObjectRaw, specialProps = {}) {
      this.#values = mergeArrayTween(newObjectParsed, this.#values);
      const { reverse, immediate } = this.#mergeProps(specialProps);
      if (valueIsBooleanAndTrue(reverse, "reverse"))
        this.#values = setReverseValues(newObjectRaw, this.#values);
      this.#values = setRelativeTween(this.#values, this.#relative);
      if (valueIsBooleanAndTrue(immediate, "immediate ")) {
        if (this.#isRunning) {
          this.stop({ clearCache: false, updateValues: false });
          this.#updateDataWhileRunning();
        }
        this.#values = setFromCurrentByTo(this.#values);
        return Promise.resolve();
      }
      const shouldInitializeRAF = !this.#isRunning && !this.#currentPromise;
      if (shouldInitializeRAF) {
        this.#currentPromise = new Promise((resolve, reject) => {
          this.#startRaf(resolve, reject);
        });
      }
      return shouldInitializeRAF && this.#currentPromise ? this.#currentPromise : Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
    }
    /**
     * Get current values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myTween.get();
     *     ```;
     *
     * @type {import('./type.js').TimeTweenGetValue}
     */
    get() {
      return getValueObj(this.#values, "currentValue");
    }
    /**
     * Get initial values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myTween.getIntialData();
     *     ```;
     *
     * @type {import('./type.js').TimeTweenGetValue}
     */
    getInitialData() {
      return getValueObj(this.#initialData, "currentValue");
    }
    /**
     * Get from values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myTween.getFrom();
     *     ```;
     *
     * @type {import('./type.js').TimeTweenGetValue}
     */
    getFrom() {
      return getValueObj(this.#values, "fromValue");
    }
    /**
     * Get to values, If the single value is a function it returns the result of the function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myTween.getTo();
     *     ```;
     *
     * @type {import('./type.js').TimeTweenGetValue}
     */
    getTo() {
      return getValueObj(this.#values, "toValue");
    }
    /**
     * Get From values, if the single value is a function it returns the same function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myTween.getFromNativeType();
     *     ```;
     *
     * @type {import('./type.js').TimeTweenGetValueNative}
     */
    getFromNativeType() {
      return getValueObjFromNative(this.#values);
    }
    /**
     * Get To values, if the single value is a function it returns the same function.
     *
     * @example
     *     ```javascript
     *
     *
     *     const { prop } = myTween.getToNativeType();
     *     ```;
     *
     * @type {import('./type.js').TimeTweenGetValueNative}
     */
    getToNativeType() {
      return getValueObjToNative(this.#values);
    }
    /**
     * Get tween type
     *
     * @example
     *     ```javascript
     *
     *
     *     const type = myTween.getType();
     *     ```;
     *
     * @type {import('./type.js').TimeTweenGetType} tween Type
     */
    getType() {
      return "TWEEN";
    }
    /**
     * Get univoque Id
     *
     * @example
     *     ```javascript
     *
     *
     *     const type = myTween.getId();
     *     ```;
     *
     * @type {import('./type.js').TimeTweenGetId}
     */
    getId() {
      return this.#uniqueId;
    }
    /**
     * Return active state.
     *
     * @returns {boolean}
     */
    isActive() {
      return this.#isRunning;
    }
    /**
     * Update ease with new preset
     *
     * @type {import('./type.js').TimeTweenUpdateEase}
     */
    updateEase(ease) {
      this.#ease = easeTweenIsValidGetFunction(ease);
      this.#defaultProps = mergeDeep(this.#defaultProps, {
        ease
      });
    }
    /**
     * Callback that returns updated values ready to be usable, it is advisable to use it for single elements, although
     * it works well on a not too large number of elements (approximately 100-200 elements) for large staggers it is
     * advisable to use the subscribeCache method .
     *
     * @type {import('./type.js').TimeTweenSubscribe}
     */
    subscribe(cb) {
      const { arrayOfCallbackUpdated, unsubscribeCb } = updateSubScribers(
        cb,
        this.#callback
      );
      this.#callback = arrayOfCallbackUpdated;
      return () => this.#callback = unsubscribeCb(this.#callback);
    }
    /**
     * Callback that returns updated values ready to be usable, specific to manage large staggers.
     *
     * @type {import('./type.js').TimeTweenSubscribeCache}
     */
    subscribeCache(item, fn) {
      const { arrayOfCallbackUpdated, unsubscribeCb, unsubscribeCache } = updateSubscribersCache(
        item,
        fn,
        this.#callbackCache,
        this.#unsubscribeCache
      );
      this.#callbackCache = arrayOfCallbackUpdated;
      this.#unsubscribeCache = unsubscribeCache;
      return () => this.#callbackCache = unsubscribeCb(this.#callbackCache);
    }
    /**
     * Support callback to asyncTimeline. Callback to manage the departure of tweens in a timeline. If a delay is
     * applied to the tween and before the delay ends the timeline pauses the tween at the end of the delay will
     * automatically pause. Add callback to start in pause to stack
     *
     * @param {object} params
     * @param {() => boolean} params.validation
     * @param {() => void} params.callback
     * @returns {() => void}
     */
    validateInitialization({ validation, callback: callback2 }) {
      const valuesUpdated = [
        ...this.#externalValidations,
        { validation, callback: callback2 }
      ];
      this.#externalValidations = valuesUpdated;
      return () => this.#externalValidations = [];
    }
    /**
     * Similar to subscribe this callBack is launched when the data calculation stops (when the timeline ends or the
     * scroll trigger is inactive). Useful for applying a different style to an inactive element. A typical example is
     * to remove the teansform3D property:
     *
     * @type {import('./type.js').TimeTweenOnComplete}
     */
    onComplete(cb) {
      const { arrayOfCallbackUpdated, unsubscribeCb } = updateSubScribers(
        cb,
        this.#callbackOnComplete
      );
      this.#callbackOnComplete = arrayOfCallbackUpdated;
      return () => this.#callbackOnComplete = unsubscribeCb(
        this.#callbackOnComplete
      );
    }
    /**
     * Destroy tween
     *
     * @returns {void}
     */
    destroy() {
      if (this.#currentPromise) this.stop();
      this.#callbackOnComplete = [];
      this.#externalValidations = [];
      this.#callback = [];
      this.#callbackCache = [];
      this.#values = [];
      this.#currentPromise = void 0;
      this.#unsubscribeCache.forEach((unsubscribe3) => unsubscribe3());
      this.#unsubscribeCache = [];
    }
  };

  // src/js/mob/mob-motion/animation/sequencer/mob-create-stagger.js
  var getStaggerEqual = ({ each, duration: duration2, numItem, index, eachByNumItem }) => {
    if (each === 1) {
      const stepDuration = duration2 / numItem;
      const start = getRoundedValue(index * stepDuration);
      const end = getRoundedValue(start + stepDuration);
      return { start, end };
    }
    const unit = duration2 / numItem;
    const staggerDuration = unit * eachByNumItem;
    const remainSpace = duration2 - staggerDuration;
    const validNumItem = numItem - 1 > 0 ? numItem - 1 : 1;
    const remainSpaceUnit = remainSpace / validNumItem;
    const staggerStart = remainSpaceUnit * index;
    return {
      start: getRoundedValue(staggerStart),
      end: getRoundedValue(staggerDuration + staggerStart)
    };
  };
  var getStaggerSpecial = ({
    duration: duration2,
    numItem,
    index,
    eachByNumItem,
    type
  }) => {
    const unit = duration2 / numItem;
    const cleanStart = unit * index;
    const noopSpace = duration2 - (duration2 - cleanStart);
    const gap = noopSpace / numItem * eachByNumItem;
    if (type === STAGGER_TYPE_START) {
      return {
        start: 0,
        end: getRoundedValue(duration2 - (cleanStart - gap))
      };
    }
    if (type === STAGGER_TYPE_CENTER) {
      const space = (cleanStart - gap) / 2;
      return {
        start: getRoundedValue(space),
        end: getRoundedValue(duration2 - space)
      };
    }
    if (type === STAGGER_TYPE_END) {
      return {
        start: getRoundedValue(cleanStart - gap),
        end: getRoundedValue(duration2)
      };
    }
    return {
      start: 0,
      end: duration2
    };
  };
  var MobCreateStaggers = (data) => {
    const items = staggerItemsIsValid(data?.items);
    const stagger = getStaggerFromProps(data);
    const duration2 = durationIsValid(data?.duration);
    const eachProportion = 10;
    let each = stagger?.each || 1;
    const fallBack = [...items].map((item, i) => {
      return {
        item,
        start: 0,
        end: duration2,
        index: i
      };
    });
    if (!validateStaggerItems(items)) {
      return fallBack;
    }
    if (stagger.grid?.col > items.length) {
      staggerIsOutOfRangeWarning(items.length);
      each = 1;
    }
    if (modules_exports.checkType(Number, each) && (each > eachProportion || each < 1)) {
      createStaggerEachWarning(eachProportion);
      each = 1;
    }
    const { staggerArray } = setStagger({
      arrayDefault: [...items].map((item) => ({ item })),
      arrayOnStop: [],
      stagger,
      slowlestStagger: STAGGER_DEFAULT_INDEX_OBJ,
      fastestStagger: STAGGER_DEFAULT_INDEX_OBJ
    });
    const staggerArrayFiltered = staggerArray.filter(
      ({ item }) => modules_exports.checkType(Element, item) || modules_exports.checkType(Object, item) || modules_exports.checkType(Element, item?.deref?.())
    );
    if (staggerArrayFiltered.length === 0) {
      createStaggerItemsTypeWarning();
      return fallBack;
    }
    const frameArray = staggerArrayFiltered.map(({ frame }) => frame);
    const frameSet = [...new Set(frameArray)].sort((a, b) => a - b);
    const numItem = frameSet.length;
    const staggers = staggerArrayFiltered.map(({ item, frame }) => {
      const index = frameSet.indexOf(frame);
      const eachByNumItem = each * numItem / eachProportion;
      const { start, end } = (() => {
        if (stagger.type === STAGGER_TYPE_EQUAL) {
          return getStaggerEqual({
            each,
            duration: duration2,
            numItem,
            index,
            eachByNumItem
          });
        }
        if (stagger.type === STAGGER_TYPE_START || stagger.type === STAGGER_TYPE_END || stagger.type === STAGGER_TYPE_CENTER) {
          return getStaggerSpecial({
            duration: duration2,
            numItem,
            index,
            eachByNumItem,
            type: stagger.type
          });
        }
        return {
          start: 0,
          end: duration2
        };
      })();
      return {
        item,
        start,
        end,
        index
      };
    });
    return staggers;
  };

  // src/js/mob/mob-motion/tween.js
  function createScrollerTween(data) {
    return new MobScrollerTween(data);
  }
  function createSequencer(data) {
    return new MobSequencer(data);
  }
  function createMasterSequencer() {
    return new MobMasterSequencer();
  }
  function createStaggers(data) {
    return MobCreateStaggers(data);
  }
  function createTimeTween(data) {
    return new MobTimeTween(data);
  }
  function createSpring(data) {
    return new MobSpring(data);
  }
  function createLerp(data) {
    return new MobLerp(data);
  }

  // src/js/mob/mob-motion/timeline.js
  var timeline_exports = {};
  __export(timeline_exports, {
    createAsyncTimeline: () => createAsyncTimeline,
    createSyncTimeline: () => createSyncTimeline
  });

  // src/js/mob/mob-motion/utils/functions-utils.js
  var NOOP = () => {
  };
  var pipe = (...functions) => (input) => functions.reduce(
    (chain, func) => chain.then(func),
    Promise.resolve(input)
  );

  // src/js/mob/mob-motion/animation/async-timeline/fitler-active-props.js
  var filterActiveProps = ({ data, filterBy }) => {
    return Object.entries(data).map((item) => {
      const [prop, val2] = item;
      const valueIsValid = prop in filterBy;
      return { data: { [prop]: val2 }, active: valueIsValid };
    }).filter(({ active: active2 }) => active2).map(({ data: data2 }) => data2).reduce((p, c) => {
      return { ...p, ...c };
    }, {});
  };

  // src/js/mob/mob-motion/animation/async-timeline/reduce-tween-until-index.js
  var reduceTweenUntilIndex = ({ timeline, tween: tween2, index }) => {
    const currentId = tween2?.getId?.();
    const initialData = tween2?.getInitialData?.() || {};
    const result = timeline.slice(0, index).reduce((previous, current) => {
      const currentTween = current.find(({ data }) => {
        const uniqueId = data?.tween?.getId?.();
        return uniqueId === currentId;
      });
      currentTween?.data?.tween?.setImmediate?.(currentTween?.data?.valuesTo);
      const currentValueTo = currentTween?.data?.tween?.getToNativeType?.();
      const propsInUse = currentValueTo && currentTween ? filterActiveProps({
        data: currentValueTo,
        filterBy: currentTween.data.valuesTo
      }) : {};
      return { ...previous, ...propsInUse };
    }, initialData);
    tween2.setImmediate(initialData);
    return result;
  };

  // src/js/mob/mob-motion/animation/async-timeline/loop-callback.js
  var resolveTweenPromise = ({
    mainReject,
    mainResolve,
    isStopped: isStopped2,
    previousSessionId,
    currentSessionId,
    isInPause,
    tween: tween2,
    stepFunction,
    action: action2,
    addToActiveTween
  }) => {
    if (isStopped2() || previousSessionId !== currentSessionId()) {
      mainReject();
      return;
    }
    const unsubscribeActiveTween = addToActiveTween(tween2);
    const unsubscribeValidation = tween2 && tween2?.validateInitialization ? tween2.validateInitialization({
      validation: () => isInPause(),
      callback: () => tween2.pause?.()
    }) : NOOP;
    stepFunction[action2]().then(() => mainResolve({ resolve: true })).catch(() => {
    }).finally(() => {
      unsubscribeActiveTween();
      unsubscribeValidation();
    });
  };

  // src/js/mob/mob-motion/animation/async-timeline/async-timeline.js
  var MobAsyncTimeline = class {
    /**
     * @type {number}
     */
    #repeat;
    /**
     * @type {boolean}
     */
    #yoyo;
    /**
     * @type {boolean}
     */
    #freeMode;
    /**
     * @type {boolean}
     */
    #autoSet;
    /**
     * @type {boolean}
     */
    #inheritProps;
    /**
     * @type {boolean}
     */
    #forceFromTo;
    /**
     * @type {import('./type.js').AsyncTimelineTweenItem[][]}
     */
    #tweenList;
    /**
     * @type {import('./type.js').AsyncTimelineCurrentTween[]}
     */
    #currentTween;
    /**
     * @type {import('./type.js').AsyncTimelineTweenStore[]}
     */
    #tweenStore;
    /**
     * @type {boolean}
     */
    #waitComplete;
    /**
     * @type {import('./type.js').AsyncTimelineRowData}
     */
    #defaultObj;
    /**
     * Timeline state
     *
     * @type {import('./type.js').AsyncTimelineLabelState}
     */
    #useLabel;
    /**
     * Group "name" star from 1 to avoid 0 = false
     *
     * @type {number}
     */
    #groupCounter;
    /**
     * @type {number | undefined}
     */
    #groupId;
    /**
     * @type {number}
     */
    #currentTweenCounter;
    /**
     * @type {number}
     */
    #currentIndex;
    /**
     * @type {number}
     */
    #loopCounter;
    /**
     * @type {boolean}
     */
    #isReverseNext;
    /**
     * @type {boolean}
     */
    #forceYoyo;
    /**
     * @type {boolean}
     */
    #isReverse;
    /**
     * @type {boolean}
     */
    #isInPause;
    /**
     * @type {boolean}
     */
    #isInSuspension;
    /**
     * @type {boolean}
     */
    #addAsyncIsActive;
    /**
     * @type {boolean}
     */
    #isStopped;
    /**
     * @type {number}
     */
    #sessionId;
    /**
     * @type {number}
     */
    #activetweenCounter;
    /**
     * @type {number}
     */
    #timeOnPause;
    /**
     * @type {boolean}
     */
    #autoSetIsJustCreated;
    /**
     * @type {import('./type.js').AsyncTimelineCurrentAction[]}
     */
    #currentAction;
    /**
     * @type {boolean}
     */
    #fpsIsInLoading;
    /**
     * @type {number}
     */
    #id;
    /**
     * @type {{ cb: (arg0: import('../utils/timeline/type.js').DirectionTypeObjectLoop) => void; id: number }[]}
     */
    #callbackLoop;
    /**
     * @type {{ cb: () => void; id: number }[]}
     */
    #callbackComplete;
    /**
     * @type{((value:any) => void)|undefined}
     */
    #currentResolve;
    /**
     * @type{((value:any) => void)|undefined}
     */
    #currentReject;
    /**
     * Available methods:
     *
     * ```javascript
     * `Methods to create timeline`;
     * myTimeline.set();
     * myTimeline.goTo();
     * myTimeline.goFrom();
     * myTimeline.goFromTo();
     * myTimeline.add();
     * myTimeline.addAsync();
     * myTimeline.createGroup();
     * myTimeline.closeGroup();
     * myTimeline.suspend();
     * myTimeline.label()`Methods to control timeline`;
     * myTimeline.play();
     * myTimeline.playFromLabel();
     * myTimeline.playFrom();
     * myTimeline.playFromReverse();
     * myTimeline.playReverse();
     * myTimeline.reverseNext();
     * myTimeline.stop();
     * myTimeline.pause();
     * myTimeline.resume();
     * myTimeline.isActive();
     * myTimeline.isPaused();
     * myTimeline.isSuspended();
     * myTimeline.getDirection();
     * myTimeline.setTween();
     * myTimeline.get();
     * myTimeline.onLoopEnd();
     * myTimeline.onComplete();
     * myTimeline.destroy();
     * ```
     *
     * @example
     *     ```javascript
     *     const myTimeline = new MobAsyncTimeline({
     *       yoyo: [ boolean ],
     *       repeat: [ number ],
     *       freeMode: [ boolean ],
     *       autoSet: [ boolean ],
     *       inheritProps: [ number ],
     *     })
     *
     *
     *     ```;
     *
     * @param {import('./type.js').AsyncTimeline} data
     */
    constructor(data) {
      this.#repeat = repeatIsValid(data?.repeat);
      this.#yoyo = valueIsBooleanAndReturnDefault(
        data?.yoyo,
        "asyncTimeline: yoyo",
        false
      );
      this.#freeMode = valueIsBooleanAndReturnDefault(
        data?.freeMode,
        "asyncTimeline: freeMode",
        false
      );
      this.#autoSet = valueIsBooleanAndReturnDefault(
        data?.autoSet,
        "asyncTimeline: autoSet",
        true
      );
      this.#inheritProps = valueIsBooleanAndReturnDefault(
        data?.inheritProps,
        "asyncTimeline: inheritProps",
        true
      );
      this.#forceFromTo = valueIsBooleanAndReturnDefault(
        data?.forceFromTo,
        "asyncTimeline: forceFromTo",
        false
      );
      this.#tweenList = [];
      this.#currentTween = [];
      this.#tweenStore = [];
      this.#waitComplete = false;
      this.#defaultObj = {
        id: -1,
        tween: void 0,
        callback: () => {
        },
        action: "",
        valuesFrom: {},
        valuesTo: {},
        prevValueTo: {},
        prevValueSettled: false,
        tweenProps: {},
        groupProps: {},
        labelProps: {}
      };
      this.#useLabel = {
        active: false,
        index: -1,
        isReverse: false,
        callback: void 0
      };
      this.#groupCounter = 1;
      this.#groupId = void 0;
      this.#currentTweenCounter = 0;
      this.#currentIndex = 0;
      this.#loopCounter = 1;
      this.#isReverseNext = false;
      this.#forceYoyo = false;
      this.#isReverse = false;
      this.#isInPause = false;
      this.#isInSuspension = false;
      this.#addAsyncIsActive = false;
      this.#isStopped = true;
      this.#sessionId = 0;
      this.#activetweenCounter = 0;
      this.#timeOnPause = 0;
      this.#autoSetIsJustCreated = false;
      this.#currentAction = [];
      this.#fpsIsInLoading = false;
      this.#id = 0;
      this.#callbackLoop = [];
      this.#callbackComplete = [];
      this.#currentResolve = void 0;
      this.#currentReject = void 0;
    }
    /**
     * @type {() => void}
     */
    #run() {
      const currentTweelist = this.#tweenList[this.#currentIndex];
      const lastAction = this.#currentAction;
      this.#currentAction = [];
      if (!currentTweelist) return;
      this.#tweenList[this.#currentIndex] = currentTweelist.map((item) => {
        const { data } = item;
        const { tween: tween2, valuesTo: currentValuesTo, prevValueSettled } = data;
        if (tween2 && tween2?.getToNativeType && !prevValueSettled) {
          const nativeValues = tween2.getToNativeType();
          const prevValueTo = filterActiveProps({
            data: nativeValues,
            filterBy: currentValuesTo
          });
          return {
            ...item,
            data: {
              ...data,
              prevValueTo,
              prevValueSettled: true
            }
          };
        }
        return item;
      });
      const tweenPromises = currentTweelist.map((item) => {
        const { data } = item;
        const {
          tween: tween2,
          callback: callback2,
          action: action2,
          valuesFrom,
          valuesTo,
          tweenProps,
          id
        } = data;
        const newTweenProps = { ...tweenProps };
        delete newTweenProps.delay;
        const { active: labelIsActive, index: labelIndex } = this.#useLabel;
        const isImmediate = Number.isNaN(labelIndex) ? false : labelIsActive && labelIndex && // @ts-ignore
        this.#currentIndex < labelIndex;
        if (isImmediate) newTweenProps.immediate = true;
        if (tweenProps && "relative" in tweenProps && tweenProps.relative) {
          tweenProps.relative = false;
          relativePropInsideTimelineWarning();
        }
        this.#currentAction.push({ id, action: action2 });
        const prevActionIsCurrent = lastAction.find(
          ({ id: prevId, action: prevAction }) => {
            return prevId === id && prevAction === action2;
          }
        );
        const stepFunction = {
          set: () => {
            if (!this.#isInPause) tween2?.clearCurretPromise?.();
            return tween2?.[
              /** @type {'set'} */
              action2
            ](
              valuesFrom,
              newTweenProps
            );
          },
          goTo: () => {
            if (!this.#isInPause) tween2?.clearCurretPromise?.();
            return tween2?.[
              /** @type {'goTo'} */
              action2
            ](
              valuesTo,
              newTweenProps
            );
          },
          goFrom: () => {
            if (!this.#isInPause) tween2?.clearCurretPromise?.();
            return tween2?.[
              /** @type {'goFrom'} */
              action2
            ](
              valuesFrom,
              newTweenProps
            );
          },
          goFromTo: () => {
            if (!this.#isInPause) tween2?.clearCurretPromise?.();
            return tween2?.[
              /** @type {'goFromTo'} */
              action2
            ](
              valuesFrom,
              valuesTo,
              newTweenProps
            );
          },
          add: () => {
            if (prevActionIsCurrent) {
              return new Promise((res) => res({ resolve: true }));
            }
            return new Promise((res) => {
              if (isImmediate) {
                res({ resolve: true });
                return;
              }
              const direction2 = this.getDirection();
              callback2({
                direction: direction2,
                loop: this.#loopCounter
              });
              res({ resolve: true });
            });
          },
          addAsync: () => {
            this.#addAsyncIsActive = true;
            const sessionId = this.#sessionId;
            if (prevActionIsCurrent) {
              return new Promise((res) => res({ resolve: true }));
            }
            return new Promise((res, reject) => {
              if (isImmediate) {
                res({ resolve: true });
                return;
              }
              const direction2 = this.getDirection();
              callback2({
                direction: direction2,
                loop: this.#loopCounter,
                resolve: () => {
                  if (sessionId === this.#sessionId) {
                    res({ resolve: true });
                    return;
                  }
                  reject();
                }
              });
            });
          },
          createGroup: () => {
            return new Promise((res) => res({ resolve: true }));
          },
          closeGroup: () => {
            return new Promise((res) => res({ resolve: true }));
          },
          label: () => {
            return new Promise((res) => res({ resolve: true }));
          },
          suspend: () => {
            if (prevActionIsCurrent) {
              return new Promise((res) => res({ resolve: true }));
            }
            const valueIsValid = modules_exports.checkType(Boolean, callback2());
            if (!valueIsValid) timelineSuspendWarning(callback2);
            const sholudSuspend = valueIsValid ? callback2() : true;
            return new Promise((res) => {
              if (!isImmediate && sholudSuspend) {
                this.#isInSuspension = true;
              }
              res({ resolve: true });
            });
          }
        };
        return new Promise((mainResolve, mainReject) => {
          const delay = isImmediate ? false : tweenProps?.delay;
          const previousSessionId = this.#sessionId;
          if (delay) {
            const start = modules_exports.getTime();
            requestAnimationFrame(() => {
              this.#loopOnDelay({
                start,
                deltaTimeOnpause: 0,
                delay,
                mainReject,
                mainResolve,
                previousSessionId,
                tween: tween2,
                stepFunction,
                action: action2
              });
            });
            return;
          }
          resolveTweenPromise({
            mainReject,
            mainResolve,
            isStopped: () => this.#isStopped,
            isInPause: () => this.#isInPause,
            addToActiveTween: (tween3) => this.#addToActiveTween(tween3),
            currentSessionId: () => this.#sessionId,
            previousSessionId,
            tween: tween2,
            stepFunction,
            action: action2
          });
        });
      });
      const waitComplete = this.#tweenList[this.#currentIndex].some(
        (item) => {
          return item.data.groupProps?.waitComplete;
        }
      );
      const promiseType = waitComplete ? "all" : "race";
      Promise[promiseType](tweenPromises).then(() => {
        if (this.#isInSuspension || this.#isStopped) return;
        const {
          active: labelIsActive,
          index: labelIndex,
          isReverse: labelIsReverse,
          callback: callbackLabel
        } = this.#useLabel;
        if (callbackLabel && labelIsActive && // @ts-ignore
        this.#currentIndex === labelIndex - 1) {
          this.#resetUseLabel();
          this.#loopCounter++;
          callbackLabel();
          return;
        }
        if (labelIsActive && labelIsReverse && // @ts-ignore
        this.#currentIndex === labelIndex - 1) {
          this.reverseNext();
        }
        if (this.#isReverseNext) {
          this.#isReverseNext = false;
          this.#currentIndex = this.#tweenList.length - this.#currentIndex - 1;
          this.#resetUseLabel();
          this.#revertTween();
          this.#run();
          return;
        }
        if (this.#currentIndex < this.#tweenList.length - 1) {
          this.#currentIndex++;
          this.#run();
          return;
        }
        if (this.#loopCounter < this.#repeat || this.#repeat === -1) {
          if (labelIsActive && labelIndex === this.#tweenList.length && !this.#freeMode) {
            const tweenPromise = this.#tweenStore.map(
              ({ tween: tween2 }) => {
                const data = reduceTweenUntilIndex({
                  timeline: this.#tweenList,
                  tween: tween2,
                  index: this.#tweenList.length
                });
                return new Promise((resolve, reject) => {
                  tween2.set(data).then(() => resolve({ resolve: true })).catch(() => reject());
                });
              }
            );
            Promise.all(tweenPromise).then(() => {
              this.#onRepeat();
            }).catch(() => {
            });
            return;
          }
          this.#onRepeat();
          return;
        }
        this.#callbackComplete.forEach(({ cb }) => cb());
        this.#isStopped = true;
        if (this.#currentResolve) {
          handleNextFrame.add(() => {
            handleNextTick.add(() => {
              this.#currentResolve?.({ resolve: true });
            });
          });
        }
      }).catch((error) => {
        if (error) console.log(error);
      }).finally(() => {
        this.#addAsyncIsActive = false;
      });
    }
    /**
     * The method run only if tween has delay. Resolve tween delay.
     *
     * @param {Object} param0
     * @param {number} param0.start
     * @param {number} param0.deltaTimeOnpause
     * @param {number} param0.delay
     * @param {(value: any) => void} param0.mainReject
     * @param {(value: any) => void} param0.mainResolve
     * @param {number} param0.previousSessionId
     * @param {any} param0.tween
     * @param {Record<string, () => void>} param0.stepFunction
     * @param {string} param0.action
     */
    #loopOnDelay({
      start,
      deltaTimeOnpause,
      delay,
      mainReject,
      mainResolve,
      previousSessionId,
      tween: tween2,
      stepFunction,
      action: action2
    }) {
      const current = modules_exports.getTime();
      const delta = current - start;
      if (this.#isInPause) deltaTimeOnpause = current - this.#timeOnPause;
      if (delta - deltaTimeOnpause >= delay || this.#isStopped || this.#isReverseNext) {
        resolveTweenPromise({
          mainReject,
          mainResolve,
          isStopped: () => this.#isStopped,
          isInPause: () => this.#isInPause,
          addToActiveTween: (tween3) => {
            return this.#addToActiveTween(tween3);
          },
          currentSessionId: () => this.#sessionId,
          previousSessionId,
          tween: tween2,
          stepFunction,
          action: action2
        });
        return;
      }
      requestAnimationFrame(() => {
        this.#loopOnDelay({
          start,
          deltaTimeOnpause,
          delay,
          mainReject,
          mainResolve,
          previousSessionId,
          tween: tween2,
          stepFunction,
          action: action2
        });
      });
    }
    /**
     * Execute repeat.
     *
     * @type {() => void}
     */
    #onRepeat() {
      if (this.#loopCounter > 0) {
        const direction2 = this.getDirection();
        this.#callbackLoop.forEach(
          ({ cb }) => cb({
            direction: direction2,
            loop: this.#loopCounter
          })
        );
      }
      this.#loopCounter++;
      this.#currentIndex = 0;
      this.#resetUseLabel();
      if (this.#yoyo || this.#forceYoyo) this.#revertTween();
      this.#forceYoyo = false;
      this.#run();
    }
    /**
     * @type {import('./type.js').AsyncTimelineAddToActiveTween}
     */
    #addToActiveTween(tween2) {
      const tweenId = tween2?.getId && tween2.getId();
      if (!tweenId) return NOOP;
      const prevActiveTweenCounter = this.#activetweenCounter;
      this.#activetweenCounter++;
      this.#currentTween.push({
        tween: tween2,
        uniqueId: tweenId,
        id: prevActiveTweenCounter
      });
      return () => {
        this.#currentTween = this.#currentTween.filter(
          ({ id }) => id !== prevActiveTweenCounter
        );
      };
    }
    /**
     * Revert main tweenList array. When timeline run inverse, run from currentIndex equal 0 but with an array reverted
     * and tween props reverted.
     *
     * @type {() => void}
     */
    #revertTween() {
      this.#isReverse = !this.#isReverse;
      this.#tweenList = this.#tweenList.reverse().map((group) => {
        return group.reverse().map((item) => {
          const { data } = item;
          const { action: action2, valuesFrom, prevValueTo, valuesTo } = data;
          const currentValueTo = valuesTo;
          switch (action2) {
            case "goTo": {
              return {
                ...item,
                data: {
                  ...data,
                  valuesTo: prevValueTo,
                  prevValueTo: currentValueTo
                }
              };
            }
            case "goFromTo": {
              return {
                ...item,
                data: {
                  ...data,
                  valuesFrom: valuesTo,
                  valuesTo: valuesFrom
                }
              };
            }
            case "goFrom": {
              if (!this.#forceFromTo) {
                timelineReverseGoFromWarning();
                this.stop();
              }
              return {
                ...item,
                data: {
                  ...data,
                  valuesFrom: valuesTo,
                  valuesTo: valuesFrom
                }
              };
            }
          }
          return item;
        });
      });
    }
    /**
     * Common method, add all action to main array
     *
     * @type {import('./type.js').AsyncTimelineAddAction}
     */
    #addAction(obj) {
      const rowIndex = this.#tweenList.findIndex((item) => {
        return item[0]?.group && item[0].group === this.#groupId;
      });
      if (rowIndex !== -1) {
        this.#tweenList[rowIndex].push({ group: this.#groupId, data: obj });
        return;
      }
      this.#tweenList.push([{ group: this.#groupId, data: obj }]);
    }
    /**
     * Register all tween used in timeline.
     *
     * @type {import('./type.js').AsyncTimelineAddTweenToStore} tween
     */
    #addTweenToStore(tween2) {
      const uniqueId = tween2?.getId?.();
      const tweenIsStored = this.#tweenStore.find(
        ({ id }) => id === uniqueId
      );
      if (tweenIsStored) return;
      const obj = { id: uniqueId, tween: tween2 };
      this.#tweenStore.push(obj);
    }
    /**
     * Reset all tween used in timeline.
     *
     * @type {() => void}
     */
    #resetAllTween() {
      this.#tweenStore.forEach(({ tween: tween2 }) => tween2.resetData());
    }
    /**
     * @type {import('./type.js').AsyncTimelineSet}
     */
    set(tween2, valuesSet = {}, tweenProps = {}) {
      if (!asyncTimelineTweenIsValid(tween2)) return this;
      tweenProps.delay = asyncTimelineDelayIsValid(tweenProps?.delay);
      const previousValues = this.#inheritProps ? reduceTweenUntilIndex({
        timeline: this.#tweenList,
        tween: tween2,
        index: this.#tweenList.length
      }) : {};
      this.#currentTweenCounter++;
      this.#addAction({
        ...this.#defaultObj,
        id: this.#currentTweenCounter,
        tween: tween2,
        action: "set",
        valuesTo: { ...previousValues, ...valuesSet },
        valuesFrom: { ...previousValues, ...valuesSet },
        tweenProps,
        groupProps: { waitComplete: this.#waitComplete }
      });
      this.#addTweenToStore(tween2);
      return this;
    }
    /**
     * @type {import('./type.js').AsyncTimelineGoTo}
     */
    goTo(tween2, valuesTo = {}, tweenProps = {}) {
      if (!asyncTimelineTweenIsValid(tween2)) return this;
      tweenProps.delay = asyncTimelineDelayIsValid(tweenProps?.delay);
      const inheritProps = reduceTweenUntilIndex({
        timeline: this.#tweenList,
        tween: tween2,
        index: this.#tweenList.length
      });
      const previousValues = this.#inheritProps || this.#forceFromTo ? inheritProps : {};
      this.#currentTweenCounter++;
      if (this.#forceFromTo) {
        this.#addAction({
          ...this.#defaultObj,
          id: this.#currentTweenCounter,
          tween: tween2,
          action: "goFromTo",
          valuesFrom: { ...previousValues },
          valuesTo: { ...previousValues, ...valuesTo },
          tweenProps: tweenProps ?? {},
          groupProps: { waitComplete: this.#waitComplete }
        });
      } else {
        this.#addAction({
          ...this.#defaultObj,
          id: this.#currentTweenCounter,
          tween: tween2,
          action: "goTo",
          valuesTo: { ...previousValues, ...valuesTo },
          tweenProps: tweenProps ?? {},
          groupProps: { waitComplete: this.#waitComplete }
        });
      }
      this.#addTweenToStore(tween2);
      return this;
    }
    /**
     * @type {import('./type.js').AsyncTimelineGoFrom}
     */
    goFrom(tween2, valuesFrom = {}, tweenProps = {}) {
      if (!asyncTimelineTweenIsValid(tween2)) return this;
      tweenProps.delay = asyncTimelineDelayIsValid(tweenProps?.delay);
      const inheritProps = reduceTweenUntilIndex({
        timeline: this.#tweenList,
        tween: tween2,
        index: this.#tweenList.length
      });
      const previousValues = this.#inheritProps || this.#forceFromTo ? inheritProps : {};
      this.#currentTweenCounter++;
      if (this.#forceFromTo) {
        this.#addAction({
          ...this.#defaultObj,
          id: this.#currentTweenCounter,
          tween: tween2,
          action: "goFromTo",
          valuesFrom: { ...previousValues, ...valuesFrom },
          valuesTo: { ...previousValues },
          tweenProps: tweenProps ?? {},
          groupProps: { waitComplete: this.#waitComplete }
        });
      } else {
        this.#addAction({
          ...this.#defaultObj,
          id: this.#currentTweenCounter,
          tween: tween2,
          action: "goFrom",
          valuesFrom: { ...previousValues, ...valuesFrom },
          tweenProps,
          groupProps: { waitComplete: this.#waitComplete }
        });
      }
      this.#addTweenToStore(tween2);
      return this;
    }
    /**
     * @type {import('./type.js').AsyncTimelineGoFromTo}
     */
    goFromTo(tween2, valuesFrom = {}, valuesTo = {}, tweenProps = {}) {
      if (!asyncTimelineTweenIsValid(tween2)) return this;
      tweenProps.delay = asyncTimelineDelayIsValid(tweenProps?.delay);
      const previousValues = this.#inheritProps ? reduceTweenUntilIndex({
        timeline: this.#tweenList,
        tween: tween2,
        index: this.#tweenList.length
      }) : {};
      this.#currentTweenCounter++;
      this.#addAction({
        ...this.#defaultObj,
        id: this.#currentTweenCounter,
        tween: tween2,
        action: "goFromTo",
        valuesFrom: { ...previousValues, ...valuesFrom },
        valuesTo: { ...previousValues, ...valuesTo },
        tweenProps,
        groupProps: { waitComplete: this.#waitComplete }
      });
      this.#addTweenToStore(tween2);
      return this;
    }
    /**
     * @type {import('./type.js').AsyncTimelineAdd}
     */
    add(fn = NOOP) {
      const callback2 = functionIsValidAndReturnDefault(
        fn,
        () => {
        },
        "timeline add function"
      );
      if (this.#groupId) {
        asyncTimelineMetodsInsideGroupWarining("add");
        return this;
      }
      this.#currentTweenCounter++;
      this.#addAction({
        ...this.#defaultObj,
        id: this.#currentTweenCounter,
        callback: callback2,
        action: "add",
        groupProps: { waitComplete: this.#waitComplete }
      });
      return this;
    }
    /**
     * @type {import('./type.js').AsyncTimelineAddAsync}
     */
    addAsync(fn) {
      const callback2 = addAsyncFunctionIsValid(fn);
      if (this.#groupId) {
        asyncTimelineMetodsInsideGroupWarining("addAsync");
        return this;
      }
      this.#currentTweenCounter++;
      this.#addAction({
        ...this.#defaultObj,
        id: this.#currentTweenCounter,
        callback: callback2,
        action: "addAsync",
        groupProps: { waitComplete: this.#waitComplete }
      });
      return this;
    }
    /**
     * @type {import('./type.js').AsyncTimelineCreateGroup}
     */
    createGroup(groupProps = {}) {
      if (this.#groupId) {
        asyncTimelineMetodsInsideGroupWarining("createGroup");
        return this;
      }
      this.#currentTweenCounter++;
      this.#addAction({
        ...this.#defaultObj,
        id: this.#currentTweenCounter,
        action: "createGroup",
        groupProps
      });
      this.#waitComplete = groupProps?.waitComplete ?? false;
      this.#groupId = this.#groupCounter++;
      return this;
    }
    /**
     * @type {import('./type.js').AsyncTimelineCloseGroup}
     */
    closeGroup() {
      this.#groupId = void 0;
      this.#currentTweenCounter++;
      this.#addAction({
        ...this.#defaultObj,
        id: this.#currentTweenCounter,
        action: "closeGroup"
      });
      this.#waitComplete = false;
      return this;
    }
    /**
     * @type {import('./type.js').AsyncTimelineSuspend}
     */
    suspend(fn = () => true) {
      if (this.#groupId) {
        asyncTimelineMetodsInsideGroupWarining("suspend");
        return this;
      }
      this.#currentTweenCounter++;
      this.#addAction({
        ...this.#defaultObj,
        id: this.#currentTweenCounter,
        callback: fn,
        action: "suspend",
        groupProps: { waitComplete: this.#waitComplete }
      });
      return this;
    }
    /**
     * @type {import('./type.js').AsyncTimelineLabel}
     */
    label(labelProps = {}) {
      if (this.#groupId) {
        asyncTimelineMetodsInsideGroupWarining("label");
        return this;
      }
      if (!valueStringIsValid(labelProps?.name, "asyncTimeline label:"))
        return this;
      this.#currentTweenCounter++;
      this.#addAction({
        ...this.#defaultObj,
        id: this.#currentTweenCounter,
        action: "label",
        labelProps,
        groupProps: { waitComplete: this.#waitComplete }
      });
      return this;
    }
    /**
     * AutoSet: Add a set 'tween' at start and end of timeline.
     *
     * @type {() => void}
     */
    #addSetBlocks() {
      if (this.#autoSetIsJustCreated) return;
      this.#autoSetIsJustCreated = true;
      this.#tweenStore.forEach(({ tween: tween2 }) => {
        const setValueTo = tween2.getInitialData();
        this.#currentTweenCounter++;
        this.#tweenList = [
          [
            {
              group: void 0,
              data: {
                ...this.#defaultObj,
                id: this.#currentTweenCounter,
                tween: tween2,
                action: "set",
                valuesFrom: setValueTo,
                valuesTo: setValueTo,
                groupProps: { waitComplete: this.#waitComplete }
              }
            }
          ],
          ...this.#tweenList
        ];
      });
      this.#tweenStore.forEach(({ tween: tween2 }) => {
        const setValueTo = reduceTweenUntilIndex({
          timeline: this.#tweenList,
          tween: tween2,
          index: this.#tweenList.length
        });
        this.#currentTweenCounter++;
        this.#tweenList.push([
          {
            group: void 0,
            data: {
              ...this.#defaultObj,
              id: this.#currentTweenCounter,
              tween: tween2,
              action: "set",
              valuesFrom: setValueTo,
              valuesTo: setValueTo,
              groupProps: { waitComplete: this.#waitComplete }
            }
          }
        ]);
      });
    }
    /**
     * Execute a set() method of specified tweens at specified label
     *
     * @type {import('./type.js').AsyncTimelineSetTween}
     */
    setTween(label = "", items = []) {
      this.stop();
      const itemsIsArray = timelineSetTweenArrayIsValid(items);
      const labelIsString = timelineSetTweenLabelIsValid(label);
      if (!itemsIsArray || !labelIsString)
        return Promise.reject(
          new Error("timeline setTween: props is wrong")
        );
      const itemsId = new Set(items.map((item) => item?.getId?.()));
      const tweens = this.#tweenStore.filter(({ id }) => {
        return itemsId.has(id);
      });
      const index = this.#tweenList.findIndex((item) => {
        const [firstItem] = item;
        const labelCheck = firstItem.data.labelProps?.name;
        return labelCheck === label;
      });
      if (index === -1) {
        timelineSetTweenLabelNotFoundWarining(label);
        return Promise.reject(
          new Error(`asyncTimeline.setTween() label: ${label} not found`)
        );
      }
      return new Promise((resolve) => {
        const tweenPromise = tweens.map(({ tween: tween2 }) => {
          const data = reduceTweenUntilIndex({
            timeline: this.#tweenList,
            tween: tween2,
            index
          });
          return new Promise((resolveTween, rejectTween) => {
            tween2.set(data).then(() => resolveTween({ resolve: true })).catch(() => rejectTween());
          });
        });
        Promise.all(tweenPromise).then(() => {
          resolve({ resolve: true });
        }).catch(() => {
          timelineSetTweenFailWarining();
        });
      });
    }
    /**
     * Reject promise without error in console ( Firefix do not ).
     */
    #rejectPromise() {
      if (this.#currentReject) {
        this.#currentReject(modules_exports.ANIMATION_STOP_REJECT);
        this.#currentReject = void 0;
      }
    }
    /**
     * Utils for play() / playReverse() / etc...
     */
    async #waitFps() {
      if (this.#fpsIsInLoading)
        return Promise.reject(modules_exports.ANIMATION_STOP_REJECT);
      this.#fpsIsInLoading = true;
      await modules_exports.useFps();
      this.#fpsIsInLoading = false;
    }
    /**
     * @type {import('./type.js').AsyncTimelinePlayFrom}
     */
    async playFrom(label) {
      await this.#waitFps();
      return this.#playFromUpDown(label, false);
    }
    /**
     * @type {import('./type.js').AsyncTimelinePlayFrom}
     */
    async playFromReverse(label) {
      await this.#waitFps();
      return this.#playFromUpDown(label, true);
    }
    /**
     * FLow:
     *
     * 2. Execute test loop via this.playReverse() to set `prevValueSettled`.
     * 3. Then when timeline reach the end useLabel is reassigned, so walk thru right label.
     *
     * @type {import('./type.js').AsyncTimelinePlayUpeDown}
     */
    #playFromUpDown(label, isReverse) {
      return new Promise((resolve, reject) => {
        this.playReverse({
          forceYoYo: false,
          resolve,
          reject,
          callback: () => {
            if (this.#tweenList.length === 0 || this.#addAsyncIsActive)
              return;
            if (this.#isReverse) this.#revertTween();
            this.#currentIndex = 0;
            this.#useLabel = {
              isReverse,
              active: true,
              index: modules_exports.checkType(String, label) ? this.#tweenList.findIndex((item) => {
                const [firstItem] = item;
                const labelCheck = firstItem.data.labelProps?.name;
                return labelCheck === label;
              }) : label,
              callback: void 0
            };
            if (modules_exports.checkType(String, label))
              playLabelIsValid(this.#useLabel.index, label);
            this.#run();
          }
        });
      });
    }
    /**
     * 1. Execute test loop via this.playReverse() to set `prevValueSettled`.
     * 2. Then when timeline reach the end run from currentIndex 0, ( stop() reset currentIndex )
     *
     * @type {() => Promise<any>}
     */
    async play() {
      await this.#waitFps();
      return new Promise((resolve, reject) => {
        if (this.#autoSet) this.#addSetBlocks();
        if (this.#freeMode) {
          if (this.#tweenList.length === 0 || this.#addAsyncIsActive)
            return;
          this.stop();
          this.#isStopped = false;
          if (this.#isReverse) this.#revertTween();
          this.#sessionId++;
          modules_exports.useFrameIndex(() => {
            this.#currentReject = reject;
            this.#currentResolve = resolve;
            this.#run();
          }, 1);
          return;
        }
        this.playReverse({
          forceYoYo: false,
          callback: () => {
            this.stop();
            this.#isStopped = false;
            const tweenPromise = this.#tweenStore.map(({ tween: tween2 }) => {
              const data = tween2.getInitialData();
              return new Promise((resolve2, reject2) => {
                tween2.set(data).then(() => resolve2({ resolve: true })).catch(() => reject2());
              });
            });
            Promise.all(tweenPromise).then(() => {
              this.#currentReject = reject;
              this.#currentResolve = resolve;
              this.#run();
            }).catch(() => {
            });
          }
        });
      });
    }
    /**
     * 1. Run a test loop to update prevValueSettled
     *
     * 2a) callback is defined: When timeline reach the end fire this callback.
     *
     * 2b) no callback is defined && forceYoYo = true ( this.playReverse() clean ): this.#forceYoYo = true force
     * timeline to fire this.#revertTween() that revert main timeline array and then go on naturally after test loop.
     *
     * 2c) no callback is defined && forceYoYo = false ( this.play ) start from 0 after test loop
     *
     * @type {import('./type.js').AsyncTimelinePlayReverse}
     */
    async playReverse({
      forceYoYo = true,
      callback: callback2,
      resolve = null,
      reject = null
    } = {}) {
      await this.#waitFps();
      return new Promise((thisResolve, thisReject) => {
        const currentResolve = resolve ?? thisResolve;
        const currentReject = reject ?? thisReject;
        const forceYoYoNow = forceYoYo;
        if (this.#autoSet) this.#addSetBlocks();
        if (this.#tweenList.length === 0 || this.#addAsyncIsActive) return;
        this.stop();
        this.#isStopped = false;
        if (forceYoYoNow) this.#forceYoyo = true;
        this.#useLabel = {
          active: true,
          index: this.#tweenList.length,
          isReverse: false,
          callback: callback2
        };
        this.#loopCounter--;
        this.#sessionId++;
        modules_exports.useFrameIndex(() => {
          this.#currentResolve = currentResolve;
          this.#currentReject = currentReject;
          this.#run();
        }, 1);
      });
    }
    /**
     * @type {() => void}
     */
    reverseNext() {
      this.#isReverseNext = true;
    }
    /**
     * @type {import('./type.js').AsyncTimelineStop}
     */
    stop({ clearCache = true } = {}) {
      this.#isStopped = true;
      this.#currentIndex = 0;
      this.#loopCounter = 1;
      this.#rejectPromise();
      this.#isReverseNext = false;
      this.#resetUseLabel();
      this.#forceYoyo = false;
      this.#isInPause = false;
      this.#isInSuspension = false;
      this.#addAsyncIsActive = false;
      this.#timeOnPause = 0;
      this.#tweenStore.forEach(({ tween: tween2 }) => {
        tween2?.stop?.({ clearCache });
      });
      if (this.#isReverse) this.#revertTween();
      this.#isReverse = false;
      if (!this.#freeMode) this.#resetAllTween();
    }
    /**
     * @type {import('./type.js').AsyncTimelinePause}
     */
    pause() {
      if (this.#isInPause) return;
      this.#isInPause = true;
      this.#timeOnPause = modules_exports.getTime();
      this.#pauseAllTween();
    }
    /**
     * @type {import('./type.js').AsyncTimelineResume}
     */
    resume() {
      if (this.#isInPause) {
        this.#isInPause = false;
        this.#timeOnPause = 0;
        this.#resumeAllTween();
      }
      if (this.#isInSuspension) {
        this.#isInSuspension = false;
        this.#timeOnPause = 0;
        if (this.#currentIndex <= this.#tweenList.length - 2) {
          this.#currentIndex++;
          this.#run();
          return;
        }
        if (this.#currentIndex === this.#tweenList.length - 1) {
          this.#currentIndex = this.#yoyo && !this.#isReverse ? 1 : 0;
          this.#resetUseLabel();
          if (this.#yoyo) this.#revertTween();
          this.#loopCounter++;
          this.#run();
        }
      }
    }
    /**
     * @returns {void}
     */
    #pauseAllTween() {
      this.#currentTween.forEach(({ tween: tween2 }) => {
        tween2?.pause?.();
      });
    }
    /**
     * @returns {void}
     */
    #resumeAllTween() {
      this.#currentTween.forEach(({ tween: tween2 }) => {
        tween2?.resume?.();
      });
    }
    /**
     * Unfreeze stagger used with subscribeCache. Use es: play after pause need restore stagger cache
     *
     * @returns {void}
     */
    // #unFreezeAllTweenStagger() {
    //     this.#currentTween.forEach(({ tween }) => {
    //         tween?.unFreezeStagger?.();
    //     });
    // }
    /**
     * @type {() => void}
     */
    #resetUseLabel() {
      this.#useLabel = {
        active: false,
        index: -1,
        isReverse: false,
        callback: void 0
      };
    }
    /**
     * Get an array of active instance.
     *
     * @example
     *     ```javascript
     *     const tweens = myTimeline.get()
     *
     *
     *     ```;
     *
     * @returns {import('./type.js').AsyncTimelineCurrentTween[]} - Returns an array with all tweens active at the time
     *   the method is called
     */
    get() {
      return this.#currentTween;
    }
    /**
     * Return active state.
     *
     * @example
     *     ```javascript
     *     const isActive = myTimeline.isActive();
     *
     *
     *     ```;
     *
     * @returns {boolean} Returns a boolean value indicating whether the timeline is active
     */
    isActive() {
      return !this.#isStopped;
    }
    /**
     * Return pause state.
     *
     * @example
     *     ```javascript
     *     const isPaused = myTimeline.isPaused():
     *
     *
     *     ```;
     *
     * @returns {boolean} Returns a boolean value indicating whether the timeline is in pause
     */
    isPaused() {
      return this.#isInPause;
    }
    /**
     * Return suspended state.
     *
     * @example
     *     ```javascript
     *     const isSuspended = myTimeline.isSuspended();
     *
     *
     *     ```;
     *
     * @returns {boolean} Returns a boolean value indicating whether the timeline is suspended
     */
    isSuspended() {
      return this.#isInSuspension;
    }
    /**
     * Return current direction.
     *
     * @example
     *     ```javascript
     *     const direction = myTimeline.getDirection();
     *
     *
     *     ```;
     *
     * @returns {import('../utils/timeline/type.js').DirectionType} Returns a boolean value indicating whether the
     *   timeline is suspended
     */
    getDirection() {
      if (this.#isStopped) return directionConstant.NONE;
      return this.#isReverse ? directionConstant.BACKWARD : directionConstant.FORWARD;
    }
    /**
     * @type {import('./type.js').AsyncTimelineOnLoopEnd}
     */
    onLoopEnd(cb) {
      this.#callbackLoop.push({ cb, id: this.#id });
      const cbId = this.#id;
      return () => {
        this.#callbackLoop = this.#callbackLoop.filter(
          (item) => item.id !== cbId
        );
      };
    }
    /**
     * @type {import('./type.js').AsyncTimelineOnComplete}
     */
    onComplete(cb) {
      this.#callbackComplete.push({ cb, id: this.#id });
      const cbId = this.#id;
      this.#id++;
      return () => {
        this.#callbackComplete = this.#callbackComplete.filter(
          (item) => item.id !== cbId
        );
      };
    }
    /**
     * Destroy timeline and all the sequencer
     */
    destroy() {
      this.#tweenStore.forEach(({ tween: tween2 }) => {
        tween2?.destroy?.();
      });
      this.#tweenList = [];
      this.#currentTween = [];
      this.#callbackComplete = [];
      this.#callbackLoop = [];
      this.#tweenStore = [];
      this.#currentIndex = 0;
      this.#useLabel = {
        active: false,
        callback: void 0,
        index: -1,
        isReverse: false
      };
    }
  };

  // src/js/mob/mob-motion/animation/sync-timeline/mob-sync-timeline.js
  var MobSyncTimeline = class {
    /**
     * @type {number}
     */
    #duration;
    /**
     * @type {boolean}
     */
    #yoyo;
    /**
     * @type {number}
     */
    #repeat;
    /**
     * @type {import('./type.js').SyncTimelineSequencers[]}
     */
    #sequencers;
    /**
     * @type {number}
     */
    #startTime;
    /**
     * @type {number}
     */
    #timeElapsed;
    /**
     * @type {number}
     */
    #currentTime;
    /**
     * @type {number}
     */
    #pauseTime;
    /**
     * @type {number}
     */
    #timeAtReverse;
    /**
     * @type {number}
     */
    #timeAtReverseBack;
    /**
     * @type {boolean}
     */
    #isReverse;
    /**
     * @type {boolean}
     */
    #startReverse;
    /**
     * @type {boolean}
     */
    #isPlayngReverse;
    /**
     * @type {number}
     */
    #loopCounter;
    /**
     * @type {number}
     */
    #loopIteration;
    /**
     * @type {number}
     */
    #minLoopIteration;
    /**
     * @type {boolean}
     */
    #isStopped;
    /**
     * @type {boolean}
     */
    #skipFirstRender;
    /**
     * @type {boolean}
     */
    #completed;
    /**
     * @type {boolean}
     */
    #fpsIsInLoading;
    /**
     * @type {boolean}
     */
    #isInPause;
    /**
     * @type {number}
     */
    #callbackId;
    /**
     * @type {import('./type.js').SyncTimelineEvent<{
     *     direction: import('../utils/timeline/type.js').DirectionType;
     *     loop: number;
     * }>[]}
     */
    #callbackLoop;
    /**
     * @type {import('./type.js').SyncTimelineEvent<void>[]}
     */
    #callbackComplete;
    /**
     * @type {import('./type.js').SyncTimelineEvent<{
     *     time: number;
     *     direction: import('../utils/timeline/type.js').DirectionType;
     * }>[]}
     */
    #callbackOnUpdate;
    /**
     * @type{((value:any) => void)|undefined}
     */
    #currentResolve;
    /**
     * @type{((value:any) => void)|undefined}
     */
    #currentReject;
    /**
     * Available methods:
     *
     * ```javascript
     * myTimeline.add();
     * myTimeline.onLoopEnd();
     * myTimeline.onComplete();
     * myTimeline.onUpdate();
     * myTimeline.stop();
     * myTimeline.play();
     * myTimeline.playReverse();
     * myTimeline.playFrom();
     * myTimeline.playFromReverse();
     * myTimeline.reverse();
     * myTimeline.pause();
     * myTimeline.resume();
     * myTimeline.isActive();
     * myTimeline.isPaused();
     * myTimeline.getDirection();
     * myTimeline.getTime();
     * myTimeline.destroy();
     * ```
     *
     * @example
     *     ```javascript
     *     const myTimeline = new HandleSyncTimeline({
     *       duration: [ Number ],
     *       yoyo: [ Boolean ],
     *       repeat: [ Number ]
     *     })
     *
     *
     *     ```;
     *
     * @param {import('./type.js').SyncTimeline} data
     */
    constructor(data = {}) {
      this.#duration = durationIsValid(data?.duration);
      this.#yoyo = valueIsBooleanAndReturnDefault(
        data?.yoyo,
        "syncTimeline: yoyo",
        false
      );
      this.#repeat = repeatIsValid(data?.repeat);
      this.#sequencers = [];
      this.#startTime = 0;
      this.#timeElapsed = 0;
      this.#currentTime = 0;
      this.#pauseTime = 0;
      this.#timeAtReverse = 0;
      this.#timeAtReverseBack = 0;
      this.#isReverse = false;
      this.#startReverse = false;
      this.#isPlayngReverse = false;
      this.#loopCounter = 0;
      this.#loopIteration = 0;
      this.#minLoopIteration = 10;
      this.#isStopped = true;
      this.#skipFirstRender = false;
      this.#completed = false;
      this.#fpsIsInLoading = false;
      this.#isInPause = false;
      this.#callbackId = 0;
      this.#callbackLoop = [];
      this.#callbackComplete = [];
      this.#callbackOnUpdate = [];
      this.#currentResolve = void 0;
      this.#currentReject = void 0;
    }
    /**
     * @param {number} time
     * @param {number} fps
     */
    #updateTime(time2, fps2) {
      if (this.#isStopped || this.#fpsIsInLoading) return;
      const frameThreshold = !this.#repeat || this.#repeat >= 2 && this.#loopCounter === this.#repeat - 1 ? 0 : 1e3 / fps2 / 2;
      if (this.#isInPause) {
        this.#pauseTime = time2 - this.#startTime - this.#timeElapsed - this.#timeAtReverseBack;
      }
      this.#timeElapsed = Math.trunc(
        time2 - this.#startTime - this.#pauseTime - this.#timeAtReverseBack
      );
      const partial = this.#isReverse ? this.#timeAtReverse - (this.#timeElapsed - this.#timeAtReverse) : this.#timeElapsed;
      if (!this.#isInPause) {
        this.#currentTime = clamp3(partial, 0, this.#duration);
        if (!this.#skipFirstRender) {
          this.#sequencers.forEach((item) => {
            item.draw({
              partial: this.#currentTime,
              isLastDraw: false,
              useFrame: true,
              direction: this.getDirection()
            });
          });
          this.#callbackOnUpdate.forEach(({ cb }) => {
            cb({
              time: this.#currentTime,
              direction: this.getDirection()
            });
          });
        }
      }
      this.#skipFirstRender = false;
      this.#loopIteration++;
      if (partial <= this.#duration - frameThreshold && partial >= 0 + frameThreshold && !this.#isStopped) {
        this.#completed = false;
        this.#goToNextFrame();
        return;
      }
      this.#resetSequencerLastValue();
      if (this.#startReverse) {
        this.#isReverse = true;
        this.#timeAtReverse = 0;
        this.#timeAtReverseBack = 0;
        this.#startReverse = false;
        this.#goToNextFrame();
        return;
      }
      const direction2 = this.getDirection();
      modules_exports.useNextFrame(() => {
        if (!this.#fpsIsInLoading && !this.#completed && this.#loopIteration > this.#minLoopIteration) {
          this.#completed = true;
          this.#loopCounter++;
          this.#loopIteration = 0;
          this.#callbackLoop.forEach(
            ({ cb }) => cb({
              direction: direction2,
              loop: this.#loopCounter
            })
          );
        }
      });
      if (!this.#repeat || this.#loopCounter === this.#repeat - 1 && this.#loopIteration > this.#minLoopIteration) {
        const endTime = this.#currentTime;
        this.#sequencers.forEach((item) => {
          item.draw({
            partial: endTime,
            isLastDraw: true,
            useFrame: true,
            direction: this.getDirection()
          });
        });
        this.#isStopped = true;
        this.#resetTime();
        this.#startTime = time2;
        if (this.#isReverse) this.#isReverse = false;
        this.#callbackComplete.forEach(({ cb }) => cb());
        if (this.#currentResolve) this.#currentResolve(true);
        return;
      }
      if (this.#yoyo) {
        this.reverse();
        this.#goToNextFrame();
        return;
      }
      if (this.#isPlayngReverse) {
        this.#resetTime();
        this.#startTime = time2;
        if (!this.#isReverse)
          this.#isPlayngReverse = !this.#isPlayngReverse;
        this.#timeElapsed = this.#duration;
        this.#currentTime = this.#duration;
        this.#pauseTime = this.#duration;
        this.#goToNextFrame();
        return;
      }
      this.#resetTime();
      this.#startTime = time2;
      if (this.#isReverse) this.#isPlayngReverse = !this.#isPlayngReverse;
      this.#goToNextFrame();
    }
    /**
     * @returns {void}
     */
    #goToNextFrame() {
      modules_exports.useFrame(() => {
        modules_exports.useNextTick(({ time: time2, fps: fps2 }) => {
          if (!this.#fpsIsInLoading) this.#updateTime(time2, fps2);
        });
      });
    }
    /**
     * @returns {void}
     */
    #resetTime() {
      this.#timeElapsed = 0;
      this.#pauseTime = 0;
      this.#currentTime = 0;
      this.#timeAtReverse = 0;
      this.#timeAtReverseBack = 0;
    }
    /**
     * @param {string} label
     * @returns {number}
     */
    #getTimeFromLabel(label) {
      const labelObj = this.#sequencers.reduce(
        (previous, current) => {
          const currentLabels = current.getLabels();
          const labelsMatched = currentLabels.find(
            ({ name: currentName }) => currentName === label
          );
          return labelsMatched || previous;
        },
        { name: "", time: 0 }
      );
      if (!labelObj) syncTimelineLabelWarning(label);
      return labelObj.time;
    }
    /**
     * @returns {void}
     */
    #rejectPromise() {
      if (this.#currentReject) {
        this.#currentReject(modules_exports.ANIMATION_STOP_REJECT);
        this.#currentReject = void 0;
      }
    }
    /**
     * Plays the timeline starting from the initial value With useCurrent set to true and with the timeline active, it
     * will reverse the direction from the current value if it is scrolling in reverse, otherwise it will continue in
     * the current direction. With useCurrent set to false (default) the animation will always start from frame 0
     * towards the final value.
     *
     * @type {import('./type.js').SyncTimelinePlay}
     */
    play(props = {}) {
      const useCurrent = props?.useCurrent;
      if (!useCurrent) this.stop();
      return new Promise((resolve, reject) => {
        if (this.#fpsIsInLoading) return;
        this.#rejectPromise();
        this.#currentResolve = resolve;
        this.#currentReject = reject;
        if (!this.#isStopped && !this.#isReverse && useCurrent) return;
        if (!this.#isStopped && this.#isReverse && useCurrent) {
          this.reverse();
          return;
        }
        this.#playFromTime();
      });
    }
    /**
     * Plays the timeline forward starting from the specific time or from a label defined in a Handle Sequencer |
     * HandleMasterSequencer instance
     *
     * @example
     *     ```javascript
     *     myTimeline.playFrom(1000).then(() => {
     *          // code
     *     })
     *
     *     myTimeline.playFrom('myLabel').then(() => {
     *          // code
     *     })
     *
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SyncTimelinePlayFrom} value
     */
    playFrom(value = 0) {
      this.stop();
      return new Promise((resolve, reject) => {
        if (this.#fpsIsInLoading) return;
        const isNumber = modules_exports.checkType(Number, value);
        const labelTime = isNumber ? value : this.#getTimeFromLabel(value);
        this.#rejectPromise();
        this.#currentResolve = resolve;
        this.#currentReject = reject;
        this.#playFromTime(labelTime);
      });
    }
    /**
     * @param {number} time
     */
    #playFromTime(time2 = 0) {
      this.#resetSequencerLastValue();
      this.#resetTime();
      this.#currentTime = time2;
      this.#timeAtReverseBack = -this.#currentTime;
      this.#isPlayngReverse = false;
      this.#loopIteration = 0;
      this.#fpsIsInLoading = true;
      this.#startAnimation(time2);
    }
    /**
     * Plays the timeline backward starting from the specific time or from a label defined in a Handle Sequencer |
     * HandleMasterSequencer instance
     *
     * @example
     *     ```javascript
     *     myTimeline.playFromReverse(1000).then(() => {
     *          // code
     *     })
     *
     *     myTimeline.playFromReverse('myLabel').then(() => {
     *          // code
     *     })
     *
     *
     *
     *     ```;
     *
     * @type {import('./type.js').syncTimelinePlayFromReverse} value
     */
    playFromReverse(value) {
      this.stop();
      return new Promise((resolve, reject) => {
        if (this.#fpsIsInLoading) return;
        const isNumber = modules_exports.checkType(Number, value);
        const labelTime = isNumber ? value : this.#getTimeFromLabel(value);
        this.#rejectPromise();
        this.#currentResolve = resolve;
        this.#currentReject = reject;
        this.#playFromTimeReverse(labelTime, true);
      });
    }
    /**
     * Plays the timeline starting from the end value With useCurrent set to true and with the timeline active, it will
     * reverse the direction from the current value if it is scrolling in reverse, otherwise it will continue in the
     * current direction. With useCurrent set to false (default) the animation will always start from the final value
     * towards the initial value.
     *
     * @example
     *     ```javascript
     *     myTimeline.playReverse({
     *          useCurrent: true
     *     }).then(() => {
     *          // code
     *     })
     *
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SyncTimelinePlayReverse}
     */
    playReverse(props = {}) {
      const useCurrent = props?.useCurrent;
      if (!useCurrent) this.stop();
      return new Promise((resolve, reject) => {
        if (this.#fpsIsInLoading) return;
        this.#rejectPromise();
        this.#currentResolve = resolve;
        this.#currentReject = reject;
        if (!this.#isStopped && this.#isReverse && useCurrent) return;
        if (!this.#isStopped && !this.#isReverse && useCurrent) {
          this.reverse();
          return;
        }
        this.#playFromTimeReverse(this.#duration, true);
      });
    }
    /**
     * @param {number} time
     * @returns {void}
     */
    #playFromTimeReverse(time2 = 0) {
      this.#resetSequencerLastValue();
      this.#timeElapsed = time2;
      this.#currentTime = time2;
      this.#pauseTime = time2;
      this.#timeAtReverse = 0;
      this.#timeAtReverseBack = 0;
      this.#startReverse = true;
      this.#isPlayngReverse = true;
      this.#skipFirstRender = true;
      this.#loopIteration = 0;
      this.#fpsIsInLoading = true;
      this.#startAnimation(time2);
    }
    /**
     * Find label than match the occurrency and return the time
     *
     * @param {number} partial
     * @returns {Promise<any>}
     */
    async #startAnimation(partial) {
      if (this.#repeat === 0) return;
      const { averageFPS } = await modules_exports.useFps();
      fpsLoadedLog("sequencer", averageFPS);
      this.#isReverse = false;
      this.#sequencers.forEach((item) => {
        item.inzializeStagger();
        item.disableStagger();
        item.draw({
          partial,
          isLastDraw: false,
          useFrame: true,
          direction: this.getDirection()
        });
      });
      modules_exports.useFrame(() => {
        modules_exports.useNextTick(({ time: time2, fps: fps2 }) => {
          this.#startTime = time2;
          this.#fpsIsInLoading = false;
          this.#isStopped = false;
          this.#isInPause = false;
          this.#loopCounter = 0;
          this.#updateTime(time2, fps2);
        });
      });
    }
    /**
     * @type {import('./type.js').SyncTimelinePause}
     */
    pause({ freezeCache = true } = {}) {
      if (this.#isStopped || this.#isInPause || this.#fpsIsInLoading) return;
      this.#isStopped = false;
      this.#isInPause = true;
      if (freezeCache) {
        this.#sequencers.forEach((item) => {
          item.freezeCachedId();
        });
        return;
      }
    }
    /**
     * @type {import('./type.js').SyncTimelineResume}
     */
    resume({ unFreezeCache = true } = {}) {
      if (this.#isStopped || !this.#isInPause || this.#fpsIsInLoading) return;
      this.#isStopped = false;
      this.#isInPause = false;
      if (unFreezeCache) {
        this.#sequencers.forEach((item) => {
          item.unFreezeCachedId();
        });
        return;
      }
    }
    /**
     * @type {import('./type.js').SyncTimelineReverse}
     */
    reverse() {
      if (this.#isStopped || this.#isInPause || this.#fpsIsInLoading) return;
      this.#resetSequencerLastValue();
      this.#isReverse = !this.#isReverse;
      if (this.#isReverse) {
        this.#timeAtReverse = this.#timeElapsed;
      } else {
        this.#timeAtReverseBack += this.#timeElapsed - this.#currentTime;
      }
    }
    /**
     * @type {import('./type.js').SyncTimelineStop}
     * @returns {void}
     */
    stop({ clearCache = true } = {}) {
      this.#isStopped = true;
      this.#isInPause = false;
      this.#rejectPromise();
      if (clearCache) {
        this.#sequencers.forEach((item) => {
          item.cleanCachedId();
        });
        return;
      }
      this.#sequencers.forEach((item) => {
        item.draw({
          partial: this.#currentTime,
          isLastDraw: true,
          useFrame: true,
          direction: this.getDirection()
        });
      });
    }
    /**
     * Add the instance of a sequencer | masterSequencer to the timeline
     *
     * @example
     *     ```javascript
     *     myTimeline.add(mySequencer);
     *     myTimeline.add(myMasterSequencer);
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SyncTimelineAdd}
     */
    add(sequencer) {
      sequencer.setStretchFactor(this.#duration);
      this.#sequencers.push(sequencer);
      return this;
    }
    /**
     * @type {import('./type.js').SyncTimelineSetDuration}
     */
    setDuration(duration2) {
      this.#duration = duration2;
      return this;
    }
    /**
     * @returns {void}
     */
    #resetSequencerLastValue() {
      this.#sequencers.forEach((item) => item.resetLastValue());
    }
    /**
     * Return active status
     *
     * @example
     *     ```javascript
     *     const isActive = myTimeline.isActive();
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SyncTimelineIsActive}
     */
    isActive() {
      return !this.#isStopped;
    }
    /**
     * Return pause status
     *
     * @example
     *     ```javascript
     *     const isPaused = myTimeline.isPaused();
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SyncTimelineIsPaused}
     */
    isPaused() {
      return this.#isInPause;
    }
    /**
     * Return direction forward|backward|none
     *
     * @example
     *     ```javascript
     *     myTimeline.getDirection();
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SyncTimelineGetDirection}
     */
    getDirection() {
      if (this.#isStopped) return directionConstant.NONE;
      return this.#isReverse ? directionConstant.BACKWARD : directionConstant.FORWARD;
    }
    /**
     * Get current time
     *
     * @example
     *     ```javascript
     *     myTimeline.getTime();
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SyncTimelineTime}
     */
    getTime() {
      return this.#currentTime;
    }
    /**
     * Callback thrown at the end of each cycle
     *
     * @example
     *     ```javascript
     *     const unsubscribeOnLoopEnd = myTimeline.onLoopEnd(({direction, loop})=>{
     *          /// code
     *     })
     *     unsubscribeOnLoopEnd();
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SyncTimelineOnLoopEnd}
     */
    onLoopEnd(cb = () => {
    }) {
      this.#callbackLoop.push({ cb, id: this.#callbackId });
      const cbId = this.#callbackId;
      this.#callbackId++;
      return () => {
        this.#callbackLoop = this.#callbackLoop.filter(
          (item) => item.id !== cbId
        );
      };
    }
    /**
     * Callback thrown at the end of timeline
     *
     * @example
     *     ```javascript
     *     const unsubscribeOnComplete = myTimeline.onComplete(() => {
     *          /// code
     *     })
     *     unsubscribeOnComplete();
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SyncTimelineOnComplete}
     */
    onComplete(cb = () => {
    }) {
      this.#callbackComplete.push({ cb, id: this.#callbackId });
      const cbId = this.#callbackId;
      this.#callbackId++;
      return () => {
        this.#callbackComplete = this.#callbackComplete.filter(
          (item) => item.id !== cbId
        );
      };
    }
    /**
     * Callback thrown at each frame during the animation
     *
     * @example
     *     ```javascript
     *     const unsubscribeOnUpdate = myTimeline.onUpdate(({direction, time}) => {
     *          /// code
     *     })
     *     unsubscribeOnUpdate();
     *
     *
     *     ```;
     *
     * @type {import('./type.js').SyncTimelineOnUpdate}
     */
    onUpdate(cb = () => {
    }) {
      this.#callbackOnUpdate.push({ cb, id: this.#callbackId });
      const cbId = this.#callbackId;
      this.#callbackId++;
      return () => {
        this.#callbackOnUpdate = this.#callbackOnUpdate.filter(
          (item) => item.id !== cbId
        );
      };
    }
    /**
     * Destroy timeline and all the sequencer
     */
    destroy() {
      this.stop();
      this.#sequencers.forEach((item) => item.destroy());
      this.#sequencers = [];
      this.#callbackOnUpdate = [];
      this.#callbackLoop = [];
      this.#callbackComplete = [];
    }
  };

  // src/js/mob/mob-motion/timeline.js
  function createSyncTimeline(data) {
    return new MobSyncTimeline(data);
  }
  function createAsyncTimeline(data) {
    return new MobAsyncTimeline(data);
  }

  // src/js/mob/mob-motion/scroller.js
  var scroller_exports = {};
  __export(scroller_exports, {
    createParallax: () => createParallax,
    createScrollTrigger: () => createScrollTrigger
  });

  // src/js/mob/mob-motion/animation/scroller/mob-scroller-emitter.js
  var action = ({ prevValue, value, maxVal }) => {
    if (value >= maxVal && prevValue <= maxVal && maxVal >= 0 || value <= maxVal && prevValue >= maxVal && maxVal <= 0)
      return MobScrollerConstant.ON_LEAVE;
    if (value > maxVal && prevValue <= maxVal && maxVal <= 0 || value < maxVal && prevValue >= maxVal && maxVal >= 0)
      return MobScrollerConstant.ON_ENTER_BACK;
    if (value >= 0 && prevValue <= 0 && maxVal <= 0 || value <= 0 && prevValue >= 0 && maxVal >= 0)
      return MobScrollerConstant.ON_LEAVE_BACK;
    if (value > 0 && value < maxVal && prevValue <= 0 && maxVal >= 0 || value < 0 && prevValue >= 0 && maxVal <= 0)
      return MobScrollerConstant.ON_ENTER;
    return MobScrollerConstant.ON_NOOP;
  };
  function MobScrollerEmitter({
    prevValue,
    value,
    maxVal,
    onEnter,
    onEnterBack,
    onLeave,
    onLeaveBack
  }) {
    const fn = {
      [MobScrollerConstant.ON_LEAVE]: () => {
        if (onLeave) onLeave();
      },
      [MobScrollerConstant.ON_ENTER_BACK]: () => {
        if (onEnterBack) onEnterBack();
      },
      [MobScrollerConstant.ON_LEAVE_BACK]: () => {
        if (onLeaveBack) onLeaveBack();
      },
      [MobScrollerConstant.ON_ENTER]: () => {
        if (onEnter) onEnter();
      },
      [MobScrollerConstant.ON_NOOP]: () => {
      }
    };
    fn[action({ prevValue, value, maxVal })]();
  }

  // src/js/mob/mob-motion/animation/scroller/mob-scroller-marker.js
  var getMarker = ({ startMarker, endMarker, label }) => {
    if (!startMarker && !endMarker) {
      const labelSanitized = label.replaceAll(/^[^a-z]+|[^\w.:-]+/gi, "-");
      const startMarkerEL = document.createElement("span");
      startMarkerEL.className += `p-marker p-marker--start  p-marker-${labelSanitized}`;
      startMarkerEL.innerHTML = `start ${labelSanitized}`;
      const endMarkerEL = document.createElement("span");
      endMarkerEL.className += `p-marker p-marker--end  p-marker-${labelSanitized}`;
      endMarkerEL.innerHTML = `end ${labelSanitized}`;
      document.body.append(startMarkerEL);
      document.body.append(endMarkerEL);
      const startMarkerGenerated = document.querySelector(
        `.p-marker--start.p-marker-${labelSanitized}`
      );
      const endMarkerElGenerated = document.querySelector(
        `.p-marker--end.p-marker-${labelSanitized}`
      );
      return {
        lastStartMarker: startMarkerGenerated ?? void 0,
        lastEndMarkerEl: endMarkerElGenerated ?? void 0
      };
    }
    return {
      lastStartMarker: startMarker,
      lastEndMarkerEl: endMarker
    };
  };
  var getPosition = ({ screen }) => {
    if (screen === globalThis) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    const rect = screen.getBoundingClientRect();
    return {
      top: rect.top,
      right: document.documentElement.clientWidth - // @ts-ignore
      (rect.left + screen.offsetWidth),
      // @ts-ignore
      bottom: window.innerHeight - (rect.top + screen.offsetHeight),
      left: rect.left
    };
  };
  var getStartStyle = ({
    startPoint,
    direction: direction2,
    invertSide,
    top,
    bottom,
    left,
    right
  }) => {
    if (direction2 === MobScrollerConstant.DIRECTION_VERTICAL) {
      return invertSide ? {
        right: 0,
        width: "100vw",
        height: "3px",
        top: `${startPoint + top}px`,
        padding: "0 30px",
        pointerEvents: "none"
      } : {
        right: 0,
        width: "100vw",
        height: "3px",
        bottom: `${startPoint + bottom}px`,
        padding: "0 30px",
        pointerEvents: "none"
      };
    }
    return invertSide ? {
      top: 0,
      height: "100vw",
      width: "3px",
      left: `${startPoint + left}px`,
      padding: "30px 0",
      pointerEvents: "none"
    } : {
      top: 0,
      height: "100vw",
      width: "3px",
      right: `${startPoint + right}px`,
      padding: "30px 0",
      pointerEvents: "none"
    };
  };
  var getEndStyle = ({
    startPoint,
    endPoint,
    direction: direction2,
    invertSide,
    top,
    bottom,
    left,
    right
  }) => {
    if (direction2 === MobScrollerConstant.DIRECTION_VERTICAL) {
      return invertSide ? {
        right: 0,
        width: "100vw",
        height: "3px",
        top: `${startPoint + endPoint + top}px`,
        padding: "0 30px",
        pointerEvents: "none"
      } : {
        right: 0,
        width: "100vw",
        height: "3px",
        bottom: `${startPoint + endPoint + bottom}px`,
        padding: "0 30px",
        pointerEvents: "none"
      };
    }
    return invertSide ? {
      top: 0,
      height: "100vw",
      width: "3px",
      left: `${startPoint + endPoint + left}px`,
      padding: "30px 0",
      pointerEvents: "none"
    } : {
      top: 0,
      height: "100vw",
      width: "3px",
      right: `${startPoint + endPoint + right}px`,
      padding: "30px 0",
      pointerEvents: "none"
    };
  };
  var MobScrollerMarker = ({
    startMarker,
    endMarker,
    startPoint,
    endPoint,
    screen,
    direction: direction2,
    invertSide,
    label
  }) => {
    const { lastStartMarker, lastEndMarkerEl } = getMarker({
      startMarker,
      endMarker,
      label
    });
    const { top, right, bottom, left } = getPosition({ screen });
    const startStyle = getStartStyle({
      startPoint,
      direction: direction2,
      invertSide,
      top,
      bottom,
      left,
      right
    });
    const endStyle = getEndStyle({
      startPoint,
      endPoint,
      direction: direction2,
      invertSide,
      top,
      bottom,
      left,
      right
    });
    const style = {
      position: "fixed",
      zIndex: "99999",
      background: handleSetUp.get("scrollTrigger")?.markerColor?.startEnd || "#ff0000",
      fontSize: "14px",
      whiteSpace: "nowrap",
      textTransform: "uppercase"
    };
    modules_exports.useFrame(() => {
      Object.assign(lastStartMarker?.style, { ...style, ...startStyle });
      Object.assign(lastEndMarkerEl?.style, { ...style, ...endStyle });
    });
    return {
      startMarker: lastStartMarker,
      endMarker: lastEndMarkerEl
    };
  };

  // src/js/mob/mob-motion/animation/scroller/mob-scroller-pin-utils.js
  var getMarkerWrapperStyle = ({ marker, direction: direction2, invertSide }) => {
    if (!marker) return {};
    const borderColor = handleSetUp.get("scrollTrigger")?.markerColor?.item || "#14df3b";
    const borderStyle = `3px ${borderColor} solid`;
    if (direction2 === MobScrollerConstant.DIRECTION_VERTICAL) {
      return invertSide ? { borderBottom: borderStyle } : { borderTop: borderStyle };
    } else {
      return invertSide ? { borderRight: borderStyle } : { borderLeft: borderStyle };
    }
  };

  // src/js/mob/mob-motion/animation/scroller/mob-scroller-pin.js
  var MobScrollerPin = class {
    /**
     * @type {number}
     */
    #scrollerHeight;
    /**
     * @type {number}
     */
    #start;
    /**
     * @type {number}
     */
    #startFromTop;
    /**
     * @type {boolean | undefined}
     */
    #invertSide;
    /**
     * @type {number}
     */
    #end;
    /**
     * @type{() => number}
     */
    #getStart;
    /**
     * @type{() => number}
     */
    #getEnd;
    /**
     * @type {string}
     */
    #direction;
    /**
     * @type {number}
     */
    #compesateValue;
    /**
     * @type {HTMLElement | null | undefined}
     */
    #item;
    /**
     * @type {MobSpring | undefined | null}
     */
    #spring;
    /**
     * @type {HTMLElement | undefined}
     */
    #wrapper;
    /**
     * @type {String | undefined}
     */
    #marker;
    /**
     * @type {globalThis | HTMLElement}
     */
    #screen;
    /**
     * @type {HTMLElement | undefined}
     */
    #pin;
    /**
     * @type {boolean}
     */
    #isOver;
    /**
     * @type {boolean}
     */
    #isInner;
    /**
     * @type {boolean}
     */
    #isUnder;
    /**
     * @type {Function}
     */
    #unsubscribeScroll;
    /**
     * @type {Function}
     */
    #unsubscribeScrollStart;
    /**
     * @type {Function}
     */
    #unsubscribeSpring;
    /**
     * @type {boolean}
     */
    #firstTime;
    /**
     * Item style applied to pin wrapper
     *
     * @type {string[]}
     */
    #itemRequireStyleToWrapper;
    /**
     * Item style get and applied itself when transpond
     *
     * @type {string[]}
     */
    #itemRequireStyleWhenTraspond;
    /**
     * Paerent style to applied to pin
     *
     * @type {string[]}
     */
    #parentRequireStyle;
    /**
     * Item style applied to pin
     *
     * @type {string[]}
     */
    #itemRequireStyleToPin;
    /**
     * Parent style that activate transpond
     *
     * @type {string[]}
     */
    #styleToTranspond;
    /**
     * Skip parent style to activate transpond above with this value
     *
     * @type {string[]}
     */
    #nonRelevantRule;
    /**
     * @type {boolean}
     */
    #isInizialized;
    /**
     * @type {number}
     */
    #prevScroll;
    /**
     * @type {number}
     */
    #prevscrollY;
    /**
     * @type {boolean}
     */
    #animatePin;
    /**
     * @type {number}
     */
    #anticipateFactor;
    /**
     * @type {boolean}
     */
    #forceTranspond;
    /**
     * @type {boolean}
     */
    #justPinned;
    /**
     * @type {number}
     */
    #afterPinCounter;
    /**
     * @type {number}
     */
    #lastStep;
    /**
     * @type {boolean}
     */
    #afterJustPinned;
    /**
     * @type {number}
     */
    #afterJustPinnedCounter;
    /**
     * @type {number}
     */
    #numeCycleToFreeze;
    /**
     * @type {string}
     */
    #collisionStyleProp;
    /**
     * @type {boolean}
     */
    #shoulTranspond;
    /**
     * @type {boolean}
     */
    #anticipatePinOnLoad;
    constructor() {
      this.#scrollerHeight = 0;
      this.#start = 0;
      this.#startFromTop = 0;
      this.#invertSide = void 0;
      this.#end = 0;
      this.#getStart = () => 0;
      this.#getEnd = () => 0;
      this.#direction = MobScrollerConstant.DIRECTION_VERTICAL;
      this.#compesateValue = 0;
      this.#item = void 0;
      this.#spring = void 0;
      this.#wrapper = void 0;
      this.#pin = void 0;
      this.#isOver = false;
      this.#isInner = false;
      this.#isUnder = false;
      this.#unsubscribeScroll = () => {
      };
      this.#unsubscribeScrollStart = () => {
      };
      this.#unsubscribeSpring = () => {
      };
      this.#firstTime = true;
      this.#marker = void 0;
      this.#screen = globalThis;
      this.#collisionStyleProp = "left";
      this.#anticipatePinOnLoad = true;
      this.#shoulTranspond = false;
      this.#itemRequireStyleToWrapper = [
        "flex",
        "flex-shrink",
        "flex-basis",
        "float",
        "display",
        "grid-area",
        "grid-column-start",
        "grid-column-end",
        "grid-row-start",
        "grid-row-end",
        "box-sizing",
        "order",
        "place-self",
        "align-self",
        "justify-self"
      ];
      this.#itemRequireStyleWhenTraspond = [
        "font-size",
        "padding",
        "margin",
        "line-height",
        "white-space"
      ];
      this.#parentRequireStyle = ["text-align"];
      this.#itemRequireStyleToPin = ["z-index", "pointer-events"];
      this.#styleToTranspond = [
        "transform",
        "position",
        "translate",
        "rotate",
        "scale"
      ];
      this.#nonRelevantRule = ["none", "static"];
      this.#isInizialized = false;
      this.#prevScroll = 0;
      this.#prevscrollY = 0;
      this.#animatePin = false;
      this.#anticipateFactor = 1.5;
      this.#forceTranspond = false;
      this.#justPinned = false;
      this.#afterPinCounter = 0;
      this.#lastStep = 0;
      this.#afterJustPinned = false;
      this.#afterJustPinnedCounter = 0;
      this.#numeCycleToFreeze = 3;
    }
    /**
     * @param {import('./type.js').PinParams} data
     */
    init(data) {
      this.#item = data.item;
      this.#marker = data.marker;
      this.#screen = data.screen;
      this.#animatePin = data.animatePin;
      this.#anticipatePinOnLoad = data.anticipatePinOnLoad;
      this.#forceTranspond = data.forceTranspond;
      this.#invertSide = data.invertSide;
      this.#direction = data.direction;
      this.#getStart = data.getStart;
      this.#getEnd = data.getEnd;
      this.#start = this.#getStart();
      this.#end = this.#getEnd();
      this.#prevscrollY = window.scrollY;
      this.#scrollerHeight = data?.scrollerHeight;
      this.#refreshCollisionPoint();
      this.#collisionStyleProp = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? "top" : "left";
      this.#isInizialized = true;
      this.#firstTime = true;
      this.#createPin();
      this.#addStyleFromPinToWrapper();
      this.#setPinSize();
      this.#setUpMotion();
      this.#unsubscribeScrollStart = modules_exports.useScrollStart(() => {
        if (!this.#isInizialized) return;
        if (this.#screen !== globalThis && this.#isInner && this.#pin) {
          modules_exports.useFrame(() => {
            if (this.#pin)
              this.#pin.style.transition = `transform .85s cubic-bezier(0, 0.68, 0.45, 1.1)`;
          });
        }
      });
      this.#unsubscribeScroll = modules_exports.useScroll(({ scrollY: scrollY2 }) => {
        if (!this.#isInizialized) return;
        if (this.#screen !== globalThis && this.#screen !== document.documentElement) {
          if (this.#direction === MobScrollerConstant.DIRECTION_VERTICAL) {
            this.#refreshCollisionPoint();
          }
          const gap = scrollY2 - this.#prevscrollY;
          this.#prevscrollY = scrollY2;
          if (this.#isInner && this.#pin && this.#spring) {
            const { verticalGap } = this.#spring.get();
            const translateValue = verticalGap - gap;
            this.#spring.setData({
              collision: 0,
              verticalGap: translateValue
            });
            modules_exports.useFrame(() => {
              if (this.#pin)
                this.#pin.style.transform = `translate(0px,${translateValue}px)`;
            });
          }
        }
      });
    }
    #setUpMotion() {
      this.#spring = new MobSpring({
        data: { collision: 0, verticalGap: 0 },
        config: "wobbly"
      });
      this.#unsubscribeSpring = this.#spring.subscribe(
        ({ collision, verticalGap }) => {
          if (this.#direction === MobScrollerConstant.DIRECTION_VERTICAL && this.#pin) {
            this.#pin.style.transform = `translate(0px, ${collision}px)`;
          } else if (this.#pin) {
            this.#pin.style.transform = `translate(${collision}px, ${verticalGap}px)`;
          }
        }
      );
    }
    #resetSpring() {
      if (this.#pin && this.#spring)
        this.#spring.set({ collision: 0, verticalGap: 0 }).catch(() => {
        });
    }
    #createPin() {
      if (!this.#item) this.#item = document.createElement("div");
      const wrapper2 = document.createElement("div");
      wrapper2.classList.add("pin-wrapper");
      const pin = document.createElement("div");
      pin.classList.add("pin");
      wrapper2.append(pin);
      const parentNode = this.#item?.parentNode;
      if (parentNode) parentNode.insertBefore(wrapper2, this.#item);
      pin.append(this.#item);
      this.#wrapper = this.#item.closest(".pin-wrapper");
      this.#pin = this.#item.closest(".pin");
      const requiredStyleToadd = this.#addRquiredStyle();
      const pinStyleFromItem = this.#addPinStyleFromItem();
      const markerWrapperStyle = getMarkerWrapperStyle({
        marker: this.#marker,
        invertSide: this.#invertSide,
        direction: this.#direction
      });
      const display = { display: "table" };
      modules_exports.useFrame(() => {
        if (!this.#pin || !this.#wrapper) return;
        Object.assign(this.#wrapper.style, { ...markerWrapperStyle });
        Object.assign(this.#pin.style, {
          ...display,
          ...pinStyleFromItem,
          ...requiredStyleToadd
        });
      });
      this.#checkIfShouldTranspond();
    }
    #setPinSize() {
      if (!this.#pin || !this.#wrapper) return;
      const height = this.#wrapper.offsetHeight;
      const width = this.#wrapper.offsetWidth;
      this.#wrapper.style.height = `${height}px`;
      this.#wrapper.style.width = `${width}px`;
      this.#pin.style.height = `${height}px`;
      this.#pin.style.width = `${width}px`;
    }
    /**
     * Get style from item and apply to wrapper ( es: flex)
     */
    #addStyleFromPinToWrapper() {
      if (!this.#item) return;
      const compStyles = globalThis.getComputedStyle(this.#item);
      const style = this.#itemRequireStyleToWrapper.reduce((p, c) => {
        return { ...p, [c]: compStyles.getPropertyValue(c) };
      }, {});
      modules_exports.useFrame(() => {
        if (!this.#wrapper) return;
        Object.assign(this.#wrapper.style, style);
      });
    }
    /**
     * @param {HTMLElement} target
     * @param {string} rule
     * @returns {Record<string, any> | undefined}
     */
    #findStyle(target, rule) {
      let node = target.parentNode;
      if (!node) return;
      while (node !== null && node !== document) {
        const style = getComputedStyle(
          /** @type {Element} */
          node
        );
        if (style[rule] && !this.#nonRelevantRule.includes(style[rule])) {
          return { [rule]: style[rule] };
        }
        node = node.parentNode;
      }
      return;
    }
    /**
     * @returns {Record<string, string> | {}}
     */
    #addRquiredStyle() {
      if (!this.#pin) return {};
      const stylesObject = this.#parentRequireStyle.map((item) => {
        return this.#findStyle(this.#pin, item);
      }).filter((item) => item !== null).reduce((p, c) => {
        return { ...p, ...c };
      }, {});
      return stylesObject ?? {};
    }
    /**
     * @returns {void}
     */
    #checkIfShouldTranspond() {
      if (this.#forceTranspond) {
        this.#shoulTranspond = true;
        return;
      }
      this.#shoulTranspond = this.#styleToTranspond.map((item) => {
        const style = this.#findStyle(this.#wrapper, item);
        if (!style) return false;
        const [key] = Object.keys(style);
        const [value] = Object.values(style);
        if (key === "position") {
          return value === "fixed" || value === "absolute" ? true : false;
        } else {
          return true;
        }
      }).includes(true);
    }
    /**
     * @returns {void}
     */
    #updateStartEndValue() {
      this.#start = this.#getStart();
      this.#end = this.#getEnd();
    }
    /**
     * @returns {void}
     */
    #refreshCollisionPoint() {
      this.#updateStartEndValue();
      if (this.#screen !== globalThis) {
        this.#start -= this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? (
          // @ts-ignore
          position(this.#screen).top
        ) : (
          // @ts-ignore
          position(this.#screen).left
        );
      }
      this.#startFromTop = this.#invertSide ? this.#start : this.#scrollerHeight - this.#start;
      this.#compesateValue = this.#invertSide ? -Math.trunc(this.#end) : Math.trunc(this.#end);
    }
    /**
     * @returns {void}
     */
    destroy() {
      if (!this.#isInizialized) return;
      this.#spring?.stop?.();
      this.#unsubscribeSpring();
      this.#unsubscribeScroll();
      this.#unsubscribeScrollStart();
      this.#spring?.destroy?.();
      this.#spring = null;
      this.#afterPinCounter = 0;
      this.#justPinned = false;
      this.#isUnder = false;
      this.#isInner = false;
      this.#isOver = false;
      if (this.#pin && this.#wrapper) {
        this.#wrapper.parentNode?.insertBefore(this.#item, this.#wrapper);
        this.#pin.remove();
        this.#wrapper.remove();
        this.#wrapper = void 0;
        this.#pin = void 0;
        this.#isInizialized = false;
      }
    }
    /**
     * @returns {number}
     */
    #getGap() {
      if (!this.#wrapper) return 0;
      return this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? position(this.#wrapper).top - this.#startFromTop : position(this.#wrapper).left - this.#startFromTop;
    }
    /**
     * @returns {void}
     */
    #animateCollision() {
      const gap = this.#getGap();
      this.#tween(gap);
    }
    /**
     * @returns {void}
     */
    #animateCollisionBack() {
      const gap = this.#invertSide ? this.#getGap() - this.#end : this.#getGap() + this.#end;
      this.#tween(gap);
    }
    /**
     * @param {number} gap
     */
    #tween(gap) {
      modules_exports.useFrame(() => {
        if (!this.#pin || !this.#collisionStyleProp) return;
        const style = this.#pin?.style ?? {};
        style[this.#collisionStyleProp] = `${this.#startFromTop}px`;
      });
      if (this.#animatePin && !this.#firstTime && this.#pin && this.#spring) {
        this.#spring.goFrom({ collision: gap }).then(() => {
          this.#resetPinTransform();
        }).catch(() => {
        });
      }
    }
    /**
     * @returns {void}
     */
    #resetPinTransform() {
      modules_exports.useFrame(() => {
        if (!this.#pin) return;
        this.#pin.style.transform = `translate(0px, 0px)`;
      });
    }
    /**
     * @returns {void}
     */
    #resetStyleWhenUnder() {
      this.#resetSpring();
      modules_exports.useFrame(() => {
        if (!this.#pin) return;
        this.#pin.style.transition = "";
        this.#pin.style.position = "relative";
        this.#pin.style.top = ``;
        this.#pin.style.left = ``;
      });
    }
    /**
     * @returns {void}
     */
    #resetStyleWhenOver() {
      this.#resetSpring();
      modules_exports.useFrame(() => {
        if (!this.#pin) return;
        this.#pin.style.transition = "";
        this.#pin.style.position = "relative";
        if (this.#direction === MobScrollerConstant.DIRECTION_VERTICAL) {
          this.#pin.style.left = ``;
          this.#pin.style.top = `${this.#compesateValue}px`;
        } else {
          this.#pin.style.top = ``;
          this.#pin.style.left = `${this.#compesateValue}px`;
        }
      });
    }
    /**
     * @returns {void}
     */
    #setFixedPosition() {
      if (!this.#pin) return;
      const left = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? position(this.#pin).left : position(this.#pin).top;
      const style = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? "left" : "top";
      modules_exports.useFrame(() => {
        if (!this.#pin) return;
        this.#pin.style.position = "fixed";
        this.#pin.style[style] = `${left}px`;
        this.#justPinned = true;
        this.#afterJustPinned = true;
      });
    }
    /**
     * @returns {object}
     */
    #addPinStyleFromItem() {
      if (!this.#item) return {};
      const compStyles = globalThis.getComputedStyle(this.#item);
      return this.#itemRequireStyleToPin.reduce((p, c) => {
        return { ...p, [c]: compStyles.getPropertyValue(c) };
      }, {});
    }
    /**
     * @returns {object}
     */
    #addStyleToItem() {
      if (!this.#item) return {};
      const compStyles = globalThis.getComputedStyle(this.#item);
      return this.#itemRequireStyleWhenTraspond.reduce((p, c) => {
        return { ...p, [c]: compStyles.getPropertyValue(c) };
      }, {});
    }
    /**
     * @returns {object}
     */
    #removeStyleToItem() {
      return this.#itemRequireStyleWhenTraspond.reduce((p, c) => {
        return { ...p, [c]: "" };
      }, {});
    }
    /**
     * @returns {void}
     */
    #activateTrasponder() {
      if (this.#shoulTranspond) {
        const requiredStyleToAdd = this.#addRquiredStyle();
        const pinStyleFromItem = this.#addPinStyleFromItem();
        const styleToAdd = this.#addStyleToItem();
        modules_exports.useFrame(() => {
          if (!this.#pin) return;
          Object.assign(this.#pin.style, {
            ...pinStyleFromItem,
            ...requiredStyleToAdd
          });
          if (this.#item) Object.assign(this.#item.style, styleToAdd);
          document.body.append(this.#pin);
        });
      }
    }
    /**
     * @returns {void}
     */
    #deactivateTrasponder() {
      if (!this.#shoulTranspond || !this.#item || !this.#wrapper) return;
      modules_exports.useFrame(() => {
        if (!this.#pin) return;
        Object.assign(this.#item.style, this.#removeStyleToItem());
        this.#wrapper?.append(this.#pin);
      });
    }
    /**
     * @param {number} scrollTop
     * @returns {number}
     */
    #getAnticipate(scrollTop) {
      const step = this.#afterJustPinned && this.#afterJustPinnedCounter < 3 ? this.#lastStep : clamp3(Math.abs(scrollTop - this.#prevScroll), 0, 250);
      if (this.#afterJustPinned && this.#afterJustPinnedCounter < this.#numeCycleToFreeze) {
        this.#afterJustPinnedCounter++;
      } else {
        this.#afterJustPinnedCounter = 0;
        this.#afterJustPinned = false;
      }
      this.#lastStep = step;
      return step * this.#anticipateFactor;
    }
    /**
     * @param {number} scrollTop
     * @param {string} scrollDirection
     * @returns {{ anticipateBottom: number; anticipateInnerIn: number; anticipateInnerOut: number }}
     */
    #getAnticipateValue(scrollTop, scrollDirection) {
      if (this.#animatePin && !this.#firstTime || this.#firstTime && !this.#anticipatePinOnLoad) {
        return {
          anticipateBottom: 0,
          anticipateInnerIn: 0,
          anticipateInnerOut: 0
        };
      }
      const anticipate = this.#getAnticipate(scrollTop);
      const anticipateBottom = scrollDirection === MobScrollerConstant.SCROLL_UP ? 0 : anticipate;
      const anticipateInnerIn = scrollDirection === MobScrollerConstant.SCROLL_UP ? 0 : anticipate * 2;
      const anticipateInnerOut = scrollDirection === MobScrollerConstant.SCROLL_UP ? anticipate : 0;
      return {
        anticipateBottom,
        anticipateInnerIn,
        anticipateInnerOut
      };
    }
    /**
     * @param {number} scrollTop
     * @param {string} scrollDirection
     * @returns {{ anticipateBottom: number; anticipateInnerIn: number; anticipateInnerOut: number }}
     */
    #getAnticipateValueInverted(scrollTop, scrollDirection) {
      if (this.#animatePin && !this.#firstTime || this.#firstTime && !this.#anticipatePinOnLoad) {
        return {
          anticipateBottom: 0,
          anticipateInnerIn: 0,
          anticipateInnerOut: 0
        };
      }
      const anticipate = this.#getAnticipate(scrollTop);
      const anticipateBottom = scrollDirection === MobScrollerConstant.SCROLL_UP ? anticipate : 0;
      const anticipateInnerIn = scrollDirection === MobScrollerConstant.SCROLL_UP ? anticipate * 2 : 0;
      const anticipateInnerOut = scrollDirection === MobScrollerConstant.SCROLL_UP ? 0 : anticipate;
      return {
        anticipateBottom,
        anticipateInnerIn,
        anticipateInnerOut
      };
    }
    /**
     * @param {number} scrollTop
     */
    onScroll(scrollTop) {
      if (!this.#isInizialized || !this.#wrapper) return;
      if (this.#justPinned && this.#afterPinCounter < this.#numeCycleToFreeze) {
        this.#afterPinCounter++;
        return;
      } else {
        this.#afterPinCounter = 0;
        this.#justPinned = false;
      }
      const scrollDirection = this.#prevScroll > scrollTop ? MobScrollerConstant.SCROLL_UP : MobScrollerConstant.SCROLL_DOWN;
      const offsetTop = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? position(this.#wrapper).top : position(this.#wrapper).left;
      const { anticipateBottom, anticipateInnerIn, anticipateInnerOut } = this.#invertSide ? this.#getAnticipateValueInverted(scrollTop, scrollDirection) : this.#getAnticipateValue(scrollTop, scrollDirection);
      const bottomCondition = this.#invertSide ? offsetTop < this.#start - anticipateBottom : offsetTop > this.#scrollerHeight - this.#start + anticipateBottom;
      const innerCondition = this.#invertSide ? offsetTop >= this.#start - anticipateInnerIn && offsetTop <= this.#start + anticipateInnerOut + this.#end : offsetTop <= this.#scrollerHeight - this.#start + anticipateInnerIn && this.#scrollerHeight - offsetTop <= this.#end + anticipateInnerOut + this.#start;
      if (bottomCondition) {
        if (!this.#isUnder) {
          this.#resetStyleWhenUnder();
          this.#deactivateTrasponder();
          this.#isUnder = true;
          this.#isInner = false;
          this.#isOver = false;
        }
      } else if (innerCondition) {
        if (!this.#isInner) {
          this.#setFixedPosition();
          const fireSpring = scrollDirection === MobScrollerConstant.SCROLL_DOWN && !this.#invertSide || scrollDirection === MobScrollerConstant.SCROLL_UP && this.#invertSide;
          this.#activateTrasponder();
          if (fireSpring) {
            this.#animateCollision();
          } else {
            this.#animateCollisionBack();
          }
          this.#isUnder = false;
          this.#isInner = true;
          this.#isOver = false;
        }
      } else {
        if (!this.#isOver) {
          this.#resetStyleWhenOver();
          this.#deactivateTrasponder();
          this.#isUnder = false;
          this.#isInner = false;
          this.#isOver = true;
        }
      }
      this.#prevScroll = scrollTop;
      this.#firstTime = false;
    }
  };

  // src/js/mob/mob-motion/animation/scroller/warning.js
  var scrollerWarningNoUnitMiusure = () => {
    console.warn(
      "parallax prop checker: value in start or end prop with no unit misure is not allowed, failed operation, use vh in vertical mode or vw in horizontal or px"
    );
  };
  var scrollerWarningVhIsNotAllowed = () => {
    console.warn(
      "parallax prop checker: value in start or end in vh is not allowed in horizontal mode, use vw or px"
    );
  };
  var scrollerWarningVwIsNotAllowed = () => {
    console.warn(
      "parallax prop checker: value in start or end in vw is not allowed in vertical mode, use vh or px"
    );
  };

  // src/js/mob/mob-motion/animation/scroller/mob-scroller-utils.js
  var returnWhenFail = () => {
    return {
      numberVal: 0,
      unitMisure: "",
      additionalVal: "",
      position: ""
    };
  };
  var getValueInPx = ({
    invert,
    endValInNumber,
    scrollerHeight,
    isNegative,
    startPoint,
    isFromTopLeft
  }) => {
    const valueFromTop = endValInNumber * isNegative - startPoint;
    const valueFromBottom = scrollerHeight - endValInNumber * isNegative - startPoint;
    if (invert) {
      return isFromTopLeft ? valueFromTop : valueFromBottom;
    } else {
      return isFromTopLeft ? valueFromBottom : valueFromTop;
    }
  };
  var getValueInVwVh = ({
    invert,
    scrollerHeight,
    screenUnit,
    endValInNumber,
    isNegative,
    startPoint,
    isFromTopLeft
  }) => {
    if (invert) {
      return isFromTopLeft ? scrollerHeight - screenUnit * (100 - endValInNumber * isNegative) - startPoint : screenUnit * (100 - endValInNumber * isNegative) - startPoint;
    } else {
      return isFromTopLeft ? scrollerHeight - screenUnit * endValInNumber * isNegative - startPoint : screenUnit * endValInNumber * isNegative - startPoint;
    }
  };
  var detectViewPortInterception = ({
    offset: offset2,
    height,
    gap,
    wScrollTop,
    wHeight
  }) => {
    return offset2 + height > wScrollTop - gap && offset2 < wScrollTop + (wHeight + gap);
  };
  var getStartEndValue = (values, direction2) => {
    const numberInString = values.find((item) => {
      return [...item].some((c) => !Number.isNaN(Number.parseFloat(c)));
    });
    const unitMisure = getStartEndUnitMisure(numberInString);
    if (numberInString && !unitMisure) {
      scrollerWarningNoUnitMiusure();
      return returnWhenFail();
    }
    if (numberInString && unitMisure === MobScrollerConstant.VH && direction2 === MobScrollerConstant.DIRECTION_HORIZONTAL) {
      scrollerWarningVhIsNotAllowed();
      return returnWhenFail();
    }
    if (numberInString && unitMisure === MobScrollerConstant.VW && direction2 === MobScrollerConstant.DIRECTION_VERTICAL) {
      scrollerWarningVwIsNotAllowed();
      return returnWhenFail();
    }
    const additionaChoice = [
      MobScrollerConstant.PLUS_HEIGHT,
      MobScrollerConstant.PLUS_HEIGHT_HALF,
      MobScrollerConstant.PLUS_WIDTH,
      MobScrollerConstant.PLUS_WIDTH_HALF,
      MobScrollerConstant.MINUS_HEIGHT,
      MobScrollerConstant.MINUS_HEIGHT_HALF,
      MobScrollerConstant.MINUS_WIDTH,
      MobScrollerConstant.MINUS_WIDTH_HALF
    ];
    const getAdditionalVal = values.find((item) => {
      return exactMatchInsesitivePropArray(additionaChoice, item);
    });
    const positionMap = [
      MobScrollerConstant.POSITION_BOTTOM,
      MobScrollerConstant.POSITION_TOP,
      MobScrollerConstant.POSITION_LEFT,
      MobScrollerConstant.POSITION_RIGHT
    ];
    const getPosition2 = values.find((item) => {
      return exactMatchInsesitivePropArray(positionMap, item);
    });
    return {
      numberVal: numberInString || 0,
      unitMisure,
      additionalVal: getAdditionalVal ?? "",
      position: getPosition2 ?? MobScrollerConstant.POSITION_BOTTOM
    };
  };
  var getStartPoint = (screenUnit, data, direction2) => {
    const str = String(data);
    const values = str.split(" ");
    const { numberVal, unitMisure, additionalVal, position: position2 } = getStartEndValue(
      values,
      direction2
    );
    const firstChar = String(numberVal).charAt(0);
    const isNegative = firstChar === "-" ? -1 : 1;
    const number = Number.parseFloat(
      // @ts-ignore
      String(numberVal).replaceAll(/^\D+/g, "")
    );
    const startValInNumber = number ?? 0;
    return unitMisure === MobScrollerConstant.PX ? {
      value: startValInNumber * isNegative,
      additionalVal,
      position: getScrollerPositionFromContanst(position2)
    } : {
      value: screenUnit * startValInNumber * isNegative,
      additionalVal,
      position: getScrollerPositionFromContanst(position2)
    };
  };
  var getEndPoint = (screenUnit, data, startPoint, scrollerHeight, invertSide, direction2) => {
    const str = String(data);
    const values = str.split(" ");
    const { numberVal, unitMisure, additionalVal, position: position2 } = getStartEndValue(
      values,
      direction2
    );
    const firstChar = String(numberVal).charAt(0);
    const isNegative = firstChar === "-" ? -1 : 1;
    const number = Number.parseFloat(
      // @ts-ignore
      String(numberVal).replaceAll(/^\D+/g, "")
    );
    const endValInNumber = number ?? 0;
    const positionFromConstant = getScrollerPositionFromContanst(position2);
    const isFromTopLeft = positionFromConstant === MobScrollerConstant.POSITION_TOP || positionFromConstant === MobScrollerConstant.POSITION_LEFT;
    return unitMisure === MobScrollerConstant.PX ? {
      value: invertSide ? getValueInPx({
        invert: true,
        endValInNumber,
        scrollerHeight,
        isNegative,
        startPoint,
        isFromTopLeft
      }) : getValueInPx({
        invert: false,
        endValInNumber,
        scrollerHeight,
        isNegative,
        startPoint,
        isFromTopLeft
      }),
      additionalVal,
      position: positionFromConstant
    } : {
      value: invertSide ? getValueInVwVh({
        invert: true,
        scrollerHeight,
        screenUnit,
        endValInNumber,
        isNegative,
        startPoint,
        isFromTopLeft
      }) : getValueInVwVh({
        invert: false,
        scrollerHeight,
        screenUnit,
        endValInNumber,
        isNegative,
        startPoint,
        isFromTopLeft
      }),
      additionalVal,
      position: positionFromConstant
    };
  };
  var processFixedLimit = (value, stringValue, height, width) => {
    const str = String(stringValue);
    if (exactMatchInsensitive(str, MobScrollerConstant.PLUS_HEIGHT_HALF)) {
      return value + height / 2;
    }
    if (exactMatchInsensitive(str, MobScrollerConstant.PLUS_HEIGHT)) {
      return value + height;
    }
    if (exactMatchInsensitive(str, MobScrollerConstant.PLUS_WIDTH_HALF)) {
      return value + width / 2;
    }
    if (exactMatchInsensitive(str, MobScrollerConstant.PLUS_WIDTH)) {
      return value + width;
    }
    if (exactMatchInsensitive(str, MobScrollerConstant.MINUS_HEIGHT_HALF)) {
      return value - height / 2;
    }
    if (exactMatchInsensitive(str, MobScrollerConstant.MINUS_HEIGHT)) {
      return value - height;
    }
    if (exactMatchInsensitive(str, MobScrollerConstant.MINUS_WIDTH_HALF)) {
      return value - width / 2;
    }
    if (exactMatchInsensitive(str, MobScrollerConstant.MINUS_WIDTH)) {
      return value - width;
    }
    return value;
  };
  var getValueOnSwitch = ({ switchPropierties, isReverse, value }) => {
    switch (switchPropierties) {
      case MobScrollerConstant.IN_STOP: {
        return !isReverse && value > 0 || isReverse && value < 0 ? 0 : value;
      }
      case MobScrollerConstant.IN_BACK: {
        return !isReverse && value > 0 || isReverse && value < 0 ? -value : value;
      }
      case MobScrollerConstant.OUT_STOP: {
        return !isReverse && value < 0 || isReverse && value > 0 ? 0 : value;
      }
      case MobScrollerConstant.OUT_BACK: {
        return !isReverse && value < 0 || isReverse && value > 0 ? -value : value;
      }
      default: {
        return value;
      }
    }
  };
  var getRetReverseValue = (propierties, val2) => {
    switch (propierties) {
      case MobScrollerConstant.PROP_OPACITY: {
        return 1 - val2;
      }
      default: {
        return -val2;
      }
    }
  };
  var getScrollFunction = ({ callback: callback2, pin, ease, useThrottle }) => {
    if (pin) return modules_exports.useScrollImmediate(callback2);
    if (ease && useThrottle) return modules_exports.useScrollThrottle(callback2);
    return modules_exports.useScroll(callback2);
  };

  // src/js/mob/mob-motion/animation/scroller/mob-scroller.js
  var MobScroller = class {
    /**
     * @type {boolean}
     */
    #isInzialized;
    /**
     * @type {boolean}
     */
    #willChangeIsActive;
    /**
     * @type {number}
     */
    #offset;
    /**
     * @type {number}
     */
    #screenPosition;
    /**
     * @type {number}
     */
    #endValue;
    /**
     * @type {number}
     */
    #height;
    /**
     * @type {number}
     */
    #width;
    /**
     * @type {number}
     */
    #scrollerScroll;
    /**
     * @type {number}
     */
    #scrollerHeight;
    /**
     * @type {number}
     */
    #windowInnerWidth;
    /**
     * @type {number}
     */
    #windowInnerHeight;
    /**
     * @type {number}
     */
    #gap;
    /**
     * @type {number}
     */
    #numericRange;
    /**
     * @type {Function}
     */
    #unsubscribeResize;
    /**
     * @type {Function}
     */
    #unsubscribeScroll;
    /**
     * @type {Function}
     */
    #unsubscribeScrollStart;
    /**
     * @type {Function}
     */
    #unsubscribeScrollEnd;
    /**
     * @type {Function}
     */
    #unsubscribeMarker;
    /**
     * @type {Element | undefined}
     */
    #startMarker;
    /**
     * @type {Element | undefined}
     */
    #endMarker;
    /**
     * @type {number | undefined}
     */
    #lastValue;
    /**
     * @type {number}
     */
    #prevFixedRawValue;
    /**
     * @type {boolean}
     */
    #fixedShouldRender;
    /**
     * @type {number | undefined}
     */
    #prevFixedClamp;
    /**
     * @type {boolean}
     */
    #firstTime;
    /**
     * @type {boolean}
     */
    #isInViewport;
    /**
     * @type {boolean}
     */
    #iSControlledFromOutside;
    /**
     * @type {boolean}
     */
    #force3D;
    /**
     * @type {MobScrollerPin | undefined}
     */
    #pinInstance;
    /**
     * @type {string}
     */
    #unitMisure;
    /**
     * @type {number}
     */
    #startPoint;
    /**
     * @type {number}
     */
    #endPoint;
    /**
     * @type {Function}
     */
    #unsubscribeMotion;
    /**
     * @type {Function}
     */
    #unsubscribeOnComplete;
    /**
     * Fixed prop
     */
    /**
     * @type {boolean}
     */
    #pin;
    /**
     * @type {boolean}
     */
    #animatePin;
    /**
     * @type {boolean}
     */
    #forceTranspond;
    /**
     * @type {boolean}
     */
    #anticipatePinOnLoad;
    /**
     * @type {string}
     */
    #start;
    /**
     * @type {string}
     */
    #end;
    /**
     * @type {boolean}
     */
    #invertSide;
    /**
     * @type {string}
     */
    #marker;
    /**
     * @type {import('./type.js').DynamicStart}
     */
    #dynamicStart;
    /**
     * @type {import('./type.js').DynamicEnd}
     */
    #dynamicEnd;
    /**
     * @type {Function | undefined}
     */
    #dynamicRange;
    /**
     * @type {boolean}
     */
    #animateAtStart;
    /**
     * @type {Function}
     */
    #onEnter;
    /**
     * @type {Function}
     */
    #onEnterBack;
    /**
     * @type {Function}
     */
    #onLeave;
    /**
     * @type {Function}
     */
    #onLeaveBack;
    /**
     * @type {Function}
     */
    #onTickCallback;
    /**
     * @type {string | number}
     */
    #align;
    /**
     * @type {string | boolean}
     */
    #onSwitch;
    /**
     * @type {boolean}
     */
    #reverse;
    /**
     * @type {number}
     */
    #opacityStart;
    /**
     * @type {number}
     */
    #opacityEnd;
    /**
     * @type {boolean}
     */
    #limiterOff;
    /**
     * Common prop
     */
    /**
     * @type {boolean | undefined}
     */
    #useWillChange;
    /**
     * @type {import('../../type.js').MobMasterSequencer | MobScrollerTween | MobSequencer}
     */
    #tween;
    /**
     * @type {HTMLElement | null}
     */
    #item;
    /**
     * @type {HTMLElement | globalThis | null}
     */
    #scroller;
    /**
     * @type {HTMLElement | globalThis | null}
     */
    #screen;
    /**
     * @type {HTMLElement | null | undefined}
     */
    #trigger;
    /**
     * @type {HTMLElement | null | undefined}
     */
    #applyTo;
    /**
     * @type {string}
     */
    #direction;
    /**
     * @type {boolean}
     */
    #disableForce3D;
    // With pin active no throttle is usable, pin need precision
    /**
     * @type {boolean}
     */
    #useThrottle;
    /**
     * @type {string}
     */
    #type;
    /**
     * @type {number}
     */
    #perspective;
    /**
     * @type {string}
     */
    #breakpoint;
    /**
     * @type {string}
     */
    #queryType;
    /**
     * @type {string}
     */
    #propierties;
    /**
     * Skip render and set a default 100px value for trigger the events.
     *
     * @type {boolean}
     */
    #shouldTrackOnlyEvents;
    /**
     * @type {string | number}
     */
    #range;
    /**
     * Get properties, check if there is sequencer inside a Parallax, In case return y propierties
     *
     * @type {boolean}
     */
    #ease;
    /**
     * Get easeType properties, Check if a sequencer is used inside a scrollTrigger In case return a lerp
     *
     * @type {string}
     */
    #easeType;
    /**
     * Get easeType properties, Check if a sequencer is used inside a scrollTrigger In case return a lerp
     *
     * @type {import('../spring/type.js').SpringChoiceConfig}
     */
    #springConfig;
    /**
     * Get easeType properties, Check if a sequencer is used inside a scrollTrigger In case return a lerp
     *
     * @type {number}
     */
    #lerpConfig;
    /**
     * Add more precision to motion spring/lerp to trigger better force3D
     *
     * @type {any}
     */
    #motionParameters;
    /**
     * Add more precision to motion spring/lerp to trigger better force3D
     *
     * @type {import('./type.js').MobScrollerMotion}
     */
    #motion;
    /**
     * Available methods:
     *
     * ```javascript
     * myInstance.init();
     * myInstance.destroy();
     * myInstance.refresh();
     * myInstance.move();
     * ```
     *
     * @example
     *     ```javascript
     *      Parallax property schema:
     *
     *
     *      const myParallax = new MobScroller({
     *          type: 'parallax',
     *          item: String | Element,
     *          applyTo: [ String | Element ],
     *          trigger: [ String | Element ],
     *          screen: [ String | Element ],
     *          scroller: [ String | Element ],
     *          breakpoint: [ String ],
     *          queryType: [ String ],
     *          direction: [ String ],
     *          propierties: [ String ],
     *          tween: [ MobSequencer | MobScrollerTween ],
     *          range: [ String | Number ],
     *          align: [ String ],
     *          onSwitch: [ String ],
     *          reverse: [ Boolean ],
     *          ease: [ Boolean ],
     *          easeType: [ String ],
     *          lerpConfig: [ Number ],
     *          springConfig: [ String ],
     *          opacityEnd: [ Number ],
     *          opacityStart: [ Number ],
     *          limiterOff: [ Boolean ],
     *          perspective: [ Number ],
     *          disableForce3D: [ Boolean ],
     *          useThrottle: [ Boolean ],
     *      });
     *
     *
     *
     *      Scrolltrigger property schema:
     *
     *
     *      const myScrollTrigger = new MobScroller({
     *          item: String | Element,
     *          applyTo: [ String | Element ],
     *          trigger: [ String | Element ],
     *          screen: [ String | Element ],
     *          scroller: [ String | Element ],
     *          breakpoint: [ String ],
     *          queryType: [ String ],
     *          direction: [ String ],
     *          propierties: [ String ],
     *          tween: [ MobSequencer | MobScrollerTween ],
     *          range: [ String ],
     *          dynamicRange: [ Function ],
     *          fromTo: [ Boolean ],
     *          start: [ String ],
     *          dynamicStart: {
     *             position: [ String ],
     *             value: [ Function ]
     *          },
     *          end: [ String ],
     *          dynamicEnd: {
     *             position: [ String ],
     *             value: [ Function ]
     *          },
     *          ease: [ Boolean ],
     *          easeType: [ String ],
     *          lerpConfig: [ Number ],
     *          springConfig: [ String ],
     *          pin: [ Boolean ],
     *          animatePin: [ Boolean ],
     *          anticipatePinOnLoad: [ Boolean ],
     *          marker: [ String ],
     *          forceTranspond: [ Boolean ],
     *          animateAtStart: [ Boolean ],
     *          disableForce3D: [ Boolean ],
     *          onEnter: [ Function ],
     *          onEnterBack: [ Function ],
     *          onLeave: [ Function ],
     *          onLeaveBack: [ Function ],
     *          onTick: [ Function ],
     *          perspective: [ Number ],
     *          useThrottle: [ Boolean ],
     *      });
     *
     *
     *     ```;
     *
     * @param {import('./type.js').MobScrollerCommon &
     *     import('./type.js').Parallax &
     *     import('./type.js').ScrollTrigger} data
     */
    constructor(data) {
      this.#isInzialized = false;
      this.#willChangeIsActive = false;
      this.#offset = 0;
      this.#screenPosition = 0;
      this.#endValue = 0;
      this.#height = 0;
      this.#width = 0;
      this.#scrollerScroll = 0;
      this.#scrollerHeight = 0;
      this.#windowInnerWidth = window.innerWidth;
      this.#windowInnerHeight = window.innerHeight;
      this.#gap = 150;
      this.#numericRange = 0;
      this.#unsubscribeResize = () => {
      };
      this.#unsubscribeScroll = () => {
      };
      this.#unsubscribeScrollStart = () => {
      };
      this.#unsubscribeScrollEnd = () => {
      };
      this.#unsubscribeMarker = () => {
      };
      this.#startMarker = void 0;
      this.#endMarker = void 0;
      this.#lastValue = void 0;
      this.#prevFixedRawValue = 0;
      this.#fixedShouldRender = false;
      this.#prevFixedClamp = void 0;
      this.#firstTime = true;
      this.#isInViewport = false;
      this.#iSControlledFromOutside = false;
      this.#force3D = false;
      this.#pinInstance = void 0;
      this.#unitMisure = "";
      this.#startPoint = 0;
      this.#endPoint = 0;
      this.#unsubscribeMotion = () => {
      };
      this.#unsubscribeOnComplete = () => {
      };
      this.#invertSide = false;
      this.#pin = valueIsBooleanAndReturnDefault(
        data?.pin,
        "Scrolltrigger pin propierties error:",
        false
      );
      this.#animatePin = valueIsBooleanAndReturnDefault(
        data?.animatePin,
        "Scrolltrigger animatePin propierties error:",
        false
      );
      this.#forceTranspond = valueIsBooleanAndReturnDefault(
        data?.forceTranspond,
        "Scrolltrigger forceTranspond propierties error:",
        false
      );
      this.#anticipatePinOnLoad = valueIsBooleanAndReturnDefault(
        data?.anticipatePinOnLoad,
        "Scrolltrigger anticipatePinOnLoad propierties error:",
        false
      );
      this.#start = valueIsStringAndReturnDefault(
        data?.start,
        "Scrolltrigger start propierties error:",
        "bottom 0px"
      );
      this.#end = valueIsStringAndReturnDefault(
        data?.end,
        "Scrolltrigger end propierties error:",
        "top"
      );
      this.#marker = valueIsStringAndReturnDefault(
        data?.marker,
        "Scrolltrigger marker propierties error:",
        // eslint-disable-next-line unicorn/no-useless-undefined
        void 0
      );
      this.#dynamicStart = data?.dynamicStart ? scrollerDynamicValueIsValid(data.dynamicStart, "dynamicStart") : null;
      this.#dynamicEnd = data?.dynamicEnd ? scrollerDynamicValueIsValid(data.dynamicEnd, "dynamicEnd") : null;
      this.#dynamicRange = scrollerDynamicRangeIsValid(data?.dynamicRange);
      this.#animateAtStart = valueIsBooleanAndReturnDefault(
        data?.animateAtStart,
        "Scrolltrigger animateAtStart propierties error:",
        false
      );
      this.#onEnter = functionIsValidAndReturnDefault(
        data?.onEnter,
        false,
        "Scrolltrigger onEnter propierties error"
      );
      this.#onEnterBack = functionIsValidAndReturnDefault(
        data?.onEnterBack,
        false,
        "Scrolltrigger onEnterBack propierties error"
      );
      this.#onLeave = functionIsValidAndReturnDefault(
        data?.onLeave,
        false,
        "Scrolltrigger onLeave propierties error"
      );
      this.#onLeaveBack = functionIsValidAndReturnDefault(
        data?.onLeaveBack,
        false,
        "Scrolltrigger onLeaveBack propierties error"
      );
      this.#onTickCallback = functionIsValidAndReturnDefault(
        data?.onTick,
        false,
        "Scrolltrigger onTickCallback propierties error"
      );
      this.#align = scrollerAlignIsValid(data?.align);
      this.#onSwitch = scrollerOnSwitchIsValid(data?.onSwitch);
      this.#reverse = valueIsBooleanAndReturnDefault(
        data?.reverse,
        "Parallax reverse propierties error:",
        false
      );
      this.#opacityStart = scrollerOpacityIsValid(
        data?.opacityStart,
        "Parallax opacityStart propierties error:",
        100
      );
      this.#opacityEnd = scrollerOpacityIsValid(
        data?.opacityEnd,
        "Parallax opacityEnd propierties error:",
        0
      );
      this.#limiterOff = valueIsBooleanAndReturnDefault(
        data?.limiterOff,
        "Parallax|Scrolltrigger limiterOff propierties error:",
        false
      );
      this.#useWillChange = data?.useWillChange;
      this.#tween = scrollerTweenIsValid(data?.tween);
      const tweenIsSequencer = this.#tween?.getType && this.#tween.getType() === MobScrollerConstant.TWEEN_TIMELINE;
      const tweenIsParallaxTween = this.#tween?.getType && this.#tween.getType() === MobScrollerConstant.TWEEN_TWEEN;
      this.#item = domNodeIsValidAndReturnElOrWin(data?.item, false);
      this.#scroller = domNodeIsValidAndReturnElOrWin(data?.scroller, true);
      this.#screen = domNodeIsValidAndReturnElOrWin(data?.screen, true);
      this.#trigger = domNodeIsValidAndReturnNull(data?.trigger);
      this.#applyTo = domNodeIsValidAndReturnNull(data?.applyTo);
      this.#direction = directionIsValid(
        data?.direction,
        "Parallax/Scrolltrigger"
      );
      this.#disableForce3D = valueIsBooleanAndReturnDefault(
        data?.disableForce3D,
        "Parallax|Scrolltrigger disableForce3D propierties error:",
        false
      );
      this.#useThrottle = valueIsBooleanAndReturnDefault(
        data?.useThrottle,
        "Parallax|Scrolltrigger useThrottle propierties error:",
        false
      );
      this.#type = scrollerTypeIsValid(data?.type);
      this.#perspective = valueIsNumberAndReturnDefault(
        data?.perspective,
        "Parallax|Scrolltrigger perspective propierties error:",
        0
      );
      this.#breakpoint = breakpointIsValid(
        data?.breakpoint,
        "breakpoint",
        "parallax/scrolltrigger"
      );
      this.#queryType = breakpointTypeIsValid(
        data?.queryType,
        "queryType",
        "parallax/scrolltrigger"
      );
      const { propierties, shouldTrackOnlyEvents } = scrollerPropiertiesIsValid(
        data?.propierties,
        this.#type,
        tweenIsParallaxTween,
        tweenIsSequencer
      );
      this.#propierties = propierties;
      this.#shouldTrackOnlyEvents = shouldTrackOnlyEvents;
      this.#range = shouldTrackOnlyEvents ? "100px" : scrollerRangeIsValid(data?.range, this.#type);
      this.#ease = valueIsBooleanAndReturnDefault(
        data?.ease,
        "Parallax|Scrolltrigger ease propierties error:",
        false
      );
      if (tweenIsSequencer && data?.easeType === MobScrollerConstant.EASE_SPRING)
        scrollerEaseTypeSpringWarining();
      this.#easeType = tweenIsSequencer ? MobScrollerConstant.EASE_LERP : scrollerEaseTypeIsValid(data?.easeType);
      this.#springConfig = scrollerSpringConfigIsValid(
        data?.springConfig,
        this.#type
      );
      this.#lerpConfig = scrollerLerpConfigIsValid(
        data?.lerpConfig,
        this.#type
      );
      this.#motionParameters = this.#easeType === MobScrollerConstant.EASE_SPRING ? {
        configProps: {
          precision: MobScrollerConstant.EASE_PRECISION
        }
      } : { precision: MobScrollerConstant.EASE_PRECISION };
      this.#motion = this.#easeType === MobScrollerConstant.EASE_SPRING ? new MobSpring() : new MobLerp();
    }
    /**
     * Initialize instance
     */
    init() {
      if (this.#isInzialized) {
        console.warn(
          "Parallax/scrollTrigger: The init() method cannot be launched more than once. If you are passing the instance to components like horizontalScroller or smoothScroller via the children property, they will initialize the instance."
        );
        return;
      }
      this.#isInzialized = true;
      this.#setMotion();
      this.#calcScreenPosition();
      this.#calcOffset();
      this.#calcHeight();
      this.#calcWidth();
      this.#getScreenHeight();
      this.setPerspective();
      if (this.#propierties === MobScrollerConstant.PROP_TWEEN) {
        this.#range = this.#tween?.getDuration ? this.#tween.getDuration() : 0;
        this.#dynamicRange = () => this.#range;
        this.#tween?.inzializeStagger?.();
      }
      if (this.#type == MobScrollerConstant.TYPE_SCROLLTRIGGER) {
        this.#limiterOff = true;
        this.#calcRangeAndUnitMiusure();
        this.#calcFixedLimit();
      }
      if (this.#ease) {
        this.#unsubscribeScrollStart = modules_exports.useScrollStart(() => {
          if (!this.#disableForce3D) this.#force3D = true;
        });
        this.#unsubscribeScrollEnd = modules_exports.useScrollEnd(() => {
          modules_exports.useFrame(() => {
            modules_exports.useNextTick(() => {
              this.#easeRender();
            });
          });
        });
        if (this.#scroller === globalThis) {
          this.#unsubscribeScroll = getScrollFunction({
            pin: this.#pin,
            ease: this.#ease,
            useThrottle: this.#useThrottle,
            callback: () => {
              this.#easeRender();
            }
          });
        }
        this.#easeRender();
      } else {
        if (this.#scroller === globalThis) {
          this.#unsubscribeScroll = getScrollFunction({
            pin: this.#pin,
            ease: this.#ease,
            useThrottle: this.#useThrottle,
            callback: () => {
              this.#updateEndValue();
              this.#noEasingRender();
            }
          });
        }
        this.#updateEndValue();
        this.#noEasingRender();
        this.#unsubscribeScrollEnd = modules_exports.useScrollEnd(() => {
          this.#noEasingRender({ forceRender: true });
        });
      }
      if (this.#scroller !== globalThis && this.#marker) {
        this.#unsubscribeMarker = modules_exports.useScroll(() => {
          this.#calcFixedLimit();
        });
      }
      this.#unsubscribeResize = modules_exports.useResize(({ horizontalResize }) => {
        if (horizontalResize) this.refresh();
      });
      if (this.#pin) {
        this.#pinInstance = new MobScrollerPin();
        if (mq[this.#queryType](this.#breakpoint)) {
          modules_exports.useNextTick(() => {
            this.#getScrollerOffset();
            this.#pinInstance?.init(this.#getPinParams());
            this.#pinInstance?.onScroll(this.#scrollerScroll);
          });
        }
      }
    }
    #getPinParams() {
      return {
        item: this.#item,
        marker: this.#marker,
        screen: this.#screen,
        animatePin: this.#animatePin,
        anticipatePinOnLoad: this.#anticipatePinOnLoad,
        forceTranspond: this.#forceTranspond,
        invertSide: this.#invertSide,
        direction: this.#direction,
        scrollerHeight: this.#scrollerHeight,
        getStart: () => this.#startPoint,
        getEnd: () => this.#endPoint
      };
    }
    /**
     * @param {HTMLElement | globalThis} scroller
     */
    setScroller(scroller) {
      this.#scroller = domNodeIsValidAndReturnElOrWin(scroller, true);
    }
    /**
     * @param {HTMLElement | globalThis} screen
     */
    setScreen(screen) {
      this.#screen = domNodeIsValidAndReturnElOrWin(screen, true);
    }
    /**
     * @param {string} direction
     */
    setDirection(direction2) {
      this.#direction = directionIsValid(direction2, "Parallax/Scrolltrigger");
    }
    /**
     * @param {import('../../utils/type.js').MqValues} breakpoint
     */
    setBreakPoint(breakpoint) {
      this.#breakpoint = breakpointIsValid(
        breakpoint,
        "breakpoint",
        "Parallax/Scrolltrigger"
      );
    }
    /**
     * @param {import('../../utils/type.js').MqAction} queryType
     */
    setQueryType(queryType) {
      this.#queryType = breakpointTypeIsValid(
        queryType,
        "queryType",
        "Parallax/Scrolltrigger"
      );
    }
    /**
     * @private
     */
    setPerspective() {
      if (this.#perspective && this.#item && this.#item.parentNode) {
        const style = {
          perspective: `${this.#perspective}px`,
          "transform-style": "preserve-3d"
        };
        const parent = this.#item.parentNode;
        Object.assign(parent.style, style);
      }
    }
    #setMotion() {
      const initialValue = MobScrollerConstant.PROP_SCALE || MobScrollerConstant.PROP_SCALE_X || MobScrollerConstant.PROP_SCALE_Y || MobScrollerConstant.PROP_OPACITY ? 1 : 0;
      this.#motion.setData({ val: initialValue });
      this.#unsubscribeMotion = this.#motion.subscribe(({ val: val2 }) => {
        if (val2 === this.#lastValue) return;
        if (this.#propierties === MobScrollerConstant.PROP_TWEEN && this.#tween?.draw) {
          this.#tween.draw({
            partial: val2,
            isLastDraw: false,
            useFrame: false
          });
          this.#lastValue = val2;
          this.#firstTime = false;
        } else {
          this.#updateStyle(val2);
        }
        modules_exports.useNextTick(() => {
          if (this.#onTickCallback)
            this.#onTickCallback({ value: val2, parentIsMoving: true });
        });
      });
      this.#unsubscribeOnComplete = this.#motion.onComplete(({ val: val2 }) => {
        this.#force3D = false;
        if (this.#propierties === MobScrollerConstant.PROP_TWEEN && this.#tween?.draw) {
          this.#tween.draw({
            partial: val2,
            isLastDraw: true,
            useFrame: false
          });
        } else {
          this.#updateStyle(val2);
        }
        modules_exports.useNextTick(() => {
          if (this.#onTickCallback)
            this.#onTickCallback({ value: val2, parentIsMoving: false });
        });
      });
      switch (this.#easeType) {
        case MobScrollerConstant.EASE_LERP: {
          if (this.#lerpConfig && "updateVelocity" in this.#motion) {
            this.#motion?.updateVelocity?.(this.#lerpConfig);
          }
          break;
        }
        case MobScrollerConstant.EASE_SPRING: {
          if (this.#springConfig && "updateConfig" in this.#motion) {
            this.#motion?.updateConfig?.(this.#springConfig);
          }
          break;
        }
      }
    }
    #calcRangeAndUnitMiusure() {
      if (this.#dynamicRange) {
        const range = this.#dynamicRange();
        this.#numericRange = Number.isNaN(range) ? 0 : Number.parseFloat(range);
        this.#unitMisure = MobScrollerConstant.PX;
      } else {
        const str = String(this.#range);
        const firstChar = str.charAt(0);
        const isNegative = firstChar === "-" ? -1 : 1;
        const strParsed = checkStringRangeOnPropierties(
          str,
          this.#propierties
        );
        this.#numericRange = // @ts-ignore
        Number.parseFloat(strParsed.replaceAll(/^\D+/g, "")) * isNegative;
        this.#unitMisure = getRangeUnitMisure(strParsed);
      }
    }
    #calcFixedLimit() {
      const screenUnit = this.#scrollerHeight / 100;
      if (this.#dynamicStart && this.#dynamicStart?.position && this.#dynamicStart?.value?.() !== void 0) {
        const { position: position2, value: fn } = this.#dynamicStart;
        const valueResult = fn();
        if (!Number.isNaN(valueResult)) {
          this.#start = `${position2} ${valueResult}px`;
        }
      }
      const {
        value: startPoint,
        additionalVal: additionalStartVal,
        position: startPosition
      } = getStartPoint(screenUnit, this.#start, this.#direction);
      this.#invertSide = startPosition === MobScrollerConstant.POSITION_TOP || startPosition === MobScrollerConstant.POSITION_LEFT;
      this.#startPoint = processFixedLimit(
        startPoint,
        additionalStartVal,
        this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? this.#height : this.#width,
        this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? this.#width : this.#height
      );
      if (this.#dynamicEnd && this.#dynamicEnd?.position && this.#dynamicEnd?.value?.() !== void 0) {
        const { position: position2, value: fn } = this.#dynamicEnd;
        const valueResult = fn();
        if (!Number.isNaN(valueResult)) {
          this.#end = `${position2} ${valueResult}px`;
        }
      }
      const {
        value: endPoint,
        additionalVal: additionalEndVal,
        position: endPosition
      } = getEndPoint(
        screenUnit,
        this.#end,
        this.#startPoint,
        this.#scrollerHeight,
        this.#invertSide,
        this.#direction
      );
      const multiplier = (() => {
        if (this.#invertSide) {
          return endPosition === MobScrollerConstant.POSITION_BOTTOM || endPosition === MobScrollerConstant.POSITION_RIGHT ? -1 : 1;
        } else {
          return endPosition === MobScrollerConstant.POSITION_BOTTOM || endPosition === MobScrollerConstant.POSITION_RIGHT ? 1 : -1;
        }
      })();
      this.#endPoint = processFixedLimit(
        endPoint,
        additionalEndVal,
        this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? this.#height * multiplier : this.#width * multiplier,
        this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? this.#width * multiplier : this.#height * multiplier
      );
      this.#setMarker();
      if (this.#invertSide) this.#startPoint -= this.#height;
    }
    #setMarker() {
      if (this.#marker) {
        const { startMarker, endMarker } = MobScrollerMarker({
          startMarker: this.#startMarker,
          endMarker: this.#endMarker,
          startPoint: this.#startPoint,
          endPoint: this.#endPoint,
          screen: this.#screen,
          direction: this.#direction,
          invertSide: this.#invertSide,
          label: this.#marker
        });
        this.#startMarker = startMarker;
        this.#endMarker = endMarker;
      }
    }
    #calcOffset() {
      const el = this.#trigger ?? this.#item;
      if (!el) return;
      let x = 0;
      let y = 0;
      let z = 0;
      if (this.#trigger) {
        x = getTranslateValues(this.#trigger)?.x ?? 0;
        y = getTranslateValues(this.#trigger)?.y ?? 0;
        z = getTranslateValues(this.#trigger)?.z ?? 0;
      }
      el.style.transform = "";
      if (this.#direction === MobScrollerConstant.DIRECTION_VERTICAL) {
        this.#offset = this.#scroller === globalThis ? Math.trunc(offset(el).top) : Math.trunc(offset(el).top) - offset(
          /** @type {HTMLElement} */
          this.#scroller
        ).top;
      } else {
        this.#offset = this.#scroller === globalThis ? Math.trunc(offset(el).left) : Math.trunc(offset(el).left) - offset(
          /** @type {HTMLElement} */
          this.#scroller
        ).left;
      }
      if (this.#screen && this.#screen !== globalThis) {
        this.#offset -= this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? Math.trunc(
          offset(
            /** @type {HTMLElement} */
            this.#screen
          ).top
        ) : Math.trunc(
          position(
            /** @type {HTMLElement} */
            this.#screen
          ).left
        );
      }
      if (this.#trigger && (x !== 0 || y !== 0 || z !== 0)) {
        this.#trigger.style.transform = `translate3D(${x}px, ${y}px, ${z}px)`;
      }
    }
    #calcScreenPosition() {
      if (this.#screen === globalThis || !this.#screen) return;
      this.#screenPosition = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? Math.trunc(
        offset(
          /** @type {HTMLElement} */
          this.#screen
        ).top
      ) : Math.trunc(
        position(
          /** @type {HTMLElement} */
          this.#screen
        ).left
      );
    }
    #calcHeight() {
      const el = this.#trigger ?? this.#item;
      if (!el) return;
      this.#height = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? Math.trunc(el.offsetHeight) : Math.trunc(el.offsetWidth);
    }
    #calcWidth() {
      const el = this.#trigger ?? this.#item;
      if (!el) return;
      this.#width = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? Math.trunc(el.offsetWidth) : Math.trunc(el.offsetHeight);
    }
    #getScrollerOffset() {
      if (!this.#scroller) return;
      if (this.#scroller === globalThis) {
        this.#scrollerScroll = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? this.#scroller.scrollY : this.#scroller.scrollX;
      } else {
        this.#scrollerScroll = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? -offset(
          /** @type {HTMLElement} */
          this.#scroller
        ).top : -offset(
          /** @type {HTMLElement} */
          this.#scroller
        ).left;
      }
    }
    #getScreenHeight() {
      if (!this.#screen) return;
      this.#windowInnerWidth = window.innerWidth;
      this.#windowInnerHeight = window.innerHeight;
      if (this.#screen === globalThis) {
        this.#scrollerHeight = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? window.innerHeight : window.innerWidth;
      } else {
        this.#scrollerHeight = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? (
          // @ts-ignore
          Math.trunc(this.#screen.offsetHeight)
        ) : (
          // @ts-ignore
          Math.trunc(this.#screen.offsetWidth)
        );
      }
    }
    /**
     * Recalculate positions and align all values
     */
    refresh() {
      if (this.#pin && this.#pinInstance) this.#pinInstance.destroy();
      this.#calcScreenPosition();
      this.#calcOffset();
      this.#calcHeight();
      this.#calcWidth();
      this.#getScreenHeight();
      if (this.#type == MobScrollerConstant.TYPE_SCROLLTRIGGER) {
        this.#calcFixedLimit();
        if (this.#dynamicRange) this.#calcRangeAndUnitMiusure();
        if (this.#pin && this.#pinInstance && mq[this.#queryType](this.#breakpoint)) {
          this.#pinInstance?.init(this.#getPinParams());
        }
      }
      this.#lastValue = void 0;
      this.#firstTime = true;
      if (mq[this.#queryType](this.#breakpoint)) {
        if (this.#ease) {
          this.#easeRender();
        } else {
          this.#updateEndValue();
          this.#noEasingRender({ forceRender: true });
        }
      } else {
        if (this.#ease) this.#motion?.stop?.();
        modules_exports.useFrameIndex(() => {
          if (this.#applyTo) {
            this.#resetTweenStyle(this.#applyTo);
            Object.assign(this.#applyTo.style, this.#getResetStyle());
          } else {
            this.#resetTweenStyle(this.#item);
            if (this.#item)
              Object.assign(this.#item.style, this.#getResetStyle());
          }
        }, 3);
      }
    }
    /**
     * Method used to control the instance from the outside. The methods accept two parameters:
     *
     * `value`: The scroll position of the parent. If no value is provided, the instance will calculate it autonomously.
     *
     * `parentIsMoving`: Value that indicates if the component using the method is moving. The value is used to manage
     * the addition of the translate3D property. The default value is false
     *
     * @example
     *     ```javascript
     *
     *
     *     Control the instance from another scrollTrigger:
     *
     *     const myScroller = mobbu.createScrollTrigger({
     *         ...
     *         onTick: ({ value, parentIsMoving }) => {
     *             myInstance.move({ value, parentIsMoving });
     *         },
     *         ...
     *     });
     *     ```;
     *
     * @param {import('./type.js').MobScrollerMove} obj
     */
    move({ value, parentIsMoving = false }) {
      if (!mq[this.#queryType](this.#breakpoint) || !value) return;
      this.#iSControlledFromOutside = true;
      const scrollVal = this.#getScrollValueOnMove(value);
      if (this.#ease) {
        this.#easeRender(scrollVal);
      } else {
        this.#updateEndValue(scrollVal);
        const forceRender = this.#isInViewport || this.#firstTime || void 0;
        this.#noEasingRender({ forceRender, parentIsMoving });
      }
    }
    /**
     * Trigger scrollStart event Used by smoothScroll to activate 3D if child (this) have ease = true
     */
    triggerScrollStart() {
      if (!this.#ease) return;
      if (!this.#disableForce3D) this.#force3D = true;
    }
    /**
     * Trigger scrollEnd event Used by smoothScroll to deactivate 3D if child (this) have ease = false
     */
    triggerScrollEnd() {
      if (this.#ease) return;
      this.#noEasingRender({ forceRender: true });
    }
    /**
     * @param {number | undefined} value
     */
    #getScrollValueOnMove(value) {
      if (value === void 0) return;
      if (this.#screen !== globalThis) return value + this.#screenPosition;
      return value;
    }
    /**
     * Stop lerp|spring tween.
     */
    stopMotion() {
      this.#motion?.stop?.();
    }
    /**
     * @param {number} [scrollVal]
     */
    #updateEndValue(scrollVal) {
      if (!mq[this.#queryType](this.#breakpoint)) return;
      if (scrollVal) {
        this.#scrollerScroll = -scrollVal;
      } else {
        this.#getScrollerOffset();
      }
      this.#isInViewport = detectViewPortInterception({
        offset: this.#offset,
        height: this.#height,
        gap: this.#gap,
        wScrollTop: this.#scrollerScroll,
        wHeight: this.#scrollerHeight
      });
      if (!this.#isInViewport && !this.#limiterOff && this.#type === MobScrollerConstant.TYPE_PARALLAX)
        return;
      if (this.#pin && this.#pinInstance) {
        this.#pinInstance.onScroll(this.#scrollerScroll);
      }
      switch (this.#type) {
        case MobScrollerConstant.TYPE_SCROLLTRIGGER: {
          this.#endValue = getRoundedValue(this.#getFixedValue());
          break;
        }
        default: {
          switch (this.#propierties) {
            case MobScrollerConstant.PROP_OPACITY: {
              this.#endValue = getRoundedValue(
                this.#getOpacityValue()
              );
              break;
            }
            default: {
              this.#endValue = Number.isNaN(
                // @ts-ignore
                Number.parseInt(this.#align)
              ) ? getRoundedValue(this.#getIsNaNValue() / 2) : getRoundedValue(this.#getIsANumberValue() / 2);
              break;
            }
          }
        }
      }
      const reverseValue = this.#reverse && this.#type !== MobScrollerConstant.TYPE_SCROLLTRIGGER ? getRetReverseValue(this.#propierties, this.#endValue) : this.#endValue;
      this.#endValue = this.#type === MobScrollerConstant.TYPE_SCROLLTRIGGER ? reverseValue : this.#getSwitchAfterZeroValue(reverseValue);
    }
    /**
     * @param {number} [scrollVal]
     */
    #easeRender(scrollVal) {
      if (!mq[this.#queryType](this.#breakpoint)) return;
      this.#updateEndValue(scrollVal);
      if (!this.#fixedShouldRender && !this.#firstTime && this.#type === MobScrollerConstant.TYPE_SCROLLTRIGGER)
        return;
      if (!this.#isInViewport && !this.#firstTime && this.#type === MobScrollerConstant.TYPE_PARALLAX)
        return;
      const action2 = this.#firstTime && !this.#animateAtStart ? "set" : "goTo";
      if (!this.#motion) return;
      this.#motion[action2]({ val: this.#endValue }, this.#motionParameters).catch(() => {
      });
    }
    /**
     * @param {object} params
     * @param {boolean} [params.forceRender]
     * @param {boolean} [params.parentIsMoving]
     * @returns {void}
     */
    #noEasingRender({ forceRender = false, parentIsMoving = false } = {}) {
      if (!mq[this.#queryType](this.#breakpoint)) return;
      modules_exports.useFrame(() => {
        if (this.#endValue === this.#lastValue && !forceRender || !this.#isInViewport && !forceRender)
          return;
        if (!this.#disableForce3D && !this.#iSControlledFromOutside)
          this.#force3D = !forceRender;
        if (!this.#disableForce3D && this.#iSControlledFromOutside)
          this.#force3D = parentIsMoving && this.#isInViewport;
        if (this.#propierties === MobScrollerConstant.PROP_TWEEN) {
          this.#tween.draw({
            partial: this.#endValue,
            isLastDraw: !this.#force3D,
            useFrame: false
          });
          this.#lastValue = this.#endValue;
          this.#firstTime = false;
        } else {
          this.#updateStyle(this.#endValue);
        }
        modules_exports.useNextTick(() => {
          if (this.#onTickCallback)
            this.#onTickCallback({
              value: this.#endValue,
              parentIsMoving: this.#force3D
            });
        });
      });
    }
    #getFixedValue() {
      const partials = this.#invertSide ? -(this.#scrollerScroll + this.#startPoint + this.#endPoint - (this.#offset + this.#endPoint)) : -(this.#scrollerScroll + this.#scrollerHeight - this.#startPoint - (this.#offset + this.#endPoint));
      const maxVal = this.#endPoint / 100 * this.#numericRange;
      const partialVal = partials / 100 * this.#numericRange;
      const valePerDirections = (() => {
        if (this.#reverse) {
          return this.#invertSide ? maxVal - partialVal : partialVal;
        } else {
          return this.#invertSide ? partialVal : maxVal - partialVal;
        }
      })();
      const clampValue = maxVal > 0 ? -clamp3(valePerDirections, 0, maxVal) : -clamp3(valePerDirections, maxVal, 0);
      this.#fixedShouldRender = this.#prevFixedClamp !== clampValue;
      this.#prevFixedClamp = clampValue;
      if (!this.#fixedShouldRender && !this.#firstTime) return this.#endValue;
      const percentValue = clampValue * 100 / this.#endPoint;
      if (this.#onEnter || this.#onEnterBack || this.#onLeave || this.#onLeaveBack) {
        MobScrollerEmitter({
          prevValue: this.#prevFixedRawValue,
          value: valePerDirections,
          maxVal,
          onEnter: this.#onEnter,
          onEnterBack: this.#onEnterBack,
          onLeave: this.#onLeave,
          onLeaveBack: this.#onLeaveBack
        });
      }
      this.#prevFixedRawValue = valePerDirections;
      switch (this.#propierties) {
        case MobScrollerConstant.PROP_HORIZONTAL:
        case MobScrollerConstant.PROP_VERTICAL: {
          return this.#getHVval(percentValue);
        }
        case MobScrollerConstant.PROP_SCALE:
        case MobScrollerConstant.PROP_SCALE_X:
        case MobScrollerConstant.PROP_SCALE_Y:
        case MobScrollerConstant.PROP_OPACITY: {
          return 1 - percentValue;
        }
        default: {
          return -percentValue;
        }
      }
    }
    /**
     * @param {number} percent
     */
    #getHVval(percent) {
      switch (this.#unitMisure) {
        case MobScrollerConstant.VW: {
          return this.#windowInnerWidth / 100 * -percent;
        }
        case MobScrollerConstant.VH: {
          return this.#windowInnerHeight / 100 * -percent;
        }
        case MobScrollerConstant.WPERCENT: {
          return this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? this.#width / 100 * -percent : this.#height / 100 * -percent;
        }
        case MobScrollerConstant.HPERCENT: {
          return this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? this.#height / 100 * -percent : this.#width / 100 * -percent;
        }
        default: {
          return -percent;
        }
      }
    }
    #getOpacityValue() {
      const vhLimit = this.#scrollerHeight / 100 * this.#opacityEnd;
      const vhStart = this.#scrollerHeight - this.#scrollerHeight / 100 * this.#opacityStart;
      const value = this.#align == MobScrollerConstant.ALIGN_START ? -this.#scrollerScroll * -1 : (this.#scrollerScroll + vhLimit - this.#offset) * -1;
      const valClamped = this.#align == MobScrollerConstant.ALIGN_START ? 1 - value / this.#offset : 1 - value / (this.#scrollerHeight - vhStart - vhLimit);
      return clamp3(valClamped, 0, 1);
    }
    #getIsNaNValue() {
      const valuetoNumber = Number(this.#range);
      const rangeNumber = Number.isNaN(valuetoNumber) ? 0 : valuetoNumber;
      const documentHeight = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? document.documentElement.scrollHeight : document.documentElement.scrollWidth;
      switch (this.#align) {
        case MobScrollerConstant.ALIGN_START: {
          return this.#scrollerScroll / rangeNumber;
        }
        case MobScrollerConstant.ALIGN_TOP:
        case MobScrollerConstant.ALIGN_LEFT: {
          return (this.#scrollerScroll - this.#offset) / rangeNumber;
        }
        case MobScrollerConstant.ALIGN_CENTER: {
          return (this.#scrollerScroll + (this.#scrollerHeight / 2 - this.#height / 2) - this.#offset) / rangeNumber;
        }
        case MobScrollerConstant.ALIGN_BOTTOM:
        case MobScrollerConstant.ALIGN_RIGHT: {
          return (this.#scrollerScroll + (this.#scrollerHeight - this.#height) - this.#offset) / rangeNumber;
        }
        case MobScrollerConstant.ALIGN_END: {
          return -(documentHeight - (this.#scrollerScroll + this.#scrollerHeight)) / rangeNumber;
        }
        default: {
          return 0;
        }
      }
    }
    /**
     * Here the value is a number.
     */
    #getIsANumberValue() {
      const align = Number(this.#align);
      const range = Number(this.#range);
      return (this.#scrollerScroll + this.#scrollerHeight / 100 * align - this.#offset) / range;
    }
    /**
     * @param {number} value
     */
    #getSwitchAfterZeroValue(value) {
      return getValueOnSwitch({
        switchPropierties: this.#onSwitch,
        isReverse: this.#reverse,
        value
      });
    }
    /**
     * @param {number} value
     */
    #updateStyle(value) {
      if (this.#applyTo) {
        Object.assign(this.#applyTo.style, this.#getStyle(value));
      } else if (this.#item) {
        Object.assign(this.#item.style, this.#getStyle(value));
      }
      this.#lastValue = value;
      this.#firstTime = false;
    }
    /**
     * @param {number} value
     */
    #getStyle(value) {
      if (this.#shouldTrackOnlyEvents) return;
      const force3DStyle = this.#force3D ? "translate3D(0px, 0px, 0px)" : "";
      this.#willChangeIsActive = this.#useWillChange ? modules_exports.mustMakeSomething() : false;
      const shouldWill = this.#willChangeIsActive && this.#force3D ? "transform" : "";
      const valueParsed = modules_exports.shouldMakeSomething() ? Math.round(value) : value;
      switch (this.#propierties) {
        case MobScrollerConstant.PROP_VERTICAL: {
          return {
            // translate: `0 ${val}px`,
            // transform: `${force3DStyle}`,
            transform: `${force3DStyle} translateY(${valueParsed}px)`,
            willChange: shouldWill
          };
        }
        case MobScrollerConstant.PROP_HORIZONTAL: {
          return {
            transform: `${force3DStyle} translateX(${valueParsed}px)`,
            willChange: shouldWill
          };
        }
        case MobScrollerConstant.PROP_ROTATE: {
          return {
            transform: `${force3DStyle} rotate(${valueParsed}deg)`,
            willChange: shouldWill
          };
        }
        case MobScrollerConstant.PROP_ROTATEY: {
          return {
            transform: `${force3DStyle} rotateY(${valueParsed}deg)`,
            willChange: shouldWill
          };
        }
        case MobScrollerConstant.PROP_ROTATEX: {
          return {
            transform: `${force3DStyle} rotateX(${valueParsed}deg)`,
            willChange: shouldWill
          };
        }
        case MobScrollerConstant.PROP_ROTATEZ: {
          return {
            transform: `${force3DStyle} rotateZ(${valueParsed}deg)`,
            willChange: shouldWill
          };
        }
        case MobScrollerConstant.PROP_OPACITY: {
          return { opacity: `${value}` };
        }
        case MobScrollerConstant.PROP_SCALE: {
          const scaleVal = this.#type === MobScrollerConstant.TYPE_SCROLLTRIGGER ? value : 1 + value / 1e3;
          return {
            transform: `${force3DStyle} scale(${scaleVal})`,
            willChange: shouldWill
          };
        }
        case MobScrollerConstant.PROP_SCALE_X: {
          const scaleVal = this.#type === MobScrollerConstant.TYPE_SCROLLTRIGGER ? value : 1 + value / 1e3;
          return {
            transform: `${force3DStyle} scaleX(${scaleVal})`,
            willChange: shouldWill
          };
        }
        case MobScrollerConstant.PROP_SCALE_Y: {
          const scaleVal = this.#type === MobScrollerConstant.TYPE_SCROLLTRIGGER ? value : 1 + value / 1e3;
          return {
            transform: `${force3DStyle} scaleY(${scaleVal})`,
            willChange: shouldWill
          };
        }
        default: {
          return {
            [this.#propierties.toLowerCase()]: `${value}px`
          };
        }
      }
    }
    /**
     * Reset sequencer/parallaxTween style
     *
     * @param {HTMLElement | null} item
     */
    #resetTweenStyle(item) {
      if (this.#tween && item) item.style = "";
    }
    /**
     * Reset default style
     */
    #getResetStyle() {
      if (this.#shouldTrackOnlyEvents) return;
      switch (this.#propierties) {
        case MobScrollerConstant.PROP_VERTICAL:
        case MobScrollerConstant.PROP_HORIZONTAL:
        case MobScrollerConstant.PROP_ROTATE:
        case MobScrollerConstant.PROP_ROTATEY:
        case MobScrollerConstant.PROP_ROTATEX:
        case MobScrollerConstant.PROP_ROTATEZ:
        case MobScrollerConstant.PROP_SCALE: {
          return {
            transform: ``
          };
        }
        case MobScrollerConstant.PROP_OPACITY: {
          return { opacity: `` };
        }
        default: {
          return { [this.#propierties.toLowerCase()]: `` };
        }
      }
    }
    /**
     * Destroy instance
     */
    destroy() {
      this.#motion?.stop?.();
      this.#unsubscribeScroll();
      this.#unsubscribeScrollStart();
      this.#unsubscribeScrollEnd();
      this.#unsubscribeResize();
      this.#unsubscribeMotion();
      this.#unsubscribeOnComplete();
      this.#unsubscribeMarker();
      this.#motion?.destroy?.();
      this.#motion = null;
      this.#dynamicRange = () => {
      };
      if (this.#dynamicStart?.value) this.#dynamicStart.value = () => 0;
      if (this.#dynamicEnd?.value) this.#dynamicEnd.value = () => 0;
      this.#onEnter = () => {
      };
      this.#onEnterBack = () => {
      };
      this.#onLeave = () => {
      };
      this.#onLeaveBack = () => {
      };
      this.#onTickCallback = () => {
      };
      if (this.#pin && this.#pinInstance) this.#pinInstance?.destroy?.();
      if (this.#startMarker) this.#startMarker?.remove?.();
      if (this.#endMarker) this.#endMarker?.remove?.();
      this.#startMarker = void 0;
      this.#endMarker = void 0;
      this.#pinInstance = void 0;
      this.#endValue = 0;
      const el = this.#applyTo ?? this.#item;
      if (el && "style" in el) el.style = "";
      this.#item = null;
      this.#scroller = null;
      this.#screen = null;
      this.#trigger = null;
      this.#applyTo = null;
    }
  };

  // src/js/mob/mob-motion/scroller.js
  function createParallax(data) {
    return new MobScroller({
      ...data,
      // @ts-ignore
      type: MobScrollerConstant.TYPE_PARALLAX
    });
  }
  function createScrollTrigger(data) {
    return new MobScroller({
      ...data,
      // @ts-ignore
      type: MobScrollerConstant.TYPE_SCROLLTRIGGER
    });
  }

  // src/js/mob/mob-motion/plugin/page-scroll/page-scroller.js
  var windowInnerheight = window.innerHeight;
  var windowOffsetheight = document.body.offsetHeight;
  var isActive = false;
  var usePrevent = true;
  var lastScrollValue = window.scrollY;
  var useNativeScroll = true;
  var isFreezed = false;
  var destroy = () => {
  };
  var stop = () => {
  };
  var update2 = () => {
  };
  var rootElementToObserve;
  var removeWhellingClass = () => {
    document.body.classList.remove("is-whelling");
  };
  var addWhellingClass = () => {
    document.body.classList.add("is-whelling");
  };
  core_exports.setDefault({
    usePassive: false
  });
  var MobPageScroller = ({ velocity, rootElement }) => {
    let lerp2 = tween_exports.createLerp({
      data: { scrollValue: window.scrollY },
      precision: 1,
      velocity: 0.1
    });
    rootElementToObserve = rootElement;
    const unsubscribe3 = lerp2.subscribe(({ scrollValue }) => {
      if (isFreezed) return;
      window.scrollTo({
        top: Math.round(scrollValue),
        left: 0,
        behavior: "instant"
      });
    });
    lerp2.onComplete(() => {
      lastScrollValue = window.scrollY;
    });
    const unsubscribeMouseWheel = modules_exports.useMouseWheel((event) => {
      if (isFreezed) return;
      event.preventDefault();
      useNativeScroll = false;
      addWhellingClass();
      const spinY = clamp3(event.spinY ?? 0, -1, 1);
      const currentValue = core_exports.clamp(
        spinY * velocity + lastScrollValue,
        0,
        windowOffsetheight - windowInnerheight
      );
      lastScrollValue = currentValue;
      lerp2.goTo({ scrollValue: currentValue }).catch(() => {
      });
    });
    const unsubscribeWhellPrevent = modules_exports.useMouseWheel(
      ({ preventDefault }) => {
        if (usePrevent) preventDefault();
      }
    );
    const unsubscribeDebounceWheel = modules_exports.useMouseWheel(
      debounceFuncion(() => {
        removeWhellingClass();
      }, 500)
    );
    const unsubsribeScrollEnd = modules_exports.useScrollEnd(() => {
      const value = window.scrollY;
      lastScrollValue = value;
      lerp2.setImmediate({ scrollValue: value });
    });
    const unsubscribeScroll = modules_exports.useScroll(() => {
      if (!useNativeScroll) {
        return;
      }
      const value = window.scrollY;
      lastScrollValue = value;
      lerp2.setImmediate({ scrollValue: value });
    });
    const unsubscribePointerDown = modules_exports.usePointerDown(() => {
      if (isFreezed) return;
      removeWhellingClass();
      lerp2.stop();
      lastScrollValue = window.scrollY;
      useNativeScroll = true;
    });
    const resizeObserver = new ResizeObserver(() => {
      lerp2.stop();
      lerp2.setImmediate({ scrollValue: window.scrollY });
      lastScrollValue = window.scrollY;
      windowInnerheight = window.innerHeight;
      windowOffsetheight = document.body.offsetHeight;
    });
    resizeObserver.observe(rootElement);
    return {
      destroy: () => {
        isActive = false;
        lastScrollValue = 0;
        useNativeScroll = true;
        isFreezed = false;
        if (rootElementToObserve) {
          resizeObserver.unobserve(rootElementToObserve);
          resizeObserver.disconnect();
        }
        lerp2?.stop();
        lerp2?.destroy();
        lerp2 = null;
        rootElementToObserve = null;
        unsubscribe3();
        unsubscribeScroll();
        unsubsribeScrollEnd();
        unsubscribeMouseWheel();
        unsubscribePointerDown();
        unsubscribeDebounceWheel();
        unsubscribeWhellPrevent();
        destroy = () => {
        };
        stop = () => {
        };
        update2 = () => {
        };
      },
      stop: () => {
        lerp2.stop();
        lastScrollValue = window.scrollY;
      },
      update: () => {
        lerp2.setImmediate({ scrollValue: window.scrollY });
      }
    };
  };
  var InitMobPageScroll = ({
    velocity = 100,
    rootElement = document.createElement("div")
  } = {}) => {
    if (isActive) return;
    lastScrollValue = window.scrollY;
    isActive = true;
    isFreezed = false;
    windowInnerheight = window.innerHeight;
    windowOffsetheight = document.body.offsetHeight;
    usePrevent = true;
    useNativeScroll = false;
    ({ destroy, stop, update: update2 } = MobPageScroller({
      velocity,
      rootElement
    }));
  };
  var FreezeMobPageScroll = () => {
    if (!isActive || isFreezed) return;
    stop();
    isFreezed = true;
  };
  var UnFreezeMobPageScroll = () => {
    if (!isActive || !isFreezed) return;
    isFreezed = false;
  };
  var UnFreezeAndUPdateMobPageScroll = () => {
    if (!isActive || !isFreezed) return;
    update2();
    lastScrollValue = window.scrollY;
    isFreezed = false;
  };
  var UpdateMobPageScroll = () => {
    if (!isActive) return;
    update2();
  };
  var DestroyMobPageScroll = () => {
    destroy();
  };
  var enebalePreventScroll = () => {
    usePrevent = true;
  };
  var getActiveStateScroll = () => {
    return isActive;
  };

  // src/js/mob/mob-motion/plugin/body-scroll/body-scroll.js
  var defaultPreset = "easeOutQuad";
  var tween = new MobTimeTween({ ease: defaultPreset, data: { val: 0 } });
  var isRunning = false;
  var overflow = false;
  tween.subscribe(({ val: val2 }) => {
    window.scrollTo({
      top: val2,
      left: 0,
      behavior: "auto"
    });
    UpdateMobPageScroll();
  });
  var onComplete = () => {
    if (overflow) document.body.style.overflow = "";
    tween?.updateEase?.(defaultPreset);
    UnFreezeAndUPdateMobPageScroll();
  };
  var stopTween = () => {
    if (!isRunning) return;
    tween.stop();
    onComplete();
  };
  modules_exports.useMouseWheel(() => {
    stopTween();
  });
  modules_exports.useMouseDown(() => {
    stopTween();
  });
  modules_exports.useTouchStart(() => {
    stopTween();
  });
  var MobBodyScroll = /* @__PURE__ */ (() => {
    const to = (target, data) => {
      if (typeof globalThis === "undefined") return;
      const targetParsed = (() => {
        if (!target) return 0;
        const isValid = isNode(target) || modules_exports.checkType(Number, target);
        if (!isValid) {
          console.warn(
            `bodyScroll ${target} is not valid target, must be a node or a number`
          );
          return 0;
        }
        return isNode(target) ? offset(
          /** @type {HTMLElement} */
          target
        ).top : (
          /** @type {number} */
          target
        );
      })();
      const duration2 = valueIsNumberAndReturnDefault(
        data?.duration,
        "bodyScroll: duration",
        500
      );
      overflow = valueIsBooleanAndReturnDefault(
        data?.overflow,
        "bodyScroll: overflow",
        false
      );
      if (easeTweenIsValid(data?.ease)) {
        tween?.updateEase?.(
          /** @type {import('../../animation/tween/type.js').EaseTypes} */
          data?.ease
        );
      }
      if (overflow) document.body.style.overflow = "hidden";
      return new Promise((resolve) => {
        isRunning = true;
        FreezeMobPageScroll();
        tween.goFromTo(
          { val: window.scrollY },
          { val: targetParsed },
          { duration: duration2 }
        ).then(() => {
          onComplete();
          isRunning = false;
          resolve(true);
        }).catch(() => {
          onComplete();
          isRunning = false;
          resolve(true);
        });
      });
    };
    return {
      to
    };
  })();

  // src/js/mob/mob-motion/plugin/horizontal-scroller/js/horizontal-scroller-constant.js
  var horizontalScrollerContstant = {
    END: "END",
    START: "START",
    CENTER: "CENTER"
  };

  // src/js/mob/mob-motion/plugin/horizontal-scroller/js/horizontal-scroller-css.js
  var getAlign = (columnAlign) => {
    switch (columnAlign) {
      case horizontalScrollerContstant.END: {
        return "align-items:flex-end;";
      }
      case horizontalScrollerContstant.CENTER: {
        return "align-items:center;";
      }
      default: {
        return "align-items:flex-start;";
      }
    }
  };
  var horizontalScrollerCss = ({
    mainContainer,
    queryType,
    breakpoint,
    container,
    trigger,
    row,
    column,
    shadow,
    useSticky,
    columnHeight,
    columnWidth,
    columnAlign
  }) => {
    const media = mq["getBreackpoint"](breakpoint);
    const userSelect = `user-select:none`;
    const triggerPosition = useSticky ? "relative" : "absolute";
    const rowSticky = useSticky ? "position:sticky;top:0;" : "";
    const align = getAlign(columnAlign);
    const width = columnWidth ? `width:${columnWidth}vw;` : "";
    const css = `
      @media (${queryType}-width:${media}px){${container}{position:relative;${userSelect}}}@media (${queryType}-width:${media}px){${trigger}{z-index:10;position:${triggerPosition};pointer-events:none;overflow:hidden;top:0;left:0;right:0}}@media (${queryType}-width:${media}px){${row}{--sectionheight:${columnHeight}vh}}@media (${queryType}-width:${media}px){${row}{display:flex;height:100vh;${rowSticky}${align}}}@media (${queryType}-width:${media}px){${column}{height:var(--sectionheight);flex:0 0 auto;${width}}}.${shadow}{display:none}@media (${queryType}-width:${media}px){.${shadow}{width:100%;display:block;pointer-events:none}}.${shadow}{display:none}@media (${queryType}-width:${media}px){.${shadow}{pointer-events:none;display:block;position:absolute;left:0;right:0}.${shadow}--end,.${shadow}--in-center,.${shadow}--left,.${shadow}--out-center{opacity:0;border:1px red dashed;width:25%}.${shadow}--end.debug,.${shadow}--in-center.debug,.${shadow}--left.debug,.${shadow}--out-center.debug{opacity:1}.${shadow}--in-center{position:absolute;top:0;right:0;padding:0 40px;text-align:center}.${shadow}--out-center{position:absolute;top:0;right:0;padding:0 40px;text-align:center}.${shadow}--left{position:absolute;top:0;left:50%;transform:translateX(-50%);padding:0 40px;text-align:center}.${shadow}--end{position:absolute;top:0;left:0;padding-left:40px}}`;
    const styleDiv = document.createElement("div");
    styleDiv.classList.add("scroller-style");
    const style = document.createElement("style");
    style.append(document.createTextNode(css));
    styleDiv.append(style);
    mainContainer.prepend(styleDiv);
  };

  // src/js/mob/mob-motion/plugin/horizontal-scroller/js/horizontal-scroller.js
  var MobHorizontalScroller = class {
    /**
     * @type {boolean}
     */
    #propsisValid;
    /**
     * @type {number}
     */
    #triggerTopPosition;
    /**
     * @type {boolean}
     */
    #touchActive;
    /**
     * @type {number}
     */
    #lastTouchValueX;
    /**
     * @type {number}
     */
    #dragSecureAreaBottom;
    /**
     * @type {number}
     */
    #dragSecureAreaTop;
    /**
     * @type {boolean}
     */
    #shouldDragValue;
    /**
     * @type {number}
     */
    #scrollValue;
    /**
     * @type {() => void}
     */
    #unsubscribeScroll;
    /**
     * @type {boolean}
     */
    #useDrag;
    /**
     * @type {number}
     */
    #threshold;
    /**
     * @type {boolean}
     */
    #useWillChange;
    /**
     * @type {import('../../../utils/type').MqValues}
     */
    #breakpoint;
    /**
     * @type {import('../../../utils/type').MqAction}
     */
    #queryType;
    /**
     * @type {boolean}
     */
    #forceTranspond;
    /**
     * @type {boolean}
     */
    #addCss;
    /**
     * @type {boolean}
     */
    #animateAtStart;
    /**
     * @type {boolean}
     */
    #ease;
    /**
     * @type {'lerp' | 'spring'}
     */
    #easeType;
    /**
     * @type {boolean}
     */
    #useSticky;
    /**
     * @type {boolean}
     */
    #animatePin;
    /**
     * @type {boolean}
     */
    #reverse;
    /**
     * @type {boolean}
     */
    #useThrottle;
    /**
     * @type {number}
     */
    #columnHeight;
    /**
     * @type {number}
     */
    #columnWidth;
    /**
     * @type {string}
     */
    #columnAlign;
    /**
     * @type {() => void}
     */
    #onEnter;
    /**
     * @type {() => void}
     */
    #onEnterBack;
    /**
     * @type {() => void}
     */
    #onLeave;
    /**
     * @type {() => void}
     */
    #onLeaveBack;
    /**
     * @type {() => void}
     */
    #afterInit;
    /**
     * @type {() => void}
     */
    #afterRefresh;
    /**
     * @type {() => void}
     */
    #afterDestroy;
    /**
     * @type {import('./type').HorizontalScrollerOnTick | undefined}
     */
    #onTick;
    /**
     * Dom element
     */
    /**
     * @type {HTMLElement}
     */
    #mainContainer;
    /**
     * @type {string}
     */
    #container;
    /**
     * @type {HTMLElement}
     */
    #trigger;
    /**
     * @type {HTMLElement}
     */
    #row;
    /**
     * @type {NodeListOf<HTMLElement>}
     */
    #columns;
    /**
     * @type {NodeListOf<HTMLElement> | undefined}
     */
    #shadows;
    #shadowMainClassTransition;
    /**
     * @type {NodeListOf<HTMLElement> | []}
     */
    #buttons;
    /**
     * @type {boolean}
     */
    #moduleisActive;
    /**
     * @type {number}
     */
    #horizontalWidth;
    /**
     * @type {MobScroller}
     */
    #scrollTriggerInstance;
    /**
     * @type {number}
     */
    #percentRange;
    /**
     * Initialize children.
     *
     * @type {MobScroller[]}
     */
    #children;
    /**
     * Scoped event.
     *
     * @type {(arg0: MouseEvent) => void}
     * @returns {void}
     */
    #onMouseMove;
    /**
     * @type {(arg0: MouseEvent) => void}
     * @returns {void}
     */
    #onMouseDown;
    /**
     * @type {(arg0: MouseEvent) => void}
     * @returns {void}
     */
    #onMouseUp;
    /**
     * @type {(arg0: MouseEvent) => void}
     * @returns {void}
     */
    #onMouseLeave;
    /**
     * @type {(arg0: TouchEvent) => void}
     * @returns {void}
     */
    #onTouchStart;
    /**
     * @type {() => void}
     * @returns {void}
     */
    #onTouchEnd;
    /**
     * @type {(arg0: TouchEvent) => void}
     * @returns {void}
     */
    #onTouchMove;
    /**
     * @type {EventListener}
     * @returns {void}
     */
    #preventFireClick;
    /**
     * @type {number}
     */
    #firstTouchValue;
    /**
     * Create new HorizontalScroller instance.
     *
     * Special attributes to handle shadow elements: Apply the following data-attributes to any element
     *
     * `data-shadow="<String>"` Create a vertical shadow element with a custom className.
     *
     * `data-debug` Makes the shadow element visible
     *
     * Available methods: myHorizontalScroller.init(); myHorizontalScroller.refresh(); myHorizontalScroller.destroy();
     *
     * @example
     *     ```html
     *         HTML:
     *         <div class="root">
     *             <div class="container">
     *                 <div class="row">
     *                     <section class="column" data-shadow="section1">
     *                         <h1>title</h1>
     *                     </section>
     *                     <section class="column">
     *                         <h1 data-shadow="title" data-debug>title</h1>
     *                     </section>
     *                     ...
     *                 </div>
     *                 <div class="trigger"></div>
     *             </div>
     *         </div>
     *     ``````javascript
     *         JS:
     *         const myHorizontalScroller = new HorizontalScroller({
     *             root: '.root',
     *             container: '.container',
     *             row: '.row',
     *             column: '.column',
     *             trigger: '.trigger',
     *             shadowClass: '.myShadowClass,
     *             useThrottle: [ Boolean ],
     *             useSticky: [ Boolean ],
     *             animatePin: [ Boolean ],
     *             forceTranspond: [ Boolean ],
     *             useWillChange: [ Boolean ],
     *             animateAtStart: [ Boolean ],
     *             queryType: [ String ],
     *             breakpoint: [ String ],
     *             ease: [ Boolean ],
     *             easeType: [ String ],
     *             addCss: [ Boolean ],
     *             columnHeight: [ Number ],
     *             columnWidth: [ Number ],
     *             columnAlign: [ String ],
     *             children: [child1,child2, ...],
     *             onEnter: () => {
     *                 ...
     *             },
     *             onEnterBack: () => {
     *                 ...
     *             },
     *             onLeave: () => {
     *                 ...
     *             },
     *             onLeaveBack: () => {
     *                 ...
     *             },
     *             afterInit: () => {
     *                 ...
     *             },
     *             onTick: ({ value, parentIsMoving, percent }) => {
     *                 ...
     *             },
     *             afterRefresh: () => {
     *                 ...
     *             },
     *             afterDestroy: () => {
     *                 ...
     *             },
     *         });
     *     ```;
     *
     * @param {import('./type').MobHorizontalScroller} data
     */
    constructor(data) {
      this.#propsisValid = true;
      this.#triggerTopPosition = 0;
      this.#touchActive = false;
      this.#lastTouchValueX = 0;
      this.#dragSecureAreaBottom = 100;
      this.#dragSecureAreaTop = 100;
      this.#shouldDragValue = false;
      this.#scrollValue = 0;
      this.#unsubscribeScroll = () => {
      };
      this.#firstTouchValue = 0;
      this.#container = data?.container ?? "";
      this.#buttons = [];
      this.#moduleisActive = false;
      this.#horizontalWidth = 0;
      this.#scrollTriggerInstance = {};
      this.#percentRange = 0;
      this.#children = data?.children || [];
      this.#useDrag = valueIsBooleanAndReturnDefault(
        data?.useDrag,
        "HorizontalScroller: useDrag",
        false
      );
      this.#threshold = valueIsNumberAndReturnDefault(
        data?.threshold,
        "HorizontalScroller: threshold",
        30
      );
      this.#useWillChange = valueIsBooleanAndReturnDefault(
        data?.useWillChange,
        "HorizontalScroller: useWillChange",
        false
      );
      this.#breakpoint = breakpointIsValid(
        data?.breakpoint,
        "breakpoint",
        "horizontalScroller"
      );
      this.#queryType = breakpointTypeIsValid(
        data?.queryType,
        "queryType",
        "horizontalScroller"
      );
      this.#forceTranspond = valueIsBooleanAndReturnDefault(
        data?.forceTranspond,
        "HorizontalScroller: forceTranspond",
        false
      );
      this.#addCss = valueIsBooleanAndReturnDefault(
        data?.addCss,
        "HorizontalScroller: addCss",
        true
      );
      this.#animateAtStart = valueIsBooleanAndReturnDefault(
        data?.animateAtStart,
        "HorizontalScroller: animateAtStart",
        false
      );
      this.#ease = valueIsBooleanAndReturnDefault(
        data?.ease,
        "HorizontalScroller: ease",
        false
      );
      this.#easeType = genericEaseTypeIsValid(
        data?.easeType ?? "",
        "HorizontalScroller"
      );
      this.#useSticky = valueIsBooleanAndReturnDefault(
        data?.useSticky,
        "HorizontalScroller: useSticky",
        false
      );
      this.#animatePin = valueIsBooleanAndReturnDefault(
        data?.animatePin,
        "HorizontalScroller: animatePin",
        false
      );
      this.#reverse = valueIsBooleanAndReturnDefault(
        data?.reverse,
        "HorizontalScroller: reverse",
        false
      );
      this.#useThrottle = valueIsBooleanAndReturnDefault(
        data?.useThrottle,
        "HorizontalScroller: useThrottle",
        false
      );
      this.#columnHeight = valueIsNumberAndReturnDefault(
        data?.columnHeight,
        "HorizontalScroller: columnHeight",
        100
      );
      this.#columnWidth = valueIsNumberAndReturnDefault(
        data?.columnWidth,
        "HorizontalScroller: columnWidth",
        null
      );
      this.#columnAlign = data?.columnAlign ? data.columnAlign.toUpperCase() : horizontalScrollerContstant.START;
      this.#onEnter = valueIsFunctionAndReturnDefault(
        data?.onEnter,
        "HorizontalScroller: onEnter",
        NOOP
      );
      this.#onEnterBack = valueIsFunctionAndReturnDefault(
        data?.onEnterBack,
        "HorizontalScroller: onEnterBack",
        NOOP
      );
      this.#onLeave = valueIsFunctionAndReturnDefault(
        data?.onLeave,
        "HorizontalScroller: onLeave",
        NOOP
      );
      this.#onLeaveBack = valueIsFunctionAndReturnDefault(
        data?.onLeaveBack,
        "HorizontalScroller: onLeaveBack",
        NOOP
      );
      this.#afterInit = valueIsFunctionAndReturnDefault(
        data?.afterInit,
        "HorizontalScroller: afterInit",
        NOOP
      );
      this.#afterRefresh = valueIsFunctionAndReturnDefault(
        data?.afterRefresh,
        "HorizontalScroller: afterRefresh",
        NOOP
      );
      this.#afterDestroy = valueIsFunctionAndReturnDefault(
        data?.afterDestroy,
        "HorizontalScroller: afterDestroy",
        NOOP
      );
      this.#onTick = valueIsFunctionAndReturnDefault(
        data?.onTick,
        "HorizontalScroller: onTick",
        // eslint-disable-next-line unicorn/no-useless-undefined
        void 0
      );
      this.#mainContainer = modules_exports.checkType(String, data.root) ? (
        // @ts-ignore
        document.querySelector(data.root)
      ) : data.root;
      if (!this.#mainContainer) {
        this.#propsisValid = false;
        console.warn("horizontal custom: root node not found");
      }
      const scrollerTester = this.#mainContainer.querySelector(
        this.#container
      );
      if (!scrollerTester) {
        this.#propsisValid = false;
        console.warn("horizontal custom: container node not found");
      }
      this.#trigger = this.#mainContainer.querySelector(data.trigger);
      if (!this.#trigger) {
        this.#propsisValid = false;
        console.warn("horizontal custom: trigger node not found");
      }
      this.#row = this.#mainContainer.querySelector(data.row);
      if (!this.#row) {
        this.#propsisValid = false;
        console.warn("horizontal custom: row node not found");
      }
      this.#columns = this.#mainContainer.querySelectorAll(data.column);
      if (this.#columns.length === 0) {
        this.#propsisValid = false;
        console.warn("horizontal custom: column nodeList not found");
      }
      this.#shadows = this.#mainContainer.querySelectorAll("[data-shadow]");
      const originalShadowClass = data?.shadowClass || "shadow";
      this.#shadowMainClassTransition = originalShadowClass.replace(".", "");
      this.#buttons = this.#row.querySelectorAll("a, button");
      this.#children.forEach((element) => {
        if (this.#row) element.setScroller(this.#row);
        element.setDirection("horizontal");
        element.setBreakPoint(this.#breakpoint);
        element.setQueryType(this.#queryType);
        element.init();
      });
      if (this.#addCss)
        horizontalScrollerCss({
          mainContainer: this.#mainContainer,
          queryType: this.#queryType,
          breakpoint: this.#breakpoint,
          container: this.#container,
          trigger: data?.trigger ?? "trigger",
          row: data.row,
          column: data.column,
          shadow: this.#shadowMainClassTransition,
          useSticky: this.#useSticky,
          columnHeight: this.#columnHeight,
          columnWidth: this.#columnWidth,
          columnAlign: this.#columnAlign
        });
      this.#onMouseMove = (event) => {
        if (!this.#touchActive) return;
        const { movementX } = event;
        const value = this.#reverse ? movementX : -movementX;
        this.#onDrag(value);
      };
      this.#onMouseDown = () => {
        if (!mq[this.#queryType](this.#breakpoint)) return;
        FreezeMobPageScroll();
        if (this.#shouldDragValue && this.#row)
          this.#row.style.cursor = "move";
        this.#touchActive = true;
        this.#firstTouchValue = this.#scrollValue;
      };
      this.#onMouseUp = () => {
        UnFreezeMobPageScroll();
        this.#touchActive = false;
        modules_exports.useFrame(() => {
          if (this.#row) this.#row.style.cursor = "";
        });
      };
      this.#onMouseLeave = () => {
        UnFreezeMobPageScroll();
        this.#touchActive = false;
        modules_exports.useFrame(() => {
          if (this.#row) this.#row.style.cursor = "";
        });
      };
      this.#onTouchStart = (event) => {
        if (!mq[this.#queryType](this.#breakpoint)) return;
        FreezeMobPageScroll();
        this.#lastTouchValueX = -event.touches[0].clientX;
        this.#touchActive = true;
        this.#firstTouchValue = this.#scrollValue;
      };
      this.#onTouchEnd = () => {
        UnFreezeMobPageScroll();
        this.#touchActive = false;
      };
      this.#onTouchMove = (event) => {
        const touchValueX = -event.touches[0].clientX;
        const gapX = this.#reverse ? -touchValueX + this.#lastTouchValueX : touchValueX - this.#lastTouchValueX;
        this.#onDrag(gapX);
        this.#lastTouchValueX = touchValueX;
        if (this.#shouldDragValue && event.cancelable && event.defaultPrevented)
          event.preventDefault();
      };
      this.#preventFireClick = (event) => {
        if (Math.abs(this.#scrollValue - this.#firstTouchValue) > this.#threshold)
          event.preventDefault();
      };
    }
    /**
     * Initialize insatance
     *
     * @example
     *     myInstance.init();
     *
     * @type {() => void}
     */
    init() {
      if (!this.#propsisValid) return;
      pipe(
        this.#getWidth.bind(this),
        this.#setDimension.bind(this),
        this.#createShadow.bind(this),
        this.#updateShadow.bind(this)
      )().then(() => {
        this.#initScroller();
        if (this.#useDrag) this.#addDragListener();
        modules_exports.useResize(
          ({ horizontalResize }) => this.onResize(horizontalResize)
        );
        modules_exports.useFrameIndex(() => {
          modules_exports.useNextTick(() => {
            this.#afterInit?.();
            this.#children.forEach((element) => {
              element.refresh();
            });
          });
        }, 3);
      });
    }
    /**
     * @type {() => void}
     */
    #setLinkAttribute() {
      [...this.#buttons].forEach(
        (item) => item.setAttribute("draggable", "false")
      );
    }
    /**
     * @type {() => void}
     */
    #removeLinkAttribute() {
      [...this.#buttons].forEach((item) => item.removeAttribute("draggable"));
    }
    /**
     * @type {(value: number) => void}
     */
    #onDrag(value) {
      if (!this.#shouldDragValue) return;
      modules_exports.useFrame(
        () => window.scrollBy({ top: value, left: 0, behavior: "instant" })
      );
    }
    /**
     * @type {() => void}
     */
    #shouldDrag() {
      const documentScrollTop = window.scrollY;
      this.#shouldDragValue = this.#triggerTopPosition - this.#dragSecureAreaTop < documentScrollTop && this.#triggerTopPosition + this.#dragSecureAreaBottom + this.#horizontalWidth > documentScrollTop + window.innerHeight;
    }
    /**
     * @type {() => void}
     */
    #addDragListener() {
      this.#unsubscribeScroll = modules_exports.useScroll(() => this.#shouldDrag());
      this.#shouldDrag();
      this.#row.addEventListener("click", this.#preventFireClick, {
        passive: false
      });
      this.#row.addEventListener("mousedown", this.#onMouseDown, {
        passive: true
      });
      this.#row.addEventListener("mouseup", this.#onMouseUp, {
        passive: true
      });
      this.#row.addEventListener("mouseleave", this.#onMouseLeave, {
        passive: true
      });
      this.#row.addEventListener("touchstart", this.#onTouchStart, {
        passive: true
      });
      this.#row.addEventListener("touchend", this.#onTouchEnd, {
        passive: true
      });
      this.#row.addEventListener("mousemove", this.#onMouseMove, {
        passive: true
      });
      this.#row.addEventListener("touchmove", this.#onTouchMove, {
        passive: true
      });
    }
    /**
     * @type {() => void}
     */
    #removeDragListener() {
      this.#unsubscribeScroll();
      this.#row.removeEventListener("click", this.#preventFireClick);
      this.#row.removeEventListener("mousedown", this.#onMouseDown);
      this.#row.removeEventListener("mouseup", this.#onMouseUp);
      this.#row.removeEventListener("mouseleave", this.#onMouseLeave);
      this.#row.removeEventListener("touchstart", this.#onTouchStart);
      this.#row.removeEventListener("touchend", this.#onTouchEnd);
      this.#row.removeEventListener("mousemove", this.#onMouseMove);
      this.#row.removeEventListener("touchmove", this.#onTouchMove);
    }
    /**
     * @type {() => Promise<boolean>}
     */
    #setDimension() {
      if (!this.#trigger || !this.#mainContainer || !this.#row) {
        return new Promise((resolve) => {
          resolve(true);
        });
      }
      return new Promise((resolve) => {
        modules_exports.useFrame(() => {
          const width = this.#horizontalWidth;
          this.#percentRange = 100 * (width - window.innerWidth) / width;
          if (width > 0) {
            this.#trigger.style.height = `${width}px`;
            this.#mainContainer.style.height = `${width}px`;
            this.#row.style.width = `${width}px`;
          }
          resolve(true);
        });
      });
    }
    /**
     * @type {() => Promise<boolean>}
     */
    #getWidth() {
      return new Promise((resolve) => {
        modules_exports.useFrame(() => {
          if (!mq[this.#queryType](this.#breakpoint)) {
            resolve(true);
            return;
          }
          this.#horizontalWidth = [...this.#columns].map((item) => {
            return outerWidth(item);
          }).reduce((a, b) => a + b, 0);
          resolve(true);
        });
      });
    }
    /**
     * @type {() => Promise<boolean>}
     */
    #createShadow() {
      if (!this.#trigger) {
        return new Promise((resolve) => {
          resolve(true);
        });
      }
      return new Promise((resolve) => {
        modules_exports.useFrame(() => {
          if (!mq[this.#queryType](this.#breakpoint) || !this.#shadows) {
            resolve(true);
            return;
          }
          const shadowsTransition = [...this.#shadows].map((item) => {
            const shadowLabel = item.dataset["shadow"];
            const useDebug = Object.hasOwn(item.dataset, "debug");
            const debugClass = useDebug ? "debug" : "";
            const leftLabel = useDebug ? `left left : ${shadowLabel}` : "";
            const inCenterLabel = useDebug ? `in center : ${shadowLabel}` : "";
            const outCenterlabel = useDebug ? `center out : ${shadowLabel}` : "";
            const endLabel = useDebug ? `in out : ${shadowLabel}` : "";
            return (
              /* HTML */
              ` <div
                            class="${this.#shadowMainClassTransition} ${this.#shadowMainClassTransition}--${shadowLabel}"
                            data-shadow="${shadowLabel}"
                        >
                            <span
                                class="${this.#shadowMainClassTransition}--in-center ${debugClass}"
                            >
                                ${inCenterLabel}
                            </span>
                            <span
                                class="${this.#shadowMainClassTransition}--out-center ${debugClass}"
                            >
                                ${outCenterlabel}
                            </span>
                            <span
                                class="${this.#shadowMainClassTransition}--left ${debugClass}"
                            >
                                ${leftLabel}
                            </span>
                            <span
                                class="${this.#shadowMainClassTransition}--end ${debugClass}"
                            >
                                ${endLabel}
                            </span>
                        </div>`
            );
          }).join("");
          this.#trigger.innerHTML = shadowsTransition;
          resolve(true);
        });
      });
    }
    /**
     * @type {() => void}
     */
    #removeShadow() {
      if (this.#trigger) this.#trigger.innerHTML = "";
    }
    /**
     * @type {() => Promise<boolean>}
     */
    #updateShadow() {
      return new Promise((resolve) => {
        if (!mq[this.#queryType](this.#breakpoint)) {
          resolve(true);
          return;
        }
        modules_exports.useFrame(() => {
          if (!this.#shadows) return;
          [...this.#shadows].forEach((item) => {
            const percentrange = this.#percentRange / 100;
            const shadowData = item.dataset["shadow"];
            const width = outerWidth(item);
            const height = outerHeight(this.#row);
            const x = getTranslateValues(this.#row)?.x ?? 0;
            const offset2 = this.#reverse ? this.#horizontalWidth - (item.getBoundingClientRect().right - x) : item.getBoundingClientRect().left - x;
            const screenRatio = window.innerWidth / window.innerHeight;
            const windowDifference = window.innerWidth - window.innerHeight;
            const widthAmount = offset2 / screenRatio;
            const diffAmount = offset2 - offset2 / screenRatio;
            const shadowTransitionEl = this.#mainContainer.querySelector(
              `.${this.#shadowMainClassTransition}[data-shadow="${shadowData}"]`
            );
            const inCenterMarker = shadowTransitionEl?.querySelector(
              `.${this.#shadowMainClassTransition}--in-center`
            );
            const outCenterMarker = shadowTransitionEl?.querySelector(
              `.${this.#shadowMainClassTransition}--out-center`
            );
            const leftMarker = shadowTransitionEl?.querySelector(
              `.${this.#shadowMainClassTransition}--left`
            );
            const endMarker = shadowTransitionEl?.querySelector(
              `.${this.#shadowMainClassTransition}--end`
            );
            const plusFull = window.innerWidth > window.innerHeight ? window.innerHeight : 0;
            const plusHalf = window.innerWidth > window.innerHeight ? window.innerHeight / 2 : 0;
            const start = (() => {
              switch (offset2) {
                case 0: {
                  return 0;
                }
                default: {
                  return widthAmount + diffAmount / percentrange - windowDifference / percentrange;
                }
              }
            })();
            const left = (() => {
              const val2 = window.innerWidth > window.innerHeight ? windowDifference / percentrange : windowDifference / percentrange + window.innerWidth / screenRatio;
              switch (offset2) {
                case 0: {
                  return 0;
                }
                default: {
                  return val2;
                }
              }
            })();
            const end = (() => {
              const val1 = width / screenRatio;
              const val2 = (width - width / screenRatio) / percentrange;
              return val1 + val2 + left;
            })();
            const inCenter = (() => {
              return end / 2 + plusHalf;
            })();
            if (this.#useSticky) {
              this.#trigger.style["margin-top"] = `-${height}px`;
            }
            if (shadowTransitionEl)
              shadowTransitionEl.style.top = `${start}px`;
            if (inCenterMarker)
              inCenterMarker.style.height = `${inCenter}px`;
            if (outCenterMarker)
              outCenterMarker.style.height = `${inCenter}px`;
            if (outCenterMarker)
              outCenterMarker.style.top = `${inCenter}px`;
            if (leftMarker) leftMarker.style.height = `${left}px`;
            if (endMarker)
              endMarker.style.height = `${end + plusFull}px`;
            if (shadowTransitionEl)
              shadowTransitionEl.style.height = `${left}px`;
          });
          resolve(true);
        });
      });
    }
    /**
     * @type {() => void}
     */
    #initScroller() {
      if (!this.#trigger || !mq[this.#queryType](this.#breakpoint)) return;
      const scrollTriggerInstance = new MobScroller({
        type: "scrolltrigger",
        item: this.#row,
        useWillChange: this.#useWillChange,
        trigger: this.#trigger,
        propierties: "x",
        breakpoint: "xSmall",
        pin: !this.#useSticky,
        animatePin: this.#animatePin,
        ease: this.#ease,
        forceTranspond: this.#forceTranspond,
        useThrottle: this.#useThrottle,
        easeType: this.#easeType,
        springConfig: "scroller",
        animateAtStart: this.#animateAtStart,
        reverse: this.#reverse,
        dynamicRange: () => {
          return -(this.#horizontalWidth - window.innerWidth);
        },
        dynamicStart: {
          position: "bottom",
          value: () => {
            return window.innerHeight;
          }
        },
        dynamicEnd: {
          position: "bottom",
          value: () => {
            return this.#horizontalWidth;
          }
        },
        onTick: ({ value, parentIsMoving }) => {
          const valueParsed = value ?? 0;
          const percent = Math.abs(
            -Math.round(
              valueParsed * 100 / (this.#horizontalWidth - window.innerWidth)
            )
          );
          this.#scrollValue = valueParsed;
          if (this.#onTick)
            this.#onTick({
              value: valueParsed,
              parentIsMoving,
              percent: this.#reverse ? 100 - percent : percent
            });
          this.#children.forEach((element) => {
            element.move({ value: valueParsed, parentIsMoving });
          });
        },
        onEnter: this.#onEnter,
        onEnterBack: this.#onEnterBack,
        onLeave: this.#onLeave,
        onLeaveBack: this.#onLeaveBack
      });
      scrollTriggerInstance.init();
      this.#moduleisActive = true;
      this.#scrollTriggerInstance = scrollTriggerInstance;
      this.#triggerTopPosition = offset(this.#trigger).top;
      this.#setLinkAttribute();
    }
    /**
     * @type {() => void}
     */
    #createScroller() {
      pipe(
        this.#getWidth.bind(this),
        this.#setDimension.bind(this),
        this.#createShadow.bind(this),
        this.#updateShadow.bind(this)
      )().then(() => {
        this.#initScroller();
        this.#refreshChildren();
      });
    }
    /**
     * @type {() => void}
     */
    #refreshChildren() {
      modules_exports.useFrameIndex(() => {
        modules_exports.useNextTick(() => {
          this.#afterRefresh?.();
          this.#children.forEach((element) => {
            element?.refresh?.();
          });
        });
      }, 3);
    }
    /**
     * Refresh instance
     *
     * @example
     *     myInstance.refresh();
     *
     * @type {() => Promise<boolean>}
     */
    refresh() {
      if (!this.#moduleisActive || !mq[this.#queryType](this.#breakpoint))
        return new Promise((resolve) => resolve(true));
      return new Promise((resolve) => {
        pipe(
          this.#getWidth.bind(this),
          this.#setDimension.bind(this),
          this.#updateShadow.bind(this)
        )().then(() => {
          this.#scrollTriggerInstance?.stopMotion?.();
          this.#triggerTopPosition = offset(this.#trigger).top;
          if (this.#moduleisActive) {
            this.#scrollTriggerInstance?.refresh?.();
            this.#refreshChildren();
          }
          resolve(true);
        });
      });
    }
    /**
     * @type {(arg0: { destroyAll?: boolean }) => void}
     */
    #killScroller({ destroyAll = false }) {
      if (this.#moduleisActive || destroyAll) {
        this.#scrollTriggerInstance?.destroy?.();
        this.#scrollTriggerInstance = null;
        if (this.#trigger) this.#trigger.style.height = "";
        if (this.#mainContainer) this.#mainContainer.style.height = "";
        if (this.#trigger) this.#trigger.style.marginTop = "";
        this.#removeShadow();
        this.#removeLinkAttribute();
        this.#moduleisActive = false;
        modules_exports.useFrameIndex(() => {
          if (this.#row) {
            this.#row.style.width = "";
            this.#row.style.transform = "";
          }
          if (destroyAll && this.#mainContainer) {
            if (this.#useDrag) this.#removeDragListener();
            const styleDiv = this.#mainContainer.querySelector(".scroller-style");
            if (styleDiv) styleDiv.remove();
            this.#mainContainer = null;
            this.#trigger = null;
            this.#row = null;
            this.#columns = [];
            this.#shadows = [];
            this.#afterInit = NOOP;
            this.#afterRefresh = NOOP;
            this.#onTick = NOOP;
            this.#onEnter = NOOP;
            this.#onEnterBack = NOOP;
            this.#onLeave = NOOP;
            this.#onLeaveBack = NOOP;
            this.#scrollTriggerInstance = null;
            this.#moduleisActive = false;
            this.#buttons = [];
            this.#mainContainer = null;
            this.#container = null;
            this.#trigger = null;
            this.#row = null;
            modules_exports.useNextTick(() => {
              this.#afterDestroy?.();
              this.#afterDestroy = NOOP;
              this.#children.forEach((element) => {
                element?.destroy?.();
                element = null;
              });
              this.#children = [];
            });
          }
        }, 3);
      }
    }
    /**
     * @type {(horizontalResize: boolean) => void}
     */
    onResize(horizontalResize) {
      if (this.#moduleisActive && mq[this.#queryType](this.#breakpoint)) {
        if (horizontalResize) this.refresh();
      } else if (!this.#moduleisActive && mq[this.#queryType](this.#breakpoint)) {
        this.#createScroller();
      } else if (this.#moduleisActive && !mq[this.#queryType](this.#breakpoint)) {
        this.#killScroller({ destroyAll: false });
      }
    }
    /**
     * Destroy instance
     *
     * @example
     *     myInstance.destroy();
     *
     * @type {() => void}
     */
    destroy() {
      this.#killScroller({ destroyAll: true });
    }
  };

  // src/js/mob/mob-motion/plugin/slide/slide.js
  var slideItems = /* @__PURE__ */ new Map();
  var isNode2 = (target) => {
    const isValid = modules_exports.checkType(Element, target);
    if (!isValid)
      console.warn(`slide utils ${target} is not a valid Dom element`);
    return isValid;
  };
  var setSlideData = (target) => {
    const tween2 = new MobTimeTween({ ease: "easeOutQuad", data: { val: 0 } });
    return {
      tween: tween2,
      unsubscribe: tween2.subscribe(({ val: val2 }) => {
        target.style.height = `${val2}px`;
      })
    };
  };
  var MobSlide = /* @__PURE__ */ (() => {
    const subscribe = (target) => {
      if (!isNode2(target)) return () => {
      };
      const alreadySubscribe = slideItems.has(target);
      if (alreadySubscribe) {
        console.warn(`slide utils ${target} is alredysubscribed`);
        return () => {
        };
      }
      const data = setSlideData(target);
      slideItems.set(target, data);
      return () => {
        data.unsubscribe();
        const { tween: tween2 } = data;
        tween2.destroy();
        slideItems.delete(target);
      };
    };
    const reset = (target) => {
      if (!isNode2(target)) return;
      target.style.height = "0";
      target.style.overflow = "hidden";
    };
    const up = async (target) => {
      if (!isNode2(target)) {
        return new Promise((resolve) => resolve(true));
      }
      const currentItem = slideItems.get(target);
      if (!currentItem) {
        console.warn("slide element not exist in slide store");
        return new Promise((resolve) => resolve(true));
      }
      const { tween: tween2 } = currentItem;
      const currentHeight = outerHeight(target);
      await tween2.goFromTo(
        { val: currentHeight },
        { val: 0 },
        { duration: 500 }
      );
    };
    const down = async (target) => {
      if (!isNode2(target)) {
        return new Promise((resolve) => resolve(true));
      }
      const currentItem = slideItems.get(target);
      if (!currentItem) {
        console.warn("slide element not exist in slide store");
        return new Promise((resolve) => resolve(true));
      }
      const { tween: tween2 } = currentItem;
      const { val: currentHeight } = tween2.get();
      target.style.height = `auto`;
      const height = outerHeight(target);
      target.style.height = `${currentHeight}px`;
      await tween2.goTo({ val: height }, { duration: 500 });
      modules_exports.useNextTick(() => {
        target.style.height = `auto`;
      });
    };
    return { subscribe, reset, up, down };
  })();

  // src/js/mob/mob-motion/plugin/smooth-scroller/smooth-scroller.js
  var MobSmoothScroller = class {
    /**
     * @type {boolean}
     */
    #propsIsValid;
    /**
     * @type {number}
     */
    #endValue;
    /**
     * @type {number}
     */
    #percent;
    /**
     * @type {number}
     */
    #screenWidth;
    /**
     * @type {number}
     */
    #screenHeight;
    /**
     * @type {number}
     */
    #firstTouchValue;
    /**
     * @type {number}
     */
    #threshold;
    /**
     * @type {number}
     */
    #maxValue;
    /**
     * @type {boolean}
     */
    #dragEnable;
    /**
     * @type {number}
     */
    #prevTouchVal;
    /**
     * @type {number}
     */
    #touchVal;
    /**
     * @type {() => void}
     */
    #subscribeResize;
    /**
     * @type {() => void}
     */
    #subscribeScrollStart;
    /**
     * @type {() => void}
     */
    #subscribeScrollEnd;
    /**
     * @type {() => void}
     */
    #subscribeTouchStart;
    /**
     * @type {() => void}
     */
    #subscribeTouchEnd;
    /**
     * @type {() => void}
     * @returns {void}
     */
    #subscribeMouseDown;
    /**
     * @type {() => void}
     * @returns {void}
     */
    #subscribeMouseUp;
    /**
     * @type {() => void}
     * @returns {void}
     */
    #subscribeMouseWheel;
    /**
     * @type {() => void}
     * @returns {void}
     */
    #subscribeMouseMove;
    /**
     * @type {() => void}
     * @returns {void}
     */
    #subscribeTouchMove;
    /**
     * @type {() => void}
     * @returns {void}
     */
    #subscribeMouseClick;
    /**
     * @type {() => void}
     * @returns {void}
     */
    #subscribeDebuoceWhell;
    /**
     * @type {MobLerp | MobSpring}
     */
    #motion;
    /**
     * @type {() => void}
     */
    #subscribeMotion;
    /**
     * @type {() => void}
     */
    #subscribeOnComplete;
    /**
     * @type {string}
     */
    #direction;
    /**
     * @type {boolean}
     */
    #isDestroyed;
    /**
     * @type {'lerp' | 'spring'}
     */
    #easeType;
    /**
     * @type {import('../../utils/type.js').MqValues}
     */
    #breakpoint;
    /**
     * @type {import('../../utils/type.js').MqAction}
     */
    #queryType;
    #scroller;
    #screen;
    /**
     * @type {boolean}
     */
    #scopedEvent;
    /**
     * @type {number}
     */
    #speed;
    /**
     * @type {boolean}
     */
    #drag;
    /**
     * @type {import('./type.js').OnTick}
     */
    #onTickCallback;
    /**
     * @type {import('./type.js').OnUpdate}
     */
    #onUpdateCallback;
    /**
     * @type {import('./type.js').OnSwipe}
     */
    #onSwipeCallback;
    /**
     * @type {(arg0: { shouldScroll: boolean }) => void}
     */
    #onAfterRefresh;
    /**
     * @type {(arg0: { shouldScroll: boolean }) => void}
     */
    #afterInit;
    /**
     * @type {boolean}
     */
    #swipeisActive;
    /**
     * @type {any[]}
     */
    #children;
    /**
     * @type {(arg0: Event) => void}
     */
    #scopedWhell;
    /**
     * @type {(arg0: Event) => void}
     */
    #scopedTouchMove;
    /**
     * @type {number}
     */
    #lastSpinX;
    /**
     * @type {number}
     */
    #lastSpinY;
    /**
     * @type {boolean}
     */
    #useHorizontalScroll;
    /**
     * @type {boolean}
     */
    #useSwipe;
    /**
     * @type {boolean}
     */
    #revertSwipeDirection;
    /**
     * Create new SmoothScroller instance.
     *
     *        Available methods:
     *        mySmoothScroll.init();
     *        mySmoothScroll.refresh();
     *        mySmoothScroll.destroy();
     *        mySmoothScroll.move();
     *        mySmoothScroll.set();
     *
     * @example
     *     ```javascript
     *        const mySmoothScroller = new SmoothScroller({
     *            screen: [String | Element],
     *            scroller: [String | Element],
     *            direction: [String],
     *            speed: [Number],
     *            drag: [Boolean],
     *            scopedEvent: [Boolean],
     *            children: [child1,child2, ...],
     *            ease: [Boolean],
     *            easeType: [String],
     *            afterInit: () => {
     *                ...
     *            },
     *            onTick: ({ value, parentIsMoving, percent }) => {
     *                ...
     *            },
     *            onUpdate: ({ value, percent }) => {
     *                ...
     *            },
     *            afterRefresh: () => {
     *                ...
     *            },
     *        });
     *
     *        mySmoothScroller.init();
     *        ```;
     *
     * @param {import('./type.js').MobSmoothScroller} data
     */
    constructor(data) {
      this.#propsIsValid = true;
      this.#endValue = 0;
      this.#percent = 0;
      this.#screenWidth = 0;
      this.#screenHeight = 0;
      this.#firstTouchValue = 0;
      this.#threshold = 30;
      this.#maxValue = 0;
      this.#dragEnable = false;
      this.#prevTouchVal = 0;
      this.#touchVal = 0;
      this.#lastSpinX = 0;
      this.#lastSpinY = 0;
      this.#swipeisActive = false;
      this.#subscribeResize = NOOP;
      this.#subscribeScrollStart = NOOP;
      this.#subscribeScrollEnd = NOOP;
      this.#subscribeTouchStart = NOOP;
      this.#subscribeTouchEnd = NOOP;
      this.#subscribeMouseDown = NOOP;
      this.#subscribeMouseUp = NOOP;
      this.#subscribeMouseWheel = NOOP;
      this.#subscribeMouseMove = NOOP;
      this.#subscribeTouchMove = NOOP;
      this.#subscribeMouseClick = NOOP;
      this.#subscribeDebuoceWhell = NOOP;
      this.#motion = {};
      this.#subscribeMotion = NOOP;
      this.#subscribeOnComplete = NOOP;
      this.#direction = directionIsValid(data?.direction, "SmoothScroller");
      this.#isDestroyed = false;
      this.#easeType = genericEaseTypeIsValid(
        data?.easeType ?? "",
        "SmoothScroller"
      );
      this.#breakpoint = breakpointIsValid(
        data?.breakpoint,
        "breakpoint",
        "SmoothScroller"
      );
      this.#queryType = breakpointTypeIsValid(
        data?.queryType,
        "queryType",
        "SmoothScroller"
      );
      this.#scroller = modules_exports.checkType(String, data?.scroller) ? document.querySelector(
        /** @type {string} */
        data.scroller
      ) : data.scroller;
      if (!this.#scroller) {
        console.warn("SmoothScroller: scroller node not found");
        this.#propsIsValid = false;
      }
      this.#screen = data?.screen ? (() => {
        return modules_exports.checkType(String, data.screen) ? document.querySelector(
          /** @type {string} */
          data.screen
        ) : data.screen;
      })() : document.documentElement;
      if (!this.#screen) {
        this.#propsIsValid = false;
        console.warn("SmoothScroller: screen node not found");
      }
      this.#scopedEvent = valueIsBooleanAndReturnDefault(
        data?.scopedEvent,
        "SmoothScroller: scopedEvent",
        false
      );
      this.#speed = valueIsNumberAndReturnDefault(
        data?.speed,
        "SmoothScroller: speed",
        60
      );
      this.#drag = valueIsBooleanAndReturnDefault(
        data?.drag,
        "SmoothScroller: drag",
        false
      );
      this.#onTickCallback = valueIsFunctionAndReturnDefault(
        data?.onTick,
        "SmoothScroller: onTick",
        NOOP
      );
      this.#onUpdateCallback = valueIsFunctionAndReturnDefault(
        data?.onUpdate,
        "SmoothScroller: onUpdate",
        NOOP
      );
      this.#onSwipeCallback = valueIsFunctionAndReturnDefault(
        data?.onSwipe,
        "SmoothScroller: onSwipe",
        NOOP
      );
      this.#useSwipe = valueIsBooleanAndReturnDefault(
        data?.useSwipe,
        "SmoothScroller: useSwipe",
        false
      );
      this.#revertSwipeDirection = valueIsBooleanAndReturnDefault(
        data?.revertSwipeDirection,
        "SmoothScroller: revertSwipeDirection",
        false
      );
      this.#useHorizontalScroll = valueIsBooleanAndReturnDefault(
        data?.useHorizontalScroll,
        "SmoothScroller: useBothAxis",
        false
      );
      this.#onAfterRefresh = valueIsFunctionAndReturnDefault(
        data?.afterRefresh,
        "SmoothScroller: afterRefresh",
        NOOP
      );
      this.#afterInit = valueIsFunctionAndReturnDefault(
        data?.afterInit,
        "SmoothScroller: afterInit",
        NOOP
      );
      this.#children = data?.children || [];
      this.#children.forEach((element) => {
        element.setScroller(this.#scroller);
        element.setDirection(this.#direction);
        element.setScreen(this.#screen);
        element.setBreakPoint(this.#breakpoint);
        element.setQueryType(this.#queryType);
        element.init();
      });
      this.#scopedWhell = (event) => {
        this.#addWhellingClass();
        const { spinY } = modules_exports.normalizeWheel(event);
        this.#onScopedWhell({
          spinY
        });
      };
      this.#scopedTouchMove = (event) => {
        const { clientX, clientY } = event.touches ? (
          // @ts-ignore
          event.touches[0]
        ) : event;
        this.#onScopedTouchMove({
          client: {
            x: clientX,
            y: clientY
          }
        });
      };
      this.#subscribeDebuoceWhell = modules_exports.useMouseWheel(
        debounceFuncion(() => {
          this.#removeWhellingClass();
        }, 500)
      );
    }
    /**
     * @type {() => void}
     */
    #removeWhellingClass() {
      if (!this.#scroller) return;
      this.#scroller.classList.remove("is-whelling");
    }
    /**
     * @type {() => void}
     */
    #addWhellingClass() {
      if (!this.#scroller) return;
      this.#scroller.classList.add("is-whelling");
    }
    /**
     * Check if is scrollable
     *
     * @type {() => boolean}
     */
    #getScrollableStatus() {
      return this.#maxValue > 0;
    }
    /**
     * Initialize insatance
     *
     * @example
     *     myInstance.init();
     *
     * @type {() => void}
     */
    init() {
      if (!this.#propsIsValid) return;
      switch (this.#easeType) {
        case MobScrollerConstant.EASE_SPRING: {
          this.#motion = new MobSpring();
          break;
        }
        default: {
          this.#motion = new MobLerp();
          this.#motion.updateVelocity(0.1);
          break;
        }
      }
      if (this.#scopedEvent) {
        this.#scroller.addEventListener(
          "wheel",
          this.#scopedWhell,
          {
            passive: true
          }
        );
        this.#scroller.addEventListener(
          "mousemove",
          this.#scopedTouchMove,
          {
            passive: true
          }
        );
        this.#scroller.addEventListener(
          "touchmove",
          this.#scopedTouchMove,
          {
            passive: true
          }
        );
      }
      if (!this.#scopedEvent) {
        this.#subscribeMouseWheel = modules_exports.useMouseWheel((data) => {
          this.#detectSwipe(data);
          this.#onWhell(data);
        });
        this.#subscribeMouseMove = modules_exports.useMouseMove(
          (data) => this.#onTouchMove(data)
        );
        this.#subscribeTouchMove = modules_exports.useTouchMove(
          (data) => this.#onTouchMove(data)
        );
      }
      this.#subscribeResize = modules_exports.useResize(() => this.refresh());
      this.#subscribeScrollStart = modules_exports.useScrollStart(
        () => this.#refreshScroller()
      );
      this.#subscribeScrollEnd = modules_exports.useScrollEnd(
        () => this.#refreshScroller()
      );
      this.#subscribeTouchStart = modules_exports.useTouchStart(
        (data) => this.#onMouseDown(data)
      );
      this.#subscribeTouchEnd = modules_exports.useTouchEnd(
        (data) => this.#onMouseUp(data)
      );
      this.#subscribeMouseDown = modules_exports.useMouseDown(
        (data) => this.#onMouseDown(data)
      );
      this.#subscribeMouseUp = modules_exports.useMouseUp(
        (data) => this.#onMouseUp(data)
      );
      this.#scroller.addEventListener(
        "mouseleave",
        () => {
          UnFreezeMobPageScroll();
        }
      );
      if (this.#drag) {
        this.#subscribeMouseClick = modules_exports.useMouseClick(
          ({ target, preventDefault }) => {
            this.#preventChecker({ target, preventDefault });
          }
        );
      }
      this.#initMotion();
      if (mq[this.#queryType](this.#breakpoint)) {
        this.#setScrolerStyle();
        this.#refreshScroller();
      }
      modules_exports.useFrameIndex(() => {
        modules_exports.useNextTick(() => {
          if (this.#isDestroyed) return;
          this.#afterInit?.({
            shouldScroll: this.#getScrollableStatus()
          });
          this.#children.forEach((element) => {
            element.refresh();
          });
        });
      }, 3);
    }
    /**
     * @param {import('../../../mob-core/events/mouse-utils/type.js').MouseEventParsed} params
     */
    #detectSwipe({ pixelX }) {
      if (!this.#useSwipe || !pixelX || this.#swipeisActive || this.#onSwipeCallback.length === 0)
        return;
      if (Math.abs(pixelX) > 40) {
        this.#swipeisActive = true;
        const direction2 = pixelX > 0 ? -1 : 1;
        const directionParsed = this.#revertSwipeDirection ? direction2 : direction2 * -1;
        this.#onSwipeCallback({
          direction: directionParsed,
          move: (value) => this.move(value).catch(() => {
          })
        });
        setTimeout(() => {
          this.#swipeisActive = false;
        }, 500);
      }
    }
    /**
     * @type {() => void}
     */
    #setScrolerStyle() {
      if (!this.#scroller) return;
      this.#scroller.style["user-select"] = "none";
      const activeElements = (
        /** @type {HTMLElement} */
        this.#scroller.querySelectorAll("a, button")
      );
      [...activeElements].forEach((item) => {
        item.setAttribute("draggable", "false");
        item.style["user-select"] = "none";
      });
    }
    /**
     * @type {() => void}
     */
    #removeScrolerStyle() {
      if (!this.#scroller) return;
      this.#scroller.style["user-select"] = "";
      const activeElement = (
        /** @type {HTMLElement} */
        this.#scroller.querySelectorAll("a, button")
      );
      [...activeElement].forEach((item) => {
        item.removeAttribute("draggable");
        item.style["user-select"] = "";
      });
    }
    /**
     * @type {() => void}
     */
    #initMotion() {
      if (!this.#motion) return;
      this.#motion.setData({ val: 0 });
      this.#subscribeMotion = this.#motion.subscribe(({ val: val2 }) => {
        this.#scroller.style.transform = this.#direction == MobScrollerConstant.DIRECTION_VERTICAL ? `translate3d(0px, 0px, 0px) translateY(${-Math.trunc(val2)}px)` : `translate3d(0px, 0px, 0px) translateX(${-Math.trunc(val2)}px)`;
        this.#children.forEach((element) => {
          element.triggerScrollStart();
        });
        modules_exports.useNextTick(() => {
          this.#onTickCallback({
            value: -val2,
            percent: this.#percent,
            parentIsMoving: true
          });
          this.#children.forEach((element) => {
            element.move({
              value: -val2,
              parentIsMoving: true
            });
          });
        });
      });
      this.#subscribeOnComplete = this.#motion.onComplete(({ val: val2 }) => {
        this.#scroller.style.transform = this.#direction == MobScrollerConstant.DIRECTION_VERTICAL ? `translateY(${-Math.trunc(val2)}px)` : `translateX(${-Math.trunc(val2)}px)`;
        modules_exports.useNextTick(() => {
          this.#onTickCallback({
            value: -val2,
            percent: this.#percent,
            parentIsMoving: false
          });
          this.#children.forEach((element) => {
            element.triggerScrollEnd();
            element.move({
              value: -val2,
              parentIsMoving: false
            });
          });
        });
      });
    }
    /**
     * @type {() => void}
     */
    #refreshScroller() {
      if (!this.#screen) return;
      this.#screenWidth = this.#screen === document.documentElement ? window.innerWidth : outerWidth(
        /** @type {HTMLElement} */
        this.#screen
      );
      this.#screenHeight = this.#screen === document.documentElement ? window.innerHeight : outerHeight(
        /** @type {HTMLElement} */
        this.#screen
      );
      this.#maxValue = this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? (
        /** @type {HTMLElement} */
        this.#scroller.offsetHeight - this.#screenHeight
      ) : (
        /** @type {HTMLElement} */
        this.#scroller.offsetWidth - this.#screenWidth
      );
      this.#calculateValue();
    }
    /**
     * @type {import('./type.js').MobSmoothScrollerOnMouseEvent}
     */
    #onScopedTouchMove({ client }) {
      if (!this.#dragEnable || !this.#drag) return;
      this.#prevTouchVal = this.#touchVal;
      this.#touchVal = this.#getMousePos({
        x: client?.x ?? 0,
        y: client?.y ?? 0
      });
      this.#endValue += Math.round(this.#prevTouchVal - this.#touchVal);
      this.#calculateValue();
    }
    /**
     * Speed variation by screensize
     */
    #getDelta() {
      return this.#direction === MobScrollerConstant.DIRECTION_HORIZONTAL ? this.#screenWidth / 1920 : this.#screenHeight / 1080;
    }
    /**
     * @type {(arg0: { spinY: number }) => void}
     */
    #onScopedWhell({ spinY = 0 }) {
      if (!mq[this.#queryType](this.#breakpoint)) return;
      this.#dragEnable = false;
      const delta = this.#getDelta();
      const spinYParsed = clamp3(spinY, -1, 1);
      this.#endValue += spinYParsed * this.#speed * delta;
      this.#calculateValue();
    }
    /**
     * Listener related event. Global
     */
    /**
     * @type {import('./type.js').MobSmoothScrollerOnMouseEvent}
     */
    #onMouseDown({ target, client }) {
      if (!mq[this.#queryType](this.#breakpoint)) return;
      if (target === this.#scroller || isDescendant(
        /** @type {HTMLElement} */
        this.#scroller,
        /** @type {HTMLElement} */
        target
      )) {
        this.#firstTouchValue = this.#endValue;
        this.#dragEnable = true;
        this.#prevTouchVal = this.#getMousePos({
          x: client?.x ?? 0,
          y: client?.y ?? 0
        });
        this.#touchVal = this.#getMousePos({
          x: client?.x ?? 0,
          y: client?.y ?? 0
        });
      }
    }
    /**
     * @type {import('./type.js').MobSmoothScrollerOnMouseEvent}
     */
    #onMouseUp() {
      this.#dragEnable = false;
    }
    /**
     * @type {import('./type.js').MobSmoothScrollerOnMouseEvent}
     */
    #onTouchMove({ target, client, preventDefault }) {
      if ((target === this.#scroller || isDescendant(
        /** @type {HTMLElement} */
        this.#scroller,
        /** @type {HTMLElement} */
        target
      )) && this.#dragEnable && this.#drag) {
        preventDefault();
        this.#prevTouchVal = this.#touchVal;
        this.#touchVal = this.#getMousePos({
          x: client?.x ?? 0,
          y: client?.y ?? 0
        });
        const result = Math.round(this.#prevTouchVal - this.#touchVal);
        this.#endValue += result;
        this.#calculateValue();
      }
    }
    /**
     * @type {import('./type.js').MobSmoothScrollerOnMouseEvent}
     */
    #onWhell({ target, spinY = 0, spinX = 0, preventDefault }) {
      if (!mq[this.#queryType](this.#breakpoint)) return;
      this.#addWhellingClass();
      if (target === this.#scroller || isDescendant(
        /** @type {HTMLElement} */
        this.#scroller,
        /** @type {HTMLElement} */
        target
      )) {
        this.#dragEnable = false;
        preventDefault?.();
        FreezeMobPageScroll();
        const spinXdiff = Math.abs(this.#lastSpinX - spinX);
        const spinYdiff = Math.abs(this.#lastSpinY - spinY);
        const spinValue = this.#useHorizontalScroll && !this.#useSwipe ? (() => {
          return spinXdiff > spinYdiff ? spinX : spinY;
        })() : spinY;
        if (Math.abs(spinValue) === 0) return;
        const delta = this.#getDelta();
        this.#endValue += clamp3(spinValue, -1, 1) * this.#speed * clamp3(delta, 1, 10);
        this.#calculateValue();
        this.#lastSpinY = spinY;
        this.#lastSpinX = spinX;
      }
    }
    /**
     * Move scroller
     *
     * @example
     *     myInstance.move(val);
     *
     * @param {number} percent Position in percent, from 0 to 100
     * @returns {Promise<void>} Percent position in percent, from 0 to 100
     */
    move(percent) {
      if (!mq[this.#queryType](this.#breakpoint))
        return new Promise((resolve) => resolve());
      this.#percent = percent;
      this.#endValue = this.#percent * this.#maxValue / 100;
      return this.#motion.goTo({ val: this.#endValue });
    }
    /**
     * Move scroller immediatr
     *
     * @example
     *     myInstance.set(val);
     *
     * @param {number} percent Position in percent, from 0 to 100
     */
    set(percent) {
      if (!mq[this.#queryType](this.#breakpoint)) return;
      this.#percent = percent;
      this.#endValue = this.#percent * this.#maxValue / 100;
      this.#motion.set({ val: this.#endValue });
    }
    /**
     * Utils
     *
     * @type {() => void}
     */
    #calculateValue() {
      const percentValue = this.#endValue * 100 / this.#maxValue;
      this.#percent = clamp3(percentValue, 0, 100);
      this.#endValue = clamp3(this.#endValue, 0, this.#maxValue);
      this.#motion.goTo({ val: this.#endValue }).catch(() => {
      });
      this.#onUpdateCallback?.({
        value: -this.#endValue,
        percent: this.#percent,
        parentIsMoving: true
      });
    }
    /**
     * @type {import('./type.js').MobSmoothScrollerOnMouseEvent}
     */
    #preventChecker({ target, preventDefault }) {
      if (mq[this.#queryType](this.#breakpoint) && (target === this.#scroller || isDescendant(
        /** @type {HTMLElement} */
        this.#scroller,
        /** @type {HTMLElement} */
        target
      )) && Math.abs(this.#endValue - this.#firstTouchValue) > this.#threshold) {
        preventDefault();
      }
    }
    /**
     * @type (arg0: {x: number, y:number}) => number
     */
    #getMousePos({ x, y }) {
      if (!x || !y) return 0;
      return this.#direction === MobScrollerConstant.DIRECTION_VERTICAL ? y : x;
    }
    /**
     * Refresh instance
     *
     * @example
     *     myInstance.refresh();
     *
     * @type {() => void}
     */
    refresh() {
      if (!mq[this.#queryType](this.#breakpoint)) {
        this.#removeScrolerStyle();
        this.#motion?.stop?.();
        modules_exports.useFrame(() => {
          modules_exports.useNextTick(() => {
            this.#scroller.style.transform = "";
          });
        });
        return;
      }
      this.#refreshScroller();
      this.#setScrolerStyle();
      modules_exports.useFrameIndex(() => {
        modules_exports.useNextTick(() => {
          this.#onAfterRefresh?.({
            shouldScroll: this.#getScrollableStatus()
          });
          this.#children.forEach((element) => {
            element.refresh();
          });
        });
      }, 2);
    }
    /**
     * Destroy instance
     *
     * @example
     *     myInstance.destroy();
     *
     * @type {() => void}
     */
    destroy() {
      this.#isDestroyed = true;
      this.#removeScrolerStyle();
      this.#subscribeResize();
      this.#subscribeScrollStart();
      this.#subscribeScrollEnd();
      this.#subscribeTouchStart();
      this.#subscribeTouchEnd();
      this.#subscribeMouseDown();
      this.#subscribeMouseUp();
      this.#subscribeMouseWheel();
      this.#subscribeMouseMove();
      this.#subscribeTouchMove();
      this.#subscribeMouseClick();
      this.#subscribeMotion();
      this.#subscribeOnComplete();
      this.#subscribeDebuoceWhell();
      this.#motion?.destroy();
      this.#motion = null;
      this.#children.forEach((element) => {
        element?.destroy?.();
      });
      this.#children = [];
      this.#onTickCallback = NOOP;
      this.#onUpdateCallback = NOOP;
      this.#onAfterRefresh = NOOP;
      this.#afterInit = NOOP;
      if (this.#scopedEvent) {
        this.#scroller?.removeEventListener(
          "wheel",
          this.#scopedWhell
        );
        this.#scroller?.removeEventListener(
          "mousemove",
          this.#scopedTouchMove
        );
        this.#scroller?.removeEventListener(
          "touchmove",
          this.#scopedTouchMove
        );
      }
      modules_exports.useFrameIndex(() => {
        modules_exports.useNextTick(() => {
          this.#scroller = null;
          this.#screen = null;
        });
      }, 3);
    }
  };

  // src/js/utils/page-scroll.js
  var shouldFreezePageScroll = false;
  var routeShoulNotUsePageScroll = /* @__PURE__ */ new Set([
    "scrollerN0",
    "scrollerN1",
    "horizontalScroller"
  ]);
  var usePageScroll = () => {
    const rootElement = (
      /** @type {HTMLElement} */
      document.querySelector("#root")
    );
    if (!rootElement) return;
    InitMobPageScroll({ rootElement });
    modules_exports2.mainStore.watch("beforeRouteChange", () => {
      FreezeMobPageScroll();
      enebalePreventScroll();
    });
    modules_exports2.mainStore.watch("afterRouteChange", () => {
      const currentRoute = modules_exports2.getActiveRoute()?.route;
      shouldFreezePageScroll = routeShoulNotUsePageScroll.has(currentRoute);
      modules_exports.useFrameIndex(() => {
        if (shouldFreezePageScroll) {
          DestroyMobPageScroll();
          return;
        }
        const shouldInizialize = !getActiveStateScroll();
        if (shouldInizialize) InitMobPageScroll({ rootElement });
        UnFreezeAndUPdateMobPageScroll();
      }, 30);
    });
  };

  // src/js/utils/utils.js
  function detectSafari() {
    const userAgentString = navigator.userAgent;
    let safariAgent = userAgentString.includes("Safari");
    const chromeAgent = userAgentString.includes("Chrome");
    if (chromeAgent && safariAgent) safariAgent = false;
    return safariAgent;
  }
  function detectFirefox() {
    const userAgentString = navigator.userAgent;
    let firefixAgent = userAgentString.includes("Firefox");
    const chromeAgent = userAgentString.includes("Chrome");
    if (chromeAgent && firefixAgent) firefixAgent = false;
    return firefixAgent;
  }
  function setBrowserClass() {
    const userAgent = navigator.userAgent;
    const body = document.body;
    if (/chrome|chromium|crios/i.test(userAgent)) {
      body.classList.add("is-chrome");
      return;
    }
    if (/firefox|fxios/i.test(userAgent)) {
      body.classList.add("is-firefox");
      return;
    }
    if (/safari/i.test(userAgent)) {
      body.classList.add("is-safari");
      return;
    }
    if (/edg/i.test(userAgent)) {
      body.classList.add("is-edge");
      return;
    }
  }
  var loadTextContent = async ({ source }) => {
    const response = await fetch(source);
    if (!response.ok) {
      console.warn(`${source} not found`);
      return {
        success: false,
        data: ""
      };
    }
    const data = await response.text();
    return {
      success: true,
      data
    };
  };
  var loadJsonContent = async ({ source }) => {
    const response = await fetch(source);
    if (!response.ok) {
      console.warn(`${source} not found`);
      return {
        success: false,
        data: ""
      };
    }
    const data = await response.json();
    return {
      success: true,
      data
    };
  };
  function randomIntFromInterval(min2, max2) {
    return Math.floor(Math.random() * (max2 - min2 + 1) + min2);
  }
  var serializeFragment = (fragment) => {
    const rawString = new XMLSerializer().serializeToString(fragment);
    return rawString.replaceAll(' xmlns="http://www.w3.org/1999/xhtml"', "");
  };

  // src/js/data/index.js
  var commonData;
  var getCommonData = () => commonData;
  var loadData = async () => {
    commonData = await fetch(`./data/common.json`).then((response) => response.json()).then((data) => data).catch((error) => console.warn("Something went wrong.", error));
  };

  // src/js/page-transition/index.js
  var scrollY = 0;
  modules_exports2.beforeRouteChange(() => {
    scrollY = window.scrollY;
  });
  var beforePageTransition2 = async ({ oldNode }) => {
    oldNode.classList.remove("current-route");
    oldNode.classList.add("fake-content");
    oldNode.style.position = "fixed";
    oldNode.style.zIndex = "10";
    oldNode.style.top = "var(--header-height)";
    oldNode.style.left = "0";
    oldNode.style.width = "100vw";
    oldNode.style.transform = `translate(calc(var(--header-height) / 2), -${scrollY}px)`;
    oldNode.style.minHeight = "calc(100vh - var(--header-height) - var(--footer-height))";
  };
  var pageTransition2 = async ({
    oldNode,
    newNode,
    oldRoute,
    newRoute
  }) => {
    if (core_exports.mq("max", "desktop") || oldRoute === newRoute) return;
    newNode.style.opacity = "0";
    const oldNodeTween = tween_exports.createTimeTween({
      data: { opacity: 1 },
      duration: 300
    });
    const newNodeTween = tween_exports.createTimeTween({
      data: { opacity: 0 },
      duration: 500
    });
    oldNodeTween.subscribe(({ opacity }) => {
      oldNode.style.opacity = opacity;
    });
    newNodeTween.subscribe(({ opacity }) => {
      newNode.style.opacity = opacity;
    });
    let tl = timeline_exports.createAsyncTimeline({ repeat: 1 }).createGroup({ waitComplete: true }).goTo(oldNodeTween, { opacity: 0 }).goTo(newNodeTween, { opacity: 1 }).closeGroup();
    await tl.play();
    tl.destroy();
    tl = null;
    newNode.style.removeProperty("opacity");
    newNode.classList.add("current-route");
  };

  // src/js/pages/404/index.js
  var pageNotFound2 = () => {
    return renderHtml`
        <div class="error-page">
            <div class="error-page__content">
                <h1 class="error-page__title title-big">Page not found</h1>
                <a class="error-page__link" href="./#home">back to home</a>
            </div>
        </div>
    `;
  };

  // src/js/component/pages/layout-links/animation/links-scroller.js
  var linksScroller = ({
    screenElement,
    scrollerElement,
    hideControls
  }) => {
    const scroller = new MobSmoothScroller({
      screen: screenElement,
      scroller: scrollerElement,
      direction: "horizontal",
      drag: true,
      easeType: "lerp",
      breakpoint: "small",
      afterInit: ({ shouldScroll }) => {
        hideControls(shouldScroll);
      },
      afterRefresh: ({ shouldScroll }) => {
        hideControls(shouldScroll);
      }
    });
    scroller.init();
    return {
      destroy: () => {
        scroller.destroy();
      }
    };
  };

  // src/js/component/pages/layout-links/layout-links.js
  var getCounter = (index) => index < 10 ? `0${index}` : `${index}`;
  var LayoutLinksFn = ({
    setRef,
    getRef,
    onMount,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    onMount(() => {
      const { screenElement, scrollerElement } = getRef();
      const { destroy: destroy3 } = linksScroller({
        screenElement,
        scrollerElement,
        hideControls: (value) => {
          proxi.showControls = value;
        }
      });
      setTimeout(() => {
        proxi.isMounted = true;
      }, 500);
      return () => {
        destroy3();
      };
    });
    return renderHtml`<div class="l-links">
        <div
            class="l-links__under is-white"
            ${bindEffect({
      toggleClass: {
        "is-visible": () => proxi.isMounted
      }
    })}
        >
            ${proxi.title}
        </div>
        <div class="l-links__grid">
            <div class="l-links__row l-links__row" ${setRef("screenElement")}>
                <div class="l-links__row__white">
                    <h6 class="l-links__over is-black">${proxi.title}</h6>
                </div>
                <div class="l-links__title">
                    <h1 class="title-big">${proxi.title}</h1>
                </div>
                <div
                    class="l-links__scroller"
                    ${setRef("scrollerElement")}
                    ${bindEffect({
      toggleClass: {
        "use-drag-cursor": () => proxi.showControls
      }
    })}
                >
                    <ul class="l-links__list">
                        ${proxi.items.map((item, index) => {
      return (
        /* HTML */
        `
                                    <li class="l-links__list__item">
                                        <a
                                            class="l-links__list__link"
                                            href="${item.url}"
                                        >
                                            <span class="l-links__list__counter"
                                                >${getCounter(index)}</span
                                            >
                                            <span>${item.title}</span>
                                        </a>
                                    </li>
                                `
      );
    }).join("")}
                    </ul>
                </div>
            </div>
            <h6
                class="l-links__scroll"
                ${bindEffect({
      toggleClass: {
        active: () => proxi.showControls
      }
    })}
            >
                Scroll or drag
            </h6>
        </div>
    </div>`;
  };

  // src/js/component/pages/layout-links/definition.js
  var LayoutLinks = modules_exports2.createComponent(
    /** @type{CreateComponentParams<import ('./type').LayoutLinks>} */
    {
      tag: "layout-links",
      component: LayoutLinksFn,
      exportState: ["title", "items"],
      state: {
        title: () => ({
          value: "",
          type: String
        }),
        items: () => ({
          value: [],
          type: Array
        }),
        isMounted: () => ({
          value: false,
          type: Boolean
        }),
        showControls: () => ({
          value: false,
          type: Boolean
        })
      },
      child: []
    }
  );

  // src/js/pages/layout/layout-links.js
  modules_exports2.useComponent([LayoutLinks]);
  var layoutLinksPage = async ({ props }) => {
    const { source } = props;
    const { data } = await loadJsonContent({ source });
    return renderHtml` <div class="l-links">
        <layout-links
            ${modules_exports2.staticProps(
      /** @type {import('@pagesComponent/layout-links/type').LayoutLinks['state']} */
      {
        title: data.title,
        items: data.items
      }
    )}
        ></layout-links>
    </div>`;
  };

  // src/js/component/common/doc-container/doc-container.js
  var DocContainerFn = () => {
    return renderHtml`
        <div class="c-doc-container">
            <div class="c-doc-container__content">
                <mobjs-slot name="docs"></mobjs-slot>
            </div>
            <div class="c-doc-container__side">
                <mobjs-slot name="section-title-small"></mobjs-slot>
                <mobjs-slot name="section-title"></mobjs-slot>
                <mobjs-slot name="section-links"></mobjs-slot>
            </div>
        </div>
    `;
  };

  // src/js/component/common/doc-container/definition.js
  var DocContainer = modules_exports2.createComponent(
    /** @type {CreateComponentParams<any>} */
    {
      tag: "doc-container",
      component: DocContainerFn
    }
  );

  // src/js/component/common/doc-title/doc-side.js
  var DocTitleFn = () => {
    return renderHtml`
        <div class="c-doc-title">
            <h2><mobjs-slot></mobjs-slot></h2>
        </div>
    `;
  };

  // src/js/component/common/doc-title/definition.js
  var DocTitle = modules_exports2.createComponent(
    /** @type {CreateComponentParams<any>} */
    {
      tag: "doc-title",
      component: DocTitleFn,
      state: {}
    }
  );

  // src/js/component/common/doc-title-small/doc-title-small.js
  var DocTitleSmallFn = () => {
    return renderHtml`
        <div class="c-doc-title-small">
            <mobjs-slot></mobjs-slot>
        </div>
    `;
  };

  // src/js/component/common/doc-title-small/definition.js
  var DocsTitleSmall = modules_exports2.createComponent(
    /** @type {CreateComponentParams<any>} */
    {
      tag: "doc-title-small",
      component: DocTitleSmallFn,
      state: {}
    }
  );

  // src/js/component/common/loader/loader.js
  var LoaderFn = ({ onMount, watch, remove: remove2, getState }) => {
    const { position: position2 } = getState();
    onMount(({ element }) => {
      let tweenOut = tween_exports.createTimeTween({
        data: { opacity: 1, scale: 1 },
        duration: 500
      });
      tweenOut.subscribe(({ opacity, scale }) => {
        element.style.opacity = opacity;
        element.style.transform = `scale(${scale})`;
      });
      watch("shouldRemove", async (shouldRemove) => {
        if (!shouldRemove) return;
        await tweenOut.goTo({ opacity: 0, scale: 0.9 });
        remove2();
      });
      return () => {
        tweenOut.destroy();
        tweenOut = null;
      };
    });
    return renderHtml`
        <div class="c-loader ${position2}">
            <span class="c-loader__inner"></span>
        </div>
    `;
  };

  // src/js/component/common/loader/definition.js
  var Loader = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').Loader>} */
    {
      tag: "mob-loader",
      component: LoaderFn,
      exportState: ["position", "shouldRemove"],
      state: {
        shouldRemove: () => ({
          value: false,
          type: Boolean
        }),
        position: () => ({
          value: "center-viewport",
          type: String,
          validate: (val2) => {
            return ["center-viewport", "center-component"].includes(
              val2
            );
          }
        })
      }
    }
  );

  // node_modules/highlight.js/es/core.js
  var import_core2 = __toESM(require_core(), 1);
  var core_default = import_core2.default;

  // node_modules/highlight.js/es/languages/javascript.js
  var IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
  var KEYWORDS = [
    "as",
    // for exports
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    // JS handles these with a special rule
    // "get",
    // "set",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends",
    // It's reached stage 3, which is "recommended for implementation":
    "using"
  ];
  var LITERALS = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ];
  var TYPES = [
    // Fundamental objects
    "Object",
    "Function",
    "Boolean",
    "Symbol",
    // numbers and dates
    "Math",
    "Date",
    "Number",
    "BigInt",
    // text
    "String",
    "RegExp",
    // Indexed collections
    "Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Int32Array",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array",
    // Keyed collections
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    // Structured data
    "ArrayBuffer",
    "SharedArrayBuffer",
    "Atomics",
    "DataView",
    "JSON",
    // Control abstraction objects
    "Promise",
    "Generator",
    "GeneratorFunction",
    "AsyncFunction",
    // Reflection
    "Reflect",
    "Proxy",
    // Internationalization
    "Intl",
    // WebAssembly
    "WebAssembly"
  ];
  var ERROR_TYPES = [
    "Error",
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ];
  var BUILT_IN_GLOBALS = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ];
  var BUILT_IN_VARIABLES = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "sessionStorage",
    "module",
    "global"
    // Node.js
  ];
  var BUILT_INS = [].concat(
    BUILT_IN_GLOBALS,
    TYPES,
    ERROR_TYPES
  );
  function javascript(hljs) {
    const regex = hljs.regex;
    const hasClosingTag = (match, { after }) => {
      const tag = "</" + match[0].slice(1);
      const pos = match.input.indexOf(tag, after);
      return pos !== -1;
    };
    const IDENT_RE$1 = IDENT_RE;
    const FRAGMENT = {
      begin: "<>",
      end: "</>"
    };
    const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
    const XML_TAG = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      /**
       * @param {RegExpMatchArray} match
       * @param {CallbackResponse} response
       */
      isTrulyOpeningTag: (match, response) => {
        const afterMatchIndex = match[0].length + match.index;
        const nextChar = match.input[afterMatchIndex];
        if (
          // HTML should not include another raw `<` inside a tag
          // nested type?
          // `<Array<Array<number>>`, etc.
          nextChar === "<" || // the , gives away that this is not HTML
          // `<T, A extends keyof T, V>`
          nextChar === ","
        ) {
          response.ignoreMatch();
          return;
        }
        if (nextChar === ">") {
          if (!hasClosingTag(match, { after: afterMatchIndex })) {
            response.ignoreMatch();
          }
        }
        let m;
        const afterMatch = match.input.substring(afterMatchIndex);
        if (m = afterMatch.match(/^\s*=/)) {
          response.ignoreMatch();
          return;
        }
        if (m = afterMatch.match(/^\s+extends\s+/)) {
          if (m.index === 0) {
            response.ignoreMatch();
            return;
          }
        }
      }
    };
    const KEYWORDS$1 = {
      $pattern: IDENT_RE,
      keyword: KEYWORDS,
      literal: LITERALS,
      built_in: BUILT_INS,
      "variable.language": BUILT_IN_VARIABLES
    };
    const decimalDigits = "[0-9](_?[0-9])*";
    const frac = `\\.(${decimalDigits})`;
    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
    const NUMBER2 = {
      className: "number",
      variants: [
        // DecimalLiteral
        { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
        { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
        // DecimalBigIntegerLiteral
        { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
        // NonDecimalIntegerLiteral
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        // LegacyOctalIntegerLiteral (does not include underscore separators)
        // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
        { begin: "\\b0[0-7]+n?\\b" }
      ],
      relevance: 0
    };
    const SUBST = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: KEYWORDS$1,
      contains: []
      // defined later
    };
    const HTML_TEMPLATE = {
      begin: ".?html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "xml"
      }
    };
    const CSS_TEMPLATE = {
      begin: ".?css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "css"
      }
    };
    const GRAPHQL_TEMPLATE = {
      begin: ".?gql`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "graphql"
      }
    };
    const TEMPLATE_STRING = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ]
    };
    const JSDOC_COMMENT = hljs.COMMENT(
      /\/\*\*(?!\/)/,
      "\\*/",
      {
        relevance: 0,
        contains: [
          {
            begin: "(?=@[A-Za-z]+)",
            relevance: 0,
            contains: [
              {
                className: "doctag",
                begin: "@[A-Za-z]+"
              },
              {
                className: "type",
                begin: "\\{",
                end: "\\}",
                excludeEnd: true,
                excludeBegin: true,
                relevance: 0
              },
              {
                className: "variable",
                begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
                endsParent: true,
                relevance: 0
              },
              // eat spaces (not newlines) so we can find
              // types or variables
              {
                begin: /(?=[^\n])\s/,
                relevance: 0
              }
            ]
          }
        ]
      }
    );
    const COMMENT = {
      className: "comment",
      variants: [
        JSDOC_COMMENT,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.C_LINE_COMMENT_MODE
      ]
    };
    const SUBST_INTERNALS = [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      NUMBER2
      // This is intentional:
      // See https://github.com/highlightjs/highlight.js/issues/3288
      // hljs.REGEXP_MODE
    ];
    SUBST.contains = SUBST_INTERNALS.concat({
      // we need to pair up {} inside our subst to prevent
      // it from ending too early by matching another }
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS$1,
      contains: [
        "self"
      ].concat(SUBST_INTERNALS)
    });
    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
      // eat recursive parens in sub expressions
      {
        begin: /(\s*)\(/,
        end: /\)/,
        keywords: KEYWORDS$1,
        contains: ["self"].concat(SUBST_AND_COMMENTS)
      }
    ]);
    const PARAMS = {
      className: "params",
      // convert this to negative lookbehind in v12
      begin: /(\s*)\(/,
      // to match the parms with
      end: /\)/,
      excludeBegin: true,
      excludeEnd: true,
      keywords: KEYWORDS$1,
      contains: PARAMS_CONTAINS
    };
    const CLASS_OR_EXTENDS = {
      variants: [
        // class Car extends vehicle
        {
          match: [
            /class/,
            /\s+/,
            IDENT_RE$1,
            /\s+/,
            /extends/,
            /\s+/,
            regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
          ],
          scope: {
            1: "keyword",
            3: "title.class",
            5: "keyword",
            7: "title.class.inherited"
          }
        },
        // class Car
        {
          match: [
            /class/,
            /\s+/,
            IDENT_RE$1
          ],
          scope: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    };
    const CLASS_REFERENCE = {
      relevance: 0,
      match: regex.either(
        // Hard coded exceptions
        /\bJSON/,
        // Float32Array, OutT
        /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
        // CSSFactory, CSSFactoryT
        /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
        // FPs, FPsT
        /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
        // P
        // single letters are not highlighted
        // BLAH
        // this will be flagged as a UPPER_CASE_CONSTANT instead
      ),
      className: "title.class",
      keywords: {
        _: [
          // se we still get relevance credit for JS library classes
          ...TYPES,
          ...ERROR_TYPES
        ]
      }
    };
    const USE_STRICT = {
      label: "use_strict",
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    };
    const FUNCTION_DEFINITION = {
      variants: [
        {
          match: [
            /function/,
            /\s+/,
            IDENT_RE$1,
            /(?=\s*\()/
          ]
        },
        // anonymous function
        {
          match: [
            /function/,
            /\s*(?=\()/
          ]
        }
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      label: "func.def",
      contains: [PARAMS],
      illegal: /%/
    };
    const UPPER_CASE_CONSTANT = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    };
    function noneOf(list) {
      return regex.concat("(?!", list.join("|"), ")");
    }
    const FUNCTION_CALL = {
      match: regex.concat(
        /\b/,
        noneOf([
          ...BUILT_IN_GLOBALS,
          "super",
          "import"
        ].map((x) => `${x}\\s*\\(`)),
        IDENT_RE$1,
        regex.lookahead(/\s*\(/)
      ),
      className: "title.function",
      relevance: 0
    };
    const PROPERTY_ACCESS = {
      begin: regex.concat(/\./, regex.lookahead(
        regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)
      )),
      end: IDENT_RE$1,
      excludeBegin: true,
      keywords: "prototype",
      className: "property",
      relevance: 0
    };
    const GETTER_OR_SETTER = {
      match: [
        /get|set/,
        /\s+/,
        IDENT_RE$1,
        /(?=\()/
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        {
          // eat to avoid empty params
          begin: /\(\)/
        },
        PARAMS
      ]
    };
    const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
    const FUNCTION_VARIABLE = {
      match: [
        /const|var|let/,
        /\s+/,
        IDENT_RE$1,
        /\s*/,
        /=\s*/,
        /(async\s*)?/,
        // async is optional
        regex.lookahead(FUNC_LEAD_IN_RE)
      ],
      keywords: "async",
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        PARAMS
      ]
    };
    return {
      name: "JavaScript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: KEYWORDS$1,
      // this will be extended by TypeScript
      exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
      illegal: /#(?![$_A-z])/,
      contains: [
        hljs.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        USE_STRICT,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        GRAPHQL_TEMPLATE,
        TEMPLATE_STRING,
        COMMENT,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        NUMBER2,
        CLASS_REFERENCE,
        {
          scope: "attr",
          match: IDENT_RE$1 + regex.lookahead(":"),
          relevance: 0
        },
        FUNCTION_VARIABLE,
        {
          // "value" container
          begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
          keywords: "return throw case",
          relevance: 0,
          contains: [
            COMMENT,
            hljs.REGEXP_MODE,
            {
              className: "function",
              // we have to count the parens to make sure we actually have the
              // correct bounding ( ) before the =>.  There could be any number of
              // sub-expressions inside also surrounded by parens.
              begin: FUNC_LEAD_IN_RE,
              returnBegin: true,
              end: "\\s*=>",
              contains: [
                {
                  className: "params",
                  variants: [
                    {
                      begin: hljs.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: true
                    },
                    {
                      begin: /(\s*)\(/,
                      end: /\)/,
                      excludeBegin: true,
                      excludeEnd: true,
                      keywords: KEYWORDS$1,
                      contains: PARAMS_CONTAINS
                    }
                  ]
                }
              ]
            },
            {
              // could be a comma delimited list of params to a function call
              begin: /,/,
              relevance: 0
            },
            {
              match: /\s+/,
              relevance: 0
            },
            {
              // JSX
              variants: [
                { begin: FRAGMENT.begin, end: FRAGMENT.end },
                { match: XML_SELF_CLOSING },
                {
                  begin: XML_TAG.begin,
                  // we carefully check the opening tag to see if it truly
                  // is a tag and not a false positive
                  "on:begin": XML_TAG.isTrulyOpeningTag,
                  end: XML_TAG.end
                }
              ],
              subLanguage: "xml",
              contains: [
                {
                  begin: XML_TAG.begin,
                  end: XML_TAG.end,
                  skip: true,
                  contains: ["self"]
                }
              ]
            }
          ]
        },
        FUNCTION_DEFINITION,
        {
          // prevent this from getting swallowed up by function
          // since they appear "function like"
          beginKeywords: "while if switch catch for"
        },
        {
          // we have to count the parens to make sure we actually have the correct
          // bounding ( ).  There could be any number of sub-expressions inside
          // also surrounded by parens.
          begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
          // end parens
          returnBegin: true,
          label: "func.def",
          contains: [
            PARAMS,
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })
          ]
        },
        // catch ... so it won't trigger the property rule below
        {
          match: /\.\.\./,
          relevance: 0
        },
        PROPERTY_ACCESS,
        // hack: prevents detection of keywords in some circumstances
        // .keyword()
        // $keyword = x
        {
          match: "\\$" + IDENT_RE$1,
          relevance: 0
        },
        {
          match: [/\bconstructor(?=\s*\()/],
          className: { 1: "title.function" },
          contains: [PARAMS]
        },
        FUNCTION_CALL,
        UPPER_CASE_CONSTANT,
        CLASS_OR_EXTENDS,
        GETTER_OR_SETTER,
        {
          match: /\$[(.]/
          // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
        }
      ]
    };
  }

  // src/js/component/common/snippet/snippet.js
  core_default.registerLanguage("javascript", javascript);
  var loadSnippet = async ({ ref, source }) => {
    if (!ref) return;
    const { success, data } = await loadTextContent({ source });
    if (!success) {
      ref.textContent = `something went wrong`;
      return;
    }
    ref.textContent = data;
    core_default.highlightElement(ref);
    ref.style.height = "";
  };
  var getLineHeight = () => {
    return getComputedStyle(document.documentElement).getPropertyValue(
      "--snippet-line-height-value"
    );
  };
  var SnippetFn = ({
    onMount,
    setRef,
    getRef,
    delegateEvents,
    bindEffect,
    getProxi,
    bindObject
  }) => {
    const proxi = getProxi();
    const lineHeight = getLineHeight();
    const closedHeight = `20rem`;
    const useExpand = Number(proxi.numLines) > 15;
    const expandClass = useExpand ? "use-expand" : "";
    const snippetHeight = `${proxi.numLines * Number(lineHeight)}rem`;
    onMount(async () => {
      const { codeEl } = getRef();
      if (proxi.awaitLoad) {
        await loadSnippet({ ref: codeEl, source: proxi.source });
      } else {
        loadSnippet({ ref: codeEl, source: proxi.source });
      }
      return () => {
      };
    });
    return renderHtml`<div
        class="snippet"
        style="--snippet-height:${snippetHeight};--closed-height:${closedHeight}"
    >
        <code
            ${bindEffect({
      toggleClass: {
        close: () => useExpand && !proxi.isExpanded,
        open: () => useExpand && proxi.isExpanded
      }
    })}
        >
            <pre
                ${setRef("codeEl")}
                style="height:${useExpand ? closedHeight : snippetHeight}"
            >
                 Loading snippet ...</pre
            >
        </code>
        <button
            class="snippet__expand ${expandClass}"
            ${!useExpand && "disabled"}
            ${delegateEvents({
      click: () => {
        proxi.isExpanded = !proxi.isExpanded;
      }
    })}
        >
            ${bindObject`${() => proxi.isExpanded ? "close" : "expand"}`}
        </button>
    </div>`;
  };

  // src/js/component/common/snippet/definition.js
  var Snippet = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').Snippet>} */
    {
      tag: "mob-snippet",
      component: SnippetFn,
      exportState: ["source", "numLines", "awaitLoad"],
      state: {
        source: () => ({
          value: "",
          type: String
        }),
        contentIsLoaded: () => ({
          value: false,
          type: Boolean
        }),
        numLines: () => ({
          value: 1,
          type: Number
        }),
        awaitLoad: () => ({
          value: false,
          type: Boolean
        }),
        isExpanded: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/instance-name.js
  var debugComponentName = "debug_component";
  var debugFilterListName = "debug_filter_list";
  var debugOverlayName = "debug_overlay";
  var debugTreeName = "debug_tree";
  var quickNavName = "quick_nav";
  var scrollDownLabelName = "scroll_down_label";
  var scrollToName = "scroll_to";
  var headerName = "header";
  var mobNavigationName = "mob_navigation";
  var mobNavigationContainerName = "mob_navigation_container";
  var searchOverlay = "search_overlay";
  var searchOverlayList = "search_overlay_list";
  var searchOverlayHeader = "search_overlay_header";

  // src/js/component/common/spacer-anchor/spacer-anchor.js
  function hasAnchor({ label }) {
    return label?.length > 0;
  }
  var addItemToScrollComponent = async ({
    id,
    label,
    element,
    isSection,
    isNote
  }) => {
    await modules_exports2.tick();
    const methods = modules_exports2.useMethodByName(scrollToName);
    methods?.addItem?.({ id, label, element, isSection, isNote });
    if (isVisibleInViewportSmart(element) && !isSection) {
      methods?.setActiveLabel?.(label);
    }
  };
  var SpacerAnchorFn = ({ getState, onMount }) => {
    const { style, line, id, label, isSection, isNote } = getState();
    const lineClass = line ? "spacer--line" : "";
    onMount(({ element }) => {
      const shouldAddToAnchor = hasAnchor({ label });
      if (!shouldAddToAnchor) return;
      addItemToScrollComponent({ id, label, element, isSection, isNote });
    });
    return renderHtml`<div id="${id}" class="spacer spacer--${style} ${lineClass}">
        <span></span>
    </div>`;
  };

  // src/js/component/common/spacer-anchor/definition.js
  var SpacerAnchor = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').SpacerAnchor>} */
    {
      tag: "mob-spacer",
      component: SpacerAnchorFn,
      exportState: ["style", "line", "id", "label", "isSection", "isNote"],
      state: {
        style: () => ({
          value: "x-small",
          type: String,
          validate: (val2) => ["x-small", "small", "medium", "big"].includes(val2),
          strict: true
        }),
        line: () => ({
          value: false,
          type: Boolean
        }),
        id: () => ({
          value: "",
          type: String
        }),
        label: () => ({
          value: "",
          type: String
        }),
        isSection: () => ({
          value: false,
          type: Boolean
        }),
        isNote: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/common/typography/anchor-button/anchor-button.js
  var AnchorButtonFn = ({ getState, delegateEvents }) => {
    const { content, anchor } = getState();
    return renderHtml`<div>
        <button
            type="button"
            class="anchor-button"
            ${delegateEvents({
      click: () => {
        const target = document.querySelector(anchor);
        if (!target) return;
        const offsetTop = offset(target).top - 50;
        MobBodyScroll.to(offsetTop);
      }
    })}
        >
            ${content}
            <span class="anchor-button__arrow">
                <span class="anchor-button__arrow__start"></span>
                <span class="anchor-button__arrow__end"></span>
            </span>
        </button>
    </div>`;
  };

  // src/js/component/common/typography/anchor-button/definition.js
  var AnchorButton = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').AnchorBUtton>} */
    {
      tag: "anchor-button",
      component: AnchorButtonFn,
      exportState: ["anchor", "content"],
      state: {
        anchor: () => ({
          value: "",
          type: String
        }),
        content: () => ({
          value: "",
          type: String
        })
      }
    }
  );

  // src/js/component/common/typography/list/list.js
  var getList = ({ items, links }) => {
    return links ? (
      /** @type{Record<'label' | 'url', string>[]} */
      items.map(
        ({ label, url }) => renderHtml`<li>
                          <a href="${url}" class="list-links">
                              ${label}
                              <span class="list-links__arrow">
                                  <span class="list-links__arrow__start"></span>
                                  <span class="list-links__arrow__end"></span>
                              </span>
                          </a>
                      </li>`
      ).join("")
    ) : items.map((item) => renderHtml` <li>${item}</li> `).join("");
  };
  var ListFn = ({ getState }) => {
    const { style, color, items, links } = getState();
    const colorClass = `is-${color}`;
    const linksClass = links ? "use-links" : "use-default";
    return renderHtml`<ul class="ul ul--${style} ${colorClass} ${linksClass}">
        ${getList({ items, links })}
    </ul>`;
  };

  // src/js/component/common/typography/list/definition.js
  var List = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').List>} */
    {
      tag: "mob-list",
      component: ListFn,
      exportState: ["style", "color", "items", "dots", "block", "links"],
      state: {
        style: () => ({
          value: "medium",
          type: String,
          validate: (val2) => ["small", "medium", "big"].includes(val2),
          strict: true
        }),
        dots: () => ({
          value: true,
          type: Boolean
        }),
        links: () => ({
          value: false,
          type: Boolean
        }),
        color: () => ({
          value: "black",
          type: String,
          validate: (val2) => {
            return ["white", "black", "grey", "hightlight"].includes(
              val2
            );
          }
        }),
        items: () => ({
          value: [],
          type: Array
        })
      }
    }
  );

  // src/js/component/common/typography/paragraph/paragraph.js
  var ParagraphFn = ({ getState }) => {
    const { style, color, boxed, note } = getState();
    const colorClass = color === "inherit" ? "" : `is-${color}`;
    const boxedClass = boxed ? `p--boxed` : "";
    const noteClass = note ? `p--note` : "";
    return renderHtml`<p
        class="p p--${style} ${boxedClass} ${noteClass} ${colorClass}"
    >
        <mobjs-slot></mobjs-slot>
    </p>`;
  };

  // src/js/component/common/typography/paragraph/definition.js
  var Paragraph = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').Paragraph>} */
    {
      tag: "mob-paragraph",
      component: ParagraphFn,
      exportState: ["style", "color", "boxed", "note"],
      state: {
        style: () => ({
          value: "medium",
          type: String,
          validate: (val2) => ["small", "medium", "big"].includes(val2),
          strict: true
        }),
        color: () => ({
          value: "inherit",
          type: String,
          validate: (val2) => {
            return ["inherit", "white", "hightlight", "black"].includes(
              val2
            );
          }
        }),
        boxed: () => ({
          value: false,
          type: Boolean
        }),
        note: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/lib/utils/get-triangle.js
  var getTrinangle = (className = "", useTriangle = true) => {
    if (!useTriangle) return "";
    return renderHtml`
        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <svg
            width="685.75171"
            height="641.88232"
            viewBox="0 0 181.43847 169.83136"
            version="1.1"
            id="svg5"
            xmlns="http://www.w3.org/2000/svg"
            xmlns:svg="http://www.w3.org/2000/svg"
            class="${className}"
        >
            <g id="layer1" transform="translate(0.29348888,0.2718794)">
                <path
                    id="path1107"
                    transform="matrix(-0.26371722,0.02139075,-0.02139075,-0.26371722,201.63975,129.69612)"
                    d="M 719.78423,551.21438 37.632123,494.16328 772.89469,-88.468152 Z"
                />
            </g>
        </svg>
    `;
  };

  // src/js/component/common/typography/titles/title.js
  var shouldUseTrinagle = (tag) => {
    return tag === `h1` ? getTrinangle() : "";
  };
  var getIndex2 = (index) => {
    return index.length > 0 ? renderHtml`<span class="title-index">${index}</span>` : ``;
  };
  var TitleFn = ({ getProxi }) => {
    const proxi = getProxi();
    const colorClass = proxi.color === "inherit" ? "" : `is-${proxi.color}`;
    const boldClass = proxi.isBold ? `is-bold` : "";
    const isSectionClass = proxi.isSection ? `is-section` : "";
    return renderHtml`<${proxi.tag} class="${colorClass} ${boldClass} ${isSectionClass}">
            ${getIndex2(proxi.index)}
            <span class="triangle-left">${shouldUseTrinagle(proxi.tag)}</span>
            <span class="triangle-right">${shouldUseTrinagle(proxi.tag)}</span>
            <span class="title-content">
                <mobjs-slot></mobjs-slot>
            </span>
        </${proxi.tag}>`;
  };

  // src/js/stores/navigation/index.js
  var navigationStore = modules_exports.createStore(
    /** @type {MobStoreParams<import('./type').NavigationStore>} */
    {
      activeNavigationSection: () => ({
        value: "",
        type: String,
        skipEqual: false
      }),
      navigationIsOpen: () => ({
        value: false,
        type: Boolean
      })
    }
  );
  navigationStore.set("activeNavigationSection", "");

  // src/js/component/common/typography/titles/definition.js
  var Title = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').Title>} */
    {
      tag: "mob-title",
      component: TitleFn,
      exportState: [
        "useSticky",
        "index",
        "isSection",
        "tag",
        "color",
        "isBold"
      ],
      bindStore: navigationStore,
      state: {
        tag: () => ({
          value: "h1",
          type: String
        }),
        color: () => ({
          value: "inherit",
          type: String,
          validate: (val2) => {
            return ["inherit", "white", "hightlight", "black"].includes(
              val2
            );
          }
        }),
        isSection: () => ({
          value: false,
          type: Boolean
        }),
        isBold: () => ({
          value: false,
          type: Boolean
        }),
        index: () => ({
          value: "",
          type: String
        })
      }
    }
  );

  // src/js/component/common/html-content/html-content.js
  var getComponents = ({ data, staticProps: staticProps2, awaitLoadSnippet }) => {
    return data.map((item) => {
      const { component, props, content } = item;
      return renderHtml`
                <${component} ${staticProps2({ ...props, awaitLoad: awaitLoadSnippet })}>
                    ${content ?? ""}
                </${component}>
            `;
    }).join("");
  };
  var getData2 = async ({ source, data }) => {
    if (data && data.length > 0) return data;
    const { success, data: currentData } = await loadJsonContent({ source });
    if (!success) return [];
    return currentData.data;
  };
  var getLoader = ({ data, bindProps }) => {
    if (data && data.length > 0) return "";
    return renderHtml`
        <mob-loader
            ${bindProps({
      observe: ["contentIsLoaded"],
      props: ({ contentIsLoaded }) => {
        return { shouldRemove: contentIsLoaded };
      }
    })}
        ></mob-loader>
    `;
  };
  var HtmlContentFn = async ({
    getState,
    setState,
    staticProps: staticProps2,
    bindProps,
    onMount
  }) => {
    const { source, data } = getState();
    const currentData = await getData2({ source, data });
    const { awaitLoadSnippet, useTriangle, usePadding } = getState();
    const usePaddingClass = usePadding ? "use-padding" : "";
    onMount(async () => {
      setState("contentIsLoaded", true);
      return () => {
      };
    });
    return renderHtml`
        <section class="html-content ${usePaddingClass}">
            <div>${getTrinangle("html-content__triangle", useTriangle)}</div>
            ${getLoader({ data, bindProps })}
            ${getComponents({
      data: currentData,
      staticProps: staticProps2,
      awaitLoadSnippet
    })}
        </section>
    `;
  };

  // src/js/component/common/doc-svg/doc-svg.js
  var loadSvg = async ({ proxi }) => {
    const { success, data } = await loadTextContent({ source: proxi.url });
    if (!success) {
      return;
    }
    proxi.source = data;
  };
  var DocSvgFn = ({ getProxi, invalidate, onMount }) => {
    const proxi = getProxi();
    onMount(() => {
      loadSvg({ proxi });
    });
    return renderHtml`
        <div class="c-doc-svg ${proxi.className}">
            ${invalidate({
      observe: () => proxi.source,
      render: () => proxi.source
    })}
        </div>
    `;
  };

  // src/js/component/common/doc-svg/definition.js
  var DocSvg = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DocSvg>} */
    {
      tag: "doc-svg",
      component: DocSvgFn,
      exportState: ["url", "className"],
      state: {
        source: () => ({
          value: renderHtml`<span class="c-doc-svg__loading">
                    loading image ...
                </span>`,
          type: String
        }),
        className: () => ({
          value: "",
          type: String
        }),
        url: () => ({
          value: "",
          type: String
        })
      }
    }
  );

  // src/js/component/common/html-content/definition.js
  var HtmlContent = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').HtmlContent>} */
    {
      tag: "html-content",
      component: HtmlContentFn,
      exportState: [
        "usePadding",
        "useTriangle",
        "source",
        "data",
        "awaitLoadSnippet"
      ],
      state: {
        source: () => ({
          value: "",
          type: String
        }),
        data: () => ({
          value: [],
          type: Array
        }),
        contentIsLoaded: () => ({
          value: false,
          type: Boolean
        }),
        awaitLoadSnippet: () => ({
          value: false,
          type: Boolean
        }),
        useTriangle: () => ({
          value: true,
          type: Boolean
        }),
        usePadding: () => ({
          value: true,
          type: Boolean
        })
      },
      child: [
        List,
        Paragraph,
        Title,
        Loader,
        Snippet,
        SpacerAnchor,
        AnchorButton,
        DocSvg
      ]
    }
  );

  // src/js/component/common/scroll-to/button/scroll-to-button.js
  var ScrollToButtonFn = ({ bindEffect, getProxi }) => {
    const proxi = getProxi();
    const isSectionClass = proxi.isSection ? "is-section" : "";
    const isNoteClass = proxi.isNote ? "is-note" : "";
    return renderHtml`
        <button
            type="button"
            class="${isSectionClass} ${isNoteClass}"
            ${bindEffect({
      toggleClass: { active: () => proxi.active }
    })}
        >
            <span>${proxi.label}</span>
        </button>
    `;
  };

  // src/js/component/common/scroll-to/button/definition.js
  var ScrollToButton = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').ScrollToButton>} */
    {
      tag: "scroll-to-button",
      component: ScrollToButtonFn,
      exportState: ["label", "active", "isSection", "isNote"],
      state: {
        label: () => ({
          value: "",
          type: String
        }),
        active: () => ({
          value: false,
          type: Boolean
        }),
        isSection: () => ({
          value: false,
          type: Boolean
        }),
        isNote: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/common/scroll-to/scroll-to.js
  var disableObservereffect = false;
  function getButtons({ delegateEvents, bindProps, proxi }) {
    return proxi.anchorItems.map((item) => {
      const delegateEventsFn = item.isSection || item.isNote ? "" : delegateEvents({
        click: async () => {
          const { id: scroll, label, element } = item;
          const offsetTop = scroll === "start" ? 0 : offset(element).top - 50;
          disableObservereffect = true;
          proxi.activeLabel = label;
          await MobBodyScroll.to(offsetTop);
          setTimeout(() => {
            disableObservereffect = false;
          }, 1e3);
        }
      });
      return renderHtml`
                <li>
                    <scroll-to-button
                        ${delegateEventsFn}
                        ${bindProps(
        /** @returns {ReturnBindProps<ScrollToButton>} */
        () => ({
          active: proxi.activeLabel === item.label,
          label: item.label,
          isSection: item.isSection ?? false,
          isNote: item.isNote ?? false
        })
      )}
                    >
                    </scroll-to-button>
                </li>
            `;
    }).join("");
  }
  var setActiveLabelOnScroll = ({ proxi, direction: direction2, winHeight }) => {
    modules_exports.useFrame(() => {
      modules_exports.useNextTick(() => {
        if (direction2 === "DOWN") {
          const activeItem = proxi.anchorItems.findLast(
            ({ top, isNote }) => {
              return !isNote && top < window.scrollY + winHeight - 200;
            }
          );
          proxi.activeLabel = activeItem ? activeItem.label : "";
        }
        if (direction2 === "UP") {
          const activeItem = proxi.anchorItems.findLast(
            ({ top, isNote }) => !isNote && top < window.scrollY + 200
          );
          proxi.activeLabel = activeItem ? activeItem.label : "";
        }
      });
    });
  };
  var ScrollToFn = ({
    onMount,
    delegateEvents,
    bindProps,
    invalidate,
    computed,
    addMethod,
    updateState,
    getProxi
  }) => {
    const proxi = getProxi();
    let direction2 = "DOWN";
    let winHeight = window.innerHeight;
    addMethod("addItem", ({ id, label, element, isSection, isNote }) => {
      updateState("anchorItemsToBeComputed", (val2) => {
        return [...val2, { id, label, element, isSection, isNote }];
      });
    });
    addMethod("setActiveLabel", (label) => {
      if (disableObservereffect) return;
      proxi.activeLabel = label;
    });
    onMount(() => {
      if (core_exports.mq("max", "desktop")) return;
      computed(
        () => proxi.anchorItems,
        () => {
          return proxi.anchorItemsToBeComputed.map((item) => {
            return {
              ...item,
              top: offset(item.element).top
            };
          });
        }
      );
      const unsubscribeThrottle = modules_exports.useScrollThrottle(
        ({ direction: currentDirection }) => direction2 = currentDirection
      );
      let resizeObserver = new ResizeObserver(
        debounceFuncion(() => {
          modules_exports.useFrame(() => {
            modules_exports.useNextTick(() => {
              winHeight = window.innerHeight;
            });
          });
          proxi.anchorItems.forEach((item) => {
            item.top = offset(item.element).top;
          });
        }, 200)
      );
      resizeObserver.observe(modules_exports2.getRoot());
      const unsubscribeMouseWheel = proxi.updateAnchorOnWheel ? modules_exports.useMouseWheel(
        debounceFuncion(() => {
          if (disableObservereffect) return;
          setActiveLabelOnScroll({ proxi, direction: direction2, winHeight });
        }, 600)
      ) : () => {
      };
      const unsubScribeScrollEnd = modules_exports.useScrollEnd(() => {
        if (disableObservereffect) return;
        setActiveLabelOnScroll({ proxi, direction: direction2, winHeight });
      });
      return () => {
        unsubscribeMouseWheel();
        unsubscribeThrottle();
        unsubScribeScrollEnd();
        resizeObserver.unobserve(modules_exports2.getRoot());
        resizeObserver.disconnect();
        resizeObserver = null;
      };
    });
    return renderHtml`
        <div class="c-scroll-to">
            <ul>
                ${invalidate({
      observe: () => proxi.anchorItems,
      render: () => {
        return getButtons({
          delegateEvents,
          bindProps,
          proxi
        });
      }
    })}
            </ul>
        </div>
    `;
  };

  // src/js/component/common/scroll-to/definition.js
  var ScrollTo = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').ScrollTo>} */
    {
      tag: "scroll-to",
      component: ScrollToFn,
      state: {
        activeLabel: () => ({
          value: "",
          type: String
        }),
        updateAnchorOnWheel: () => ({
          value: false,
          type: Boolean
        }),
        anchorItemsToBeComputed: () => ({
          value: [],
          type: Array
        }),
        anchorItems: () => ({
          value: [],
          type: Array,
          transform: (value) => {
            return value.toSorted(
              function(a, b) {
                const { element: elementA } = a;
                const { element: elementB } = b;
                if (elementA === elementB || !elementA || !elementB)
                  return 0;
                if (elementA.compareDocumentPosition(elementB) & 2) {
                  return 1;
                }
                return -1;
              }
            );
          }
        })
      },
      child: [ScrollToButton]
    }
  );

  // src/js/pages/layout/utils.js
  var getBreadCrumbs = ({ breadCrumbs }) => breadCrumbs.map(
    (item, index) => index === breadCrumbs.length - 1 ? renderHtml`<a href="${item.url}" class="breadcrumbs__arrow">
                          <div class="breadcrumbs__arrow__start"></div>
                          <div class="breadcrumbs__arrow__end"></div>
                      </a>
                      <a class="breadcrumbs__link" href="${item.url}"
                          >${item.title}</a
                      >` : renderHtml`<a class="breadcrumbs__link" href="${item.url}"
                      >${item.title}</a
                  >`
  ).join("");

  // src/js/pages/layout/layout-sidebar-anchor.js
  modules_exports2.useComponent([
    DocContainer,
    DocsTitleSmall,
    ScrollTo,
    DocTitle,
    HtmlContent
  ]);
  var layoutSidebarAnchor = async ({ props }) => {
    const { source, title, breadCrumbs } = props;
    const { data } = await loadJsonContent({ source });
    return renderHtml` <doc-container>
        <div>
            <html-content
                slot="docs"
                ${modules_exports2.staticProps(
      /** @type {Partial<import('@commonComponent/html-content/type').HtmlContent['state']>} */
      {
        data: data.data,
        useMaxWidth: true
      }
    )}
            ></html-content>
            <doc-title-small slot="section-title-small"
                ><div>
                    ${getBreadCrumbs({
      breadCrumbs
    })}<span>${title}</span>
                </div></doc-title-small
            >
            <scroll-to name="${scrollToName}" slot="section-links"></scroll-to>
            <doc-title slot="section-title">${title}</doc-title>
        </div>
    </doc-container>`;
  };

  // src/js/pages/layout/layout-sidebar-links.js
  modules_exports2.useComponent([DocContainer, DocsTitleSmall, DocTitle, HtmlContent]);
  var layoutSidebarLinks = async ({ props }) => {
    const { source, title, breadCrumbs } = props;
    const { data } = await loadJsonContent({ source });
    return renderHtml` <doc-container>
        <div>
            <html-content
                slot="docs"
                ${modules_exports2.staticProps(
      /** @type {Partial<import('@commonComponent/html-content/type').HtmlContent['state']>} */
      {
        data: data.data,
        useMaxWidth: true
      }
    )}
            ></html-content>
            <doc-title-small slot="section-title-small"
                ><div>
                    ${getBreadCrumbs({
      breadCrumbs
    })}<span>${title}</span>
                </div></doc-title-small
            >
            <doc-title slot="section-title">${title}</doc-title>
        </div>
    </doc-container>`;
  };

  // src/js/component/pages/about/animation/inspiration.js
  var inspirationAnimation = ({
    weakInspirationitem,
    weakSectio4Title
  }) => {
    let masterSequencer = tween_exports.createMasterSequencer();
    let titleSequencer = tween_exports.createSequencer({
      data: {
        xTitle: 400
      }
    });
    titleSequencer.goTo({ xTitle: 0 }, { start: 0, end: 10 });
    titleSequencer.subscribe(({ xTitle }) => {
      if (!weakSectio4Title.deref()) return;
      weakSectio4Title.deref().style.transform = `translate3D(0,0,0) translateX(${xTitle}px)`;
    });
    titleSequencer.onStop(({ yTitle, xTitle }) => {
      if (!weakSectio4Title.deref()) return;
      weakSectio4Title.deref().style.transform = ` translate(${xTitle}px, ${yTitle}%)`;
    });
    masterSequencer.add(titleSequencer);
    const staggers = tween_exports.createStaggers({
      items: weakInspirationitem,
      stagger: {
        type: "end",
        each: 5,
        from: "start"
      }
    });
    staggers.forEach(({ item, start, end, index }) => {
      const sequencer = tween_exports.createSequencer({
        data: { x: 100 + index * 20 }
      }).goTo({ x: 0, opacity: 1 }, { start, end });
      sequencer.subscribe(({ x }) => {
        if (!item.deref()) return;
        item.deref().style.transform = `translate3D(0,0,0) translateX(${x}px)`;
      });
      sequencer.onStop(({ x }) => {
        if (!item.deref()) return;
        item.deref().style.transform = `translateX(${x}px)`;
      });
      masterSequencer.add(sequencer);
    });
    let inspirationScroller = scroller_exports.createScrollTrigger({
      item: weakInspirationitem[0].deref(),
      propierties: "tween",
      tween: masterSequencer,
      dynamicStart: {
        position: "right",
        value: () => 0
      },
      dynamicEnd: {
        position: "left",
        value: () => window.innerWidth / 2
      },
      ease: false
    });
    return {
      inspirationScroller,
      titleSequencer,
      masterSequencer,
      destroy: () => {
        inspirationScroller.destroy();
        inspirationScroller = null;
        titleSequencer.destroy();
        titleSequencer = null;
        masterSequencer.destroy();
        masterSequencer = null;
      }
    };
  };

  // src/js/component/pages/about/animation/path-animation.js
  var createPathAnimation = ({
    weakPathElement,
    weakScrollerElement,
    wrapElement,
    setActiveItem
  }) => {
    const sequencerData = weakPathElement.map(() => {
      return {
        ax: 53,
        ay: 70,
        bx: 64,
        by: 80,
        cx: 89,
        cy: 87,
        dx: 100,
        dy: 100,
        ex: 0,
        ey: 100,
        fx: 10,
        fy: 77,
        gx: 17,
        gy: 84
      };
    });
    const timelineData = {
      ax: -1,
      ay: -1,
      bx: 1,
      by: 1,
      cx: -1,
      cy: -1,
      dx: 1,
      dy: 1,
      ex: 1,
      ey: 1,
      fx: -1,
      fy: -1,
      gx: 1,
      gy: 1
    };
    let pathSequencer = tween_exports.createSequencer({
      data: { ...sequencerData[0] },
      stagger: {
        each: 40,
        waitComplete: false,
        from: "end"
      }
    });
    pathSequencer.goTo(
      {
        fy: 90,
        ay: 90,
        cy: 70
      },
      { start: 0, end: 3.5 }
    ).goTo(
      {
        gy: 70,
        by: 80
      },
      { start: 2, end: 5 }
    ).goTo(
      {
        fy: 90,
        ay: 100,
        cy: 90
      },
      { start: 4, end: 7.5 }
    ).goTo(
      {
        ay: 120,
        fy: 80,
        cy: 80
      },
      { start: 7.5, end: 10 }
    ).goTo(
      {
        gy: 100,
        by: 100
      },
      { start: 6, end: 10 }
    ).add(() => {
      setActiveItem(1);
    }, 0).add(({ direction: direction2, isForced }) => {
      if (isForced || direction2 === "forward") return;
      setActiveItem(1);
    }, 2.5).add(({ direction: direction2, isForced }) => {
      if (isForced || direction2 === "backward") return;
      setActiveItem(2);
    }, 1).add(({ direction: direction2, isForced }) => {
      if (isForced || direction2 === "forward") return;
      setActiveItem(2);
    }, 6).add(({ direction: direction2, isForced }) => {
      if (isForced || direction2 === "backward") return;
      setActiveItem(3);
    }, 4.5).add(({ direction: direction2, isForced }) => {
      if (isForced || direction2 === "forward") return;
      setActiveItem(3);
    }, 9).add(({ direction: direction2, isForced }) => {
      if (isForced || direction2 === "backward") return;
      setActiveItem(4);
    }, 8);
    sequencerData.forEach((item) => {
      pathSequencer.subscribe(
        ({ ax, ay, bx, by, cx, cy, dx, dy, ex, ey, fx, fy, gx, gy }) => {
          item.ax = ax;
          item.ay = ay;
          item.bx = bx;
          item.by = by;
          item.cx = cx;
          item.cy = cy;
          item.dx = dx;
          item.dy = dy;
          item.ex = ex;
          item.ey = ey;
          item.fx = fx;
          item.fy = fy;
          item.gx = gx;
          item.gy = gy;
        }
      );
    });
    let pathTween = tween_exports.createTimeTween({
      data: { ...timelineData }
    });
    pathTween.subscribe(
      ({ ax, ay, bx, by, cx, cy, dx, dy, ex, ey, fx, fy, gx, gy }) => {
        timelineData.ax = ax;
        timelineData.ay = ay;
        timelineData.bx = bx;
        timelineData.by = by;
        timelineData.cx = cx;
        timelineData.cy = cy;
        timelineData.dx = dx;
        timelineData.dy = dy;
        timelineData.ex = ex;
        timelineData.ey = ey;
        timelineData.fx = fx;
        timelineData.fy = fy;
        timelineData.gx = gx;
        timelineData.gy = gy;
      }
    );
    let pathTimeline = timeline_exports.createAsyncTimeline({
      repeat: -1,
      yoyo: true,
      autoSet: false
    }).goTo(
      pathTween,
      {
        ax: () => randomIntFromInterval(-3, 3),
        ay: () => randomIntFromInterval(-3, 3),
        bx: () => randomIntFromInterval(-3, 3),
        by: () => randomIntFromInterval(-3, 3),
        cx: () => randomIntFromInterval(-3, 3),
        cy: () => randomIntFromInterval(-3, 3),
        dx: () => 0,
        dy: () => 0,
        ex: () => 0,
        ey: () => 0,
        fx: () => randomIntFromInterval(-3, 3),
        fy: () => randomIntFromInterval(-3, 3),
        gx: () => randomIntFromInterval(-3, 3),
        gy: () => randomIntFromInterval(-3, 3)
      },
      { duration: 3e3 }
    );
    pathTimeline.play();
    let shouldLoop = true;
    const loop = () => {
      if (!shouldLoop) return;
      sequencerData.forEach((item, index) => {
        const a = {
          x: item.ax + timelineData.ax,
          y: item.ay + timelineData.ay
        };
        const b = {
          x: item.bx + timelineData.bx,
          y: item.by + timelineData.by
        };
        const c = {
          x: item.cx + timelineData.cx,
          y: item.cy + timelineData.cy
        };
        const d = {
          x: item.dx + timelineData.dx,
          y: item.dy + timelineData.dy
        };
        const e = {
          x: item.ex + timelineData.ex,
          y: item.ey + timelineData.ey
        };
        const f = {
          x: item.fx + timelineData.fx,
          y: item.fy + timelineData.fy
        };
        const g = {
          x: item.gx + timelineData.gx,
          y: item.gy + timelineData.gy
        };
        if (!weakPathElement[index].deref()) return;
        weakPathElement[index].deref().style.clipPath = `polygon(${a.x}% ${a.y}%, ${b.x}% ${b.y}%, ${c.x}% ${c.y}%, ${d.x}% ${d.y}%,${e.x}% ${e.y}%,${f.x}% ${f.y}%,${g.x}% ${g.y}%)`;
      });
      modules_exports.useNextFrame(() => loop());
    };
    modules_exports.useFrame(() => loop());
    let pathScroller = scroller_exports.createScrollTrigger({
      item: wrapElement,
      dynamicStart: {
        position: "left",
        value: () => window.innerWidth
      },
      dynamicEnd: {
        position: "right",
        value: () => {
          return -outerWidth(
            weakScrollerElement?.deref() ?? document.createElement("div")
          ) + window.innerWidth;
        }
      },
      reverse: true,
      propierties: "tween",
      ease: false,
      tween: pathSequencer
    });
    return {
      pathScroller,
      pathSequencer,
      pathTween,
      pathTimeline,
      stopLoop: () => {
        shouldLoop = false;
      },
      destroy: () => {
        pathScroller.destroy();
        pathScroller = null;
        pathSequencer.destroy();
        pathSequencer = null;
        pathTween.destroy();
        pathTween = null;
        pathTimeline.destroy();
        pathTimeline = null;
      }
    };
  };

  // src/js/component/pages/about/animation/section1.js
  var aboutSection1 = ({ title_1, title_2 }) => {
    const title1tween = tween_exports.createScrollerTween({
      from: { y: 0 },
      to: { y: 30 }
    });
    title1tween.subscribe(({ y }) => {
      title_1.style.transform = `translate3d(0,0,0) translate(${0}px, ${y}px)`;
    });
    title1tween.onStop(({ y }) => {
      title_1.style.transform = `translate(${0}px, ${y}px)`;
    });
    const title1parallax = scroller_exports.createParallax({
      item: title_1,
      propierties: "tween",
      tween: title1tween,
      ease: false,
      align: "start"
    });
    const title2tween = tween_exports.createScrollerTween({
      from: { y: 0 },
      to: { y: -30 }
    });
    title2tween.subscribe(({ y }) => {
      title_2.style.transform = `translate3d(0,0,0) translateY(${y}px)`;
    });
    title2tween.onStop(({ y }) => {
      title_2.style.transform = `translateY(${y}px)`;
    });
    const title2parallax = scroller_exports.createParallax({
      item: title_2,
      propierties: "tween",
      tween: title2tween,
      ease: false,
      align: "start"
    });
    return {
      title1parallax,
      title2parallax,
      title1tween,
      title2tween
    };
  };

  // src/js/component/pages/about/animation/section-content.js
  var sectionContentAnimation = ({ title, copy }) => {
    let sectionContentSequencer = tween_exports.createSequencer({
      data: {
        yTitle: 100,
        xTitle: -300,
        yCopy: -100,
        opacityTitle: 1,
        opacityCopy: 1
      }
    });
    sectionContentSequencer.goTo({ yTitle: 0, xTitle: 0, yCopy: 0 }, { start: 0, end: 5 }).goTo({ xTitle: -150 }, { start: 7, end: 10 }).goTo({ opacityTitle: 0, opacityCopy: 0 }, { start: 8.8, end: 10 });
    sectionContentSequencer.subscribe(
      ({ yTitle, xTitle, yCopy, opacityTitle, opacityCopy }) => {
        if (!title.deref() || !copy.deref()) return;
        title.deref().style.transform = `translate3d(0,0,0) translate(${xTitle}px, ${yTitle}%)`;
        copy.deref().style.transform = `translate3d(0,0,0) translateY(${yCopy}%)`;
        title.deref().style.opacity = opacityTitle;
        copy.deref().style.opacity = opacityCopy;
      }
    );
    sectionContentSequencer.onStop(
      ({ yTitle, xTitle, yCopy, opacityTitle, opacityCopy }) => {
        if (!title.deref() || !copy.deref()) return;
        title.deref().style.transform = `translate(${xTitle}px, ${yTitle}%)`;
        copy.deref().style.transform = `translateY(${yCopy}%)`;
        title.deref().style.opacity = opacityTitle;
        copy.deref().style.opacity = opacityCopy;
      }
    );
    let sectionContentScroller = scroller_exports.createScrollTrigger({
      item: title.deref(),
      dynamicStart: {
        position: "right",
        value: () => 0
      },
      dynamicEnd: {
        position: "left",
        value: () => 0
      },
      ease: false,
      propierties: "tween",
      tween: sectionContentSequencer
    });
    return {
      sectionContentScroller,
      sectionContentSequencer,
      destroy: () => {
        sectionContentScroller.destroy();
        sectionContentScroller = null;
        sectionContentSequencer.destroy();
        sectionContentSequencer = null;
      }
    };
  };

  // src/js/component/pages/about/animation/index.js
  var aboutAnimation = ({
    screenElement,
    scrollerElement,
    pathElement,
    wrapElement,
    title_1,
    title_2,
    section2_title,
    section2_copy,
    section3_title,
    section3_copy,
    inspirationItem,
    section4_title,
    setActiveItem,
    onScrollEnd,
    onMove,
    onSwipe
  }) => {
    const weakScrollerElement = new WeakRef(scrollerElement);
    const weakSectio2Title = new WeakRef(section2_title);
    const weakSectio2Copy = new WeakRef(section2_copy);
    const weakSectio3Title = new WeakRef(section3_title);
    const weakSectio3Copy = new WeakRef(section3_copy);
    const weakSectio4Title = new WeakRef(section4_title);
    const weakPathElement = pathElement.map((element) => {
      return new WeakRef(element);
    });
    const weakInspirationitem = inspirationItem.map((element) => {
      return new WeakRef(element);
    });
    const {
      pathScroller,
      pathSequencer,
      pathTimeline,
      pathTween,
      stopLoop,
      destroy: destroypathAnimation
    } = createPathAnimation({
      weakPathElement,
      weakScrollerElement,
      wrapElement,
      setActiveItem
    });
    const { title1parallax, title2parallax, title1tween, title2tween } = aboutSection1({ title_1, title_2 });
    const {
      sectionContentScroller: sectionContentScroller_1,
      sectionContentSequencer: section2TitleSequencer_1
    } = sectionContentAnimation({
      title: weakSectio2Title,
      copy: weakSectio2Copy
    });
    const {
      sectionContentScroller: sectionContentScroller_2,
      sectionContentSequencer: section2TitleSequencer_2,
      destroy: destroyContentAnimation
    } = sectionContentAnimation({
      title: weakSectio3Title,
      copy: weakSectio3Copy
    });
    const {
      inspirationScroller,
      masterSequencer,
      titleSequencer,
      destroy: destroyInspirationAnimation
    } = inspirationAnimation({
      weakInspirationitem,
      weakSectio4Title
    });
    let aboutScroller = new MobSmoothScroller({
      screen: screenElement,
      scroller: scrollerElement,
      direction: "horizontal",
      drag: true,
      easeType: "spring",
      breakpoint: "small",
      useHorizontalScroll: false,
      useSwipe: true,
      revertSwipeDirection: false,
      children: [
        pathScroller,
        title1parallax,
        title2parallax,
        sectionContentScroller_1,
        sectionContentScroller_2,
        inspirationScroller
      ],
      onUpdate: ({ value }) => {
        onMove(value);
        onScrollEnd();
      },
      onSwipe: ({ direction: direction2 }) => {
        onSwipe(direction2);
      }
    });
    aboutScroller.init();
    setTimeout(() => {
      aboutScroller?.refresh?.();
    }, 500);
    return {
      goTo: (value) => {
        aboutScroller?.move?.(value).catch(() => {
        });
      },
      destroy: () => {
        aboutScroller.destroy();
        aboutScroller = null;
        pathSequencer.destroy();
        pathScroller.destroy();
        pathTimeline.destroy();
        pathTween.destroy();
        title1parallax.destroy();
        title2parallax.destroy();
        title1tween.destroy();
        title2tween.destroy();
        sectionContentScroller_1.destroy();
        section2TitleSequencer_1.destroy();
        sectionContentScroller_2.destroy();
        section2TitleSequencer_2.destroy();
        inspirationScroller.destroy();
        masterSequencer.destroy();
        titleSequencer.destroy();
        stopLoop();
        destroypathAnimation();
        destroyContentAnimation();
        destroyInspirationAnimation();
      }
    };
  };

  // src/js/component/pages/about/animation/svg-animation.js
  var aboutSvgAnimation = ({ elements }) => {
    let svgSpring = tween_exports.createSpring({
      data: { x: 0 },
      stagger: {
        each: 5
      }
    });
    const svgs = elements.map((el) => el.querySelector("svg"));
    svgs.forEach((el) => {
      if (!el) return;
      svgSpring.subscribe(({ x }) => {
        el.style.transform = `translate3D(0,0,0) translateY(${-x}px)`;
      });
      svgSpring.onComplete(({ x }) => {
        el.style.transform = `translateY(${-x}px)`;
      });
    });
    return {
      svgSpring,
      destroySvgSpring: () => {
        svgSpring.destroy();
        svgSpring = null;
      }
    };
  };

  // src/js/component/pages/about/about.js
  var _goTo = () => {
  };
  var moveSvg = (value) => Promise.resolve(value);
  var moveSvgFromNav = () => {
  };
  var goToPercentage = {
    1: 0,
    2: 100 / 3 + 3,
    3: 100 / 3 * 2 + 6,
    4: 100
  };
  var block01 = ({ setRef, getState }) => {
    const { titleTop, titleBottom } = getState().block_1;
    return renderHtml`
        <section
            class="l-about__section l-about__section l-about__section--first "
        >
            <div class="l-about__section__top has-overflow">
                <h1 class="title-big" ${setRef("title_1")}>${titleTop}</h1>
            </div>
            <div class="l-about__section__bottom has-overflow">
                <h1 class="title-biggest" ${setRef("title_2")}>
                    ${titleBottom}
                </h1>
            </div>
        </section>
    `;
  };
  var block02 = ({ setRef, getState }) => {
    const { title, copy } = getState().block_2;
    return renderHtml`
        <section class="l-about__section">
            <div class="l-about__section__top has-overflow">
                <div class="l-about__section__left"></div>
                <div class="l-about__section__right">
                    <h1 class="title-biggest" ${setRef("section2_title")}>
                        ${title}
                    </h1>
                </div>
            </div>
            <div class="l-about__section__bottom has-overflow">
                <div class="l-about__section__right">
                    <p
                        class="l-about__section__copy paragraph-big"
                        ${setRef("section2_copy")}
                    >
                        ${copy}
                    </p>
                </div>
            </div>
        </section>
    `;
  };
  var block03 = ({ setRef, getState }) => {
    const { title, copy } = getState().block_3;
    return renderHtml`
        <section class="l-about__section">
            <div class="l-about__section__top has-overflow">
                <div class="l-about__section__left"></div>
                <div class="l-about__section__right">
                    <h1 class="title-biggest" ${setRef("section3_title")}>
                        ${title}
                    </h1>
                </div>
            </div>
            <div class="l-about__section__bottom has-overflow">
                <div class="l-about__section__right">
                    <p
                        class="l-about__section__copy paragraph-big"
                        ${setRef("section3_copy")}
                    >
                        ${copy}
                    </p>
                </div>
            </div>
        </section>
    `;
  };
  var block04 = ({ setRef, getState }) => {
    const { title, items } = getState().block_4;
    return renderHtml`
        <section class="l-about__section l-about__section--last">
            <div class="l-about__section__top">
                <h1 class="title-biggest" ${setRef("section4_title")}>
                    ${title}
                </h1>
            </div>
            <div class="l-about__section__bottom">
                <ul class="l-about__list">
                    ${items.map((item) => {
      return (
        /* HTML */
        `
                                <li ${setRef("inspirationItem")}>${item}</li>
                            `
      );
    }).join("")}
                </ul>
            </div>
        </section>
    `;
  };
  var navigation = ({ proxi, delegateEvents, bindEffect }) => {
    return renderHtml`
        <ul class="l-about__nav">
            ${proxi.navItem.map(({ index }) => {
      return renderHtml`
                        <li class="l-about__nav__item">
                            <button
                                class="l-about__nav__button"
                                ${delegateEvents({
        click: () => {
          _goTo(goToPercentage[index]);
          moveSvgFromNav();
        }
      })}
                            >
                                <span
                                    class="l-about__nav__dot"
                                    ${bindEffect({
        toggleClass: {
          active: () => proxi.activenavItem === index
        }
      })}
                                ></span>
                            </button>
                        </li>
                    `;
    }).join("")}
        </ul>
    `;
  };
  var getShapeTrail = ({ setRef }) => {
    const items = [...Array.from({ length: 1 }).keys()];
    return renderHtml`${items.map(() => {
      return renderHtml`
                <div
                    class="l-about__shape l-about__shape--back"
                    ${setRef("pathElement")}
                ></div>
            `;
    }).join("")}`;
  };
  var AboutComponentFn = ({
    onMount,
    setRef,
    getRef,
    getRefs,
    getState,
    bindEffect,
    delegateEvents,
    getProxi
  }) => {
    const proxi = getProxi();
    const numberOfSection = 4;
    let freezeOnLag = false;
    onMount(() => {
      const {
        screenElement,
        scrollerElement,
        wrapElement,
        title_1,
        title_2,
        section2_title,
        section2_copy,
        section3_title,
        section3_copy,
        section4_title
      } = getRef();
      const { inspirationItem, pathElement, svg } = getRefs();
      let startpercent = 0;
      let isMoving = false;
      let svgShiftAmount = 0;
      const { svgSpring, destroySvgSpring } = aboutSvgAnimation({
        elements: svg
      });
      moveSvg = async (value) => {
        const shouldStop = modules_exports.shouldMakeSomething();
        if (shouldStop || freezeOnLag) {
          svgSpring.stop();
          freezeOnLag = true;
          setTimeout(() => {
            freezeOnLag = false;
          }, 2e3);
          return;
        }
        const valueParsed = -Math.abs(value / 30);
        await svgSpring.goTo({ x: valueParsed }).catch(() => {
        });
      };
      moveSvgFromNav = () => {
        moveSvg(3e3);
        setTimeout(() => {
          moveSvg(0);
        }, 500);
      };
      const { destroy: destroy3, goTo } = aboutAnimation({
        screenElement,
        scrollerElement,
        pathElement,
        wrapElement,
        title_1,
        title_2,
        section2_title,
        section2_copy,
        section3_title,
        section3_copy,
        inspirationItem,
        section4_title,
        setActiveItem: (value) => {
          proxi.activenavItem = value;
        },
        onMove: (value) => {
          if (!isMoving) {
            startpercent = value;
          }
          isMoving = true;
          svgShiftAmount = startpercent - value;
          moveSvg(svgShiftAmount);
        },
        onSwipe: (direction2) => {
          if (direction2 === -1) {
            proxi.activenavItem -= 1;
          }
          if (direction2 === 1) {
            proxi.activenavItem += 1;
          }
          _goTo(goToPercentage[proxi.activenavItem]);
        },
        /**
         * Snap to active item. Debuounce update with 500,s value Scroll to the nearest section based on scroll
         * direction
         */
        onScrollEnd: modules_exports.useDebounce(() => {
          _goTo(goToPercentage[proxi.activenavItem]);
          isMoving = false;
          svgShiftAmount = 0;
          moveSvg(svgShiftAmount);
        }, 500)
      });
      _goTo = goTo;
      return () => {
        _goTo = () => {
        };
        destroy3();
        destroySvgSpring();
      };
    });
    return renderHtml`<div
        class="l-about"
        ${setRef("screenElement")}
        style="--number-of-section:${numberOfSection}"
    >
        <span class="l-about__background">
            <div
                class="l-about__about-svg l-about__about-svg--bottom"
                ${setRef("svg")}
            >
                ${proxi.aboutSvg}
            </div>
        </span>
        ${getShapeTrail({ setRef })}
        <div
            class="l-about__about-svg l-about__about-svg--back"
            ${setRef("svg")}
        >
            ${proxi.aboutSvg}
        </div>
        <div
            class="l-about__shape l-about__shape--front"
            ${setRef("pathElement")}
        >
            <div class="l-about__about-svg l-about__about-svg--front">
                ${proxi.aboutSvg}
            </div>
        </div>
        <button
            type="button"
            class="l-about__arrow l-about__arrow--prev"
            ${bindEffect({
      toggleClass: {
        active: () => proxi.activenavItem > 1
      }
    })}
            ${delegateEvents({
      click: () => {
        proxi.activenavItem -= 1;
        _goTo(goToPercentage[proxi.activenavItem]);
        moveSvgFromNav();
      }
    })}
        >
            <span></span>
        </button>
        <button
            type="button"
            class="l-about__arrow l-about__arrow--next"
            ${bindEffect({
      toggleClass: {
        active: () => proxi.activenavItem < 4
      }
    })}
            ${delegateEvents({
      click: () => {
        proxi.activenavItem += 1;
        _goTo(goToPercentage[proxi.activenavItem]);
        moveSvgFromNav();
      }
    })}
        >
            <span></span>
        </button>
        <div class="l-about__scroller" ${setRef("scrollerElement")}>
            <div class="l-about__wrap" ${setRef("wrapElement")}>
                ${block01({ setRef, getState })}
                ${block02({ setRef, getState })}
                ${block03({ setRef, getState })}
                ${block04({ setRef, getState })}
            </div>
        </div>
        ${navigation({ bindEffect, delegateEvents, proxi })}
    </div>`;
  };

  // src/js/component/pages/about/definition.js
  var AboutComponent = modules_exports2.createComponent(
    /** @type{CreateComponentParams<import ('./type').About>} */
    {
      tag: "about-component",
      component: AboutComponentFn,
      exportState: ["block_1", "block_2", "block_3", "block_4", "aboutSvg"],
      state: {
        block_1: () => ({
          value: {
            titleTop: "",
            titleBottom: ""
          },
          type: "any"
        }),
        block_2: () => ({
          value: {
            title: "",
            copy: ""
          },
          type: "any"
        }),
        block_3: () => ({
          value: {
            title: "",
            copy: ""
          },
          type: "any"
        }),
        block_4: () => ({
          value: {
            title: "",
            items: [""]
          },
          type: "any"
        }),
        aboutSvg: () => ({
          value: "",
          type: String
        }),
        navItem: () => ({
          value: [{ index: 1 }, { index: 2 }, { index: 3 }, { index: 4 }],
          type: Array
        }),
        activenavItem: () => ({
          value: 1,
          type: Number,
          transform: (value) => {
            return core_exports.clamp(value, 1, 4);
          }
        })
      },
      child: []
    }
  );

  // src/js/pages/about/layout-about.js
  modules_exports2.useComponent([AboutComponent]);
  var layoutAbout = async () => {
    const { data } = await loadJsonContent({
      source: "./data/about/index.json"
    });
    const { data: aboutSvg } = await loadTextContent({
      source: "./asset/svg/about.svg?v=0.1"
    });
    return renderHtml`<about-component
        ${modules_exports2.staticProps(
      /** @type {import('@pagesComponent/about/type').About['state']} */
      {
        block_1: data.block_1,
        block_2: data.block_2,
        block_3: data.block_3,
        block_4: data.block_4,
        aboutSvg
      }
    )}
    ></about-component> `;
  };

  // src/js/component/pages/benchmark/fake-component/benchmark-fake-component.js
  var BenchMarkFakeComponentFn = ({
    getProxi,
    bindObject,
    delegateEvents,
    onMount,
    id,
    bindEffect
  }) => {
    const proxiState = getProxi();
    onMount(() => {
      return () => {
      };
    });
    return renderHtml`<div
        class="benchmark-fake"
        ${bindEffect({
      toggleClass: { selected: () => proxiState.isSelected }
    })}
    >
        <div class="benchmark-fake__row">
            <strong>id:</strong><br />
            ${id}
        </div>
        <div class="benchmark-fake__row">
            ${bindObject`<strong>index:</strong><br/> ${() => proxiState.index}`}
        </div>
        <div class="benchmark-fake__row">
            ${bindObject`<strong>label:</strong><br/> ${() => proxiState.label}`}
        </div>
        <div class="benchmark-fake__row">
            ${bindObject`<strong>counter: </strong><br/> ${() => proxiState.counter}`}
        </div>
        <div class="benchmark-fake__row">
            <button
                class="benchmark-fake__button"
                type="button"
                ${delegateEvents({
      click: () => {
        proxiState.isSelected = !proxiState.isSelected;
      }
    })}
            >
                Select
            </button>
        </div>
    </div> `;
  };

  // src/js/component/pages/benchmark/fake-component/definition.js
  var BenchMarkFakeComponent = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').BenchMarkFakeComponent>} */
    {
      tag: "benchmark-fake-component",
      component: BenchMarkFakeComponentFn,
      exportState: ["index", "counter", "label"],
      state: {
        counter: () => ({
          value: 0,
          type: Number
        }),
        label: () => ({
          value: "",
          type: String
        }),
        index: () => ({
          value: 0,
          type: Number
        }),
        isSelected: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/pages/benchmark/partials/definition-partial.js
  var benchMarkDefinitionPartial = (maxItem = 1001) => ({
    exportState: ["svg"],
    state: {
      counter: () => ({
        value: 0,
        type: Number
      }),
      data: () => ({
        value: [],
        type: Array,
        validate: (value) => value.length < maxItem,
        strict: true,
        skipEqual: false
      }),
      time: () => ({
        value: 0,
        type: Number,
        transform: (value) => Math.round(value),
        skipEqual: false
      }),
      isLoading: () => ({
        value: false,
        type: Boolean
      })
    },
    child: [BenchMarkFakeComponent]
  });

  // src/js/component/pages/benchmark/partials/bench-mark-list-partial.js
  var shuffle = (array) => {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  };
  var createBenchMarkArray = (numberOfItem) => {
    const valueSanitized = modules_exports.checkType(Number, numberOfItem) ? numberOfItem : 0;
    return [...Array.from({ length: valueSanitized }).keys()].map((i) => ({
      label: `comp-${i + 1}`
    }));
  };
  var setData = async ({ setState, value, useShuffle = false }) => {
    setState("isLoading", true);
    await modules_exports2.tick();
    modules_exports.useFrame(() => {
      modules_exports.useNextTick(async () => {
        const startTime2 = performance.now();
        setState(
          "data",
          useShuffle ? shuffle(createBenchMarkArray(value)) : createBenchMarkArray(value)
        );
        await modules_exports2.tick();
        const endTime = performance.now();
        const difference = endTime - startTime2;
        setState("time", difference);
        setState("isLoading", false);
      });
    });
  };
  var benchMarkListPartial = ({
    delegateEvents,
    setRef,
    getRef,
    updateState,
    getState,
    setState,
    bindEffect
  }) => {
    return renderHtml`
        <div
            class="benchmark__loading"
            ${bindEffect({
      observe: "isLoading",
      toggleClass: { active: () => getState().isLoading }
    })}
        >
            generate components
        </div>
        <div class="benchmark__head__controls">
            <input
                class="benchmark__head__input"
                type="text"
                placeholder="Number of component"
                ${setRef("input")}
                ${delegateEvents({
      keydown: (event) => {
        if (event.keyCode === 13) {
          event.preventDefault();
          const value = Number(
            /** @type {HTMLInputElement} */
            event.target?.value ?? 0
          );
          setData({ setState, value });
        }
      }
    })}
            />
            <button
                type="button"
                class="benchmark__head__button"
                ${delegateEvents({
      click: () => {
        const { input } = getRef();
        const value = Number(
          /** @type {HTMLInputElement} */
          input?.value ?? 0
        );
        setData({ setState, value });
      }
    })}
            >
                Generate components
            </button>
            <button
                type="button"
                class="benchmark__head__button"
                ${delegateEvents({
      click: () => {
        const { data } = getState();
        setData({
          setState,
          value: data.length,
          useShuffle: true
        });
      }
    })}
            >
                Shuffle array
            </button>
            <button
                type="button"
                class="benchmark__head__button"
                ${delegateEvents({
      click: () => {
        updateState("counter", (value) => value + 1);
      }
    })}
            >
                Update counter
            </button>
        </div>
    `;
  };

  // src/js/component/pages/benchmark/invalidate/benchmark-invalidate.js
  var BenchMarkInvalidateFn = ({
    onMount,
    delegateEvents,
    bindText,
    invalidate,
    getState,
    staticProps: staticProps2,
    setRef,
    getRef,
    setState,
    updateState,
    bindProps,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    onMount(() => {
      return () => {
        getRef()?.input.remove();
      };
    });
    return renderHtml`<div class="benchmark">
        <div class="benchmark__head">
            <h3 class="benchmark__head__subtitle">Invalidate:</h3>
            <h2 class="benchmark__head__title">
                Generate components performance
            </h2>
            <p>
                Invalidate a large list of components with 5 reactive elements
                inside.<br />
                ( max component <strong>1000</strong> ).
            </p>
            ${benchMarkListPartial({
      setRef,
      getRef,
      setState,
      updateState,
      delegateEvents,
      getState,
      bindEffect
    })}

            <div class="benchmark__head__time">
                ${bindText`components generate in <strong>${"time"}ms</strong>`}
            </div>
        </div>
        <div class="benchmark__list">
            ${invalidate({
      observe: () => proxi.data,
      render: () => {
        const { data } = getState();
        return renderHtml`
                        ${data.map(({ label }, index) => {
          return renderHtml`
                                    <benchmark-fake-component
                                        ${staticProps2(
            /** @type {import('../fake-component/type').BenchMarkFakeComponent['state']} */
            {
              label,
              index
            }
          )}
                                        ${bindProps(
            /**
             * @returns {ReturnBindProps<
             *     import('../fake-component/type').BenchMarkFakeComponent
             * >}
             */
            () => ({
              counter: proxi.counter
            })
          )}
                                    ></benchmark-fake-component>
                                `;
        }).join("")}
                    `;
      }
    })}
        </div>
    </div>`;
  };

  // src/js/component/pages/benchmark/invalidate/definition.js
  var BenchMarkInvalidate = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('../type').BenchMark>} */
    {
      tag: "benchmark-invalidate",
      component: BenchMarkInvalidateFn,
      ...benchMarkDefinitionPartial()
    }
  );

  // src/js/component/pages/benchmark/partials/bench-mark-garbage-partial.js
  var benchMarkGarbagePartial = () => {
    return renderHtml`
        <p>
            Generates and updates a large list of components with 5 reactive
            elements inside.<br />
            ( max component <strong>1000</strong> ).
        </p>
    `;
  };

  // src/js/component/pages/benchmark/repeat-key/benchmark-repeat-with-key.js
  var BenchMarkRepeatWithKyFn = ({
    onMount,
    delegateEvents,
    bindText,
    setRef,
    getRef,
    getState,
    setState,
    updateState,
    bindProps,
    repeat,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    onMount(() => {
      return () => {
        getRef()?.input.remove();
      };
    });
    return renderHtml`<div class="benchmark">
        <div class="benchmark__head">
            <h3 class="benchmark__head__subtitle">Repeat ( with key ):</h3>
            <h2 class="benchmark__head__title">
                Generate components performance
            </h2>
            ${benchMarkGarbagePartial()}
            ${benchMarkListPartial({
      setRef,
      getRef,
      setState,
      updateState,
      delegateEvents,
      getState,
      bindEffect
    })}

            <div class="benchmark__head__time">
                ${bindText`components generate in <strong>${"time"}ms</strong>`}
            </div>
        </div>
        <div class="benchmark__list">
            ${repeat({
      observe: () => proxi.data,
      useSync: true,
      key: "label",
      render: ({ sync, current }) => {
        return renderHtml`
                        <benchmark-fake-component
                            class="old"
                            ${bindProps(
          /** @returns {ReturnBindProps<BenchMarkFakeComponent>} */
          () => ({
            index: current.index,
            label: current.value.label,
            counter: proxi.counter
          })
        )}
                            ${sync()}
                        >
                        </benchmark-fake-component>
                    `;
      }
    })}
        </div>
    </div>`;
  };

  // src/js/component/pages/benchmark/repeat-key/definition.js
  var BenchMarkRepeatWithKey = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('../type').BenchMark>} */
    {
      tag: "benchmark-repeat-key",
      component: BenchMarkRepeatWithKyFn,
      ...benchMarkDefinitionPartial()
    }
  );

  // src/js/component/pages/benchmark/repeat-key-nested/benchmark-repeat-with-key-nested.js
  var BenchMarkRepeatWithKyFnNested = ({
    onMount,
    delegateEvents,
    bindText,
    setRef,
    getRef,
    getState,
    setState,
    updateState,
    bindProps,
    repeat,
    bindObject,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    onMount(() => {
      return () => {
        getRef()?.input.remove();
      };
    });
    return renderHtml`<div class="benchmark">
        <div class="benchmark__head">
            <h3 class="benchmark__head__subtitle">
                Repeat ( nested with key ):
            </h3>
            <p class="benchmark__head__title">
                Repater without component with the same repeater with component
                inside<br />
                ( max value <strong>10</strong> ).
            </p>
            ${benchMarkListPartial({
      setRef,
      getRef,
      setState,
      updateState,
      delegateEvents,
      getState,
      bindEffect
    })}

            <div class="benchmark__head__time">
                ${bindText`components generate in <strong>${"time"}ms</strong>`}
            </div>
        </div>
        <div class="benchmark__list">
            ${repeat({
      observe: () => proxi.data,
      key: "label",
      useSync: true,
      render: ({ current }) => {
        return renderHtml`<div class="benchmark__static-item">
                        <div class="benchmark__static-item__inner">
                            ${bindObject`label: ${() => current.value.label}`}
                        </div>
                        <div>
                            ${repeat({
          observe: () => proxi.data,
          useSync: true,
          key: "label",
          render: ({ sync, current: current2 }) => {
            return renderHtml`
                                        <benchmark-fake-component
                                            ${bindProps(
              /** @returns {ReturnBindProps<BenchMarkFakeComponent>} */
              () => ({
                index: current2.index,
                label: current2.value.label,
                counter: proxi.counter
              })
            )}
                                            ${sync()}
                                        >
                                        </benchmark-fake-component>
                                    `;
          }
        })}
                        </div>
                    </div>`;
      }
    })}
        </div>
    </div>`;
  };

  // src/js/component/pages/benchmark/repeat-key-nested/definition.js
  var BenchMarkRepeatWithKeyNested = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('../type').BenchMark>} */
    {
      tag: "benchmark-repeat-key-nested",
      component: BenchMarkRepeatWithKyFnNested,
      ...benchMarkDefinitionPartial(31)
    }
  );

  // src/js/component/pages/benchmark/repeat-no-key/benchmark-repeat-no-key.js
  var BenchMarkRepeatNoKyFn = ({
    onMount,
    delegateEvents,
    bindText,
    setRef,
    getRef,
    getState,
    setState,
    updateState,
    bindProps,
    repeat,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    onMount(() => {
      return () => {
        getRef()?.input.remove();
      };
    });
    return renderHtml`<div class="benchmark">
        <div class="benchmark__head">
            <h3 class="benchmark__head__subtitle">Repeat ( without key ):</h3>
            <h2 class="benchmark__head__title">
                Generate components performance
            </h2>
            ${benchMarkGarbagePartial()}
            ${benchMarkListPartial({
      setRef,
      getRef,
      setState,
      updateState,
      delegateEvents,
      getState,
      bindEffect
    })}

            <div class="benchmark__head__time">
                ${bindText`components generate in <strong>${"time"}ms</strong>`}
            </div>
        </div>
        <div class="benchmark__list">
            ${repeat({
      observe: () => proxi.data,
      useSync: true,
      render: ({ sync, current }) => {
        return renderHtml`
                        <benchmark-fake-component
                            ${bindProps(
          /** @returns {ReturnBindProps<BenchMarkFakeComponent>} */
          () => ({
            index: current.index,
            label: current.value.label,
            counter: proxi.counter
          })
        )}
                            ${sync()}
                        >
                        </benchmark-fake-component>
                    `;
      }
    })}
        </div>
    </div>`;
  };

  // src/js/component/pages/benchmark/repeat-no-key/definition.js
  var BenchMarkRepeatNoKey = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('../type').BenchMark>} */
    {
      tag: "benchmark-repeat-no-key",
      component: BenchMarkRepeatNoKyFn,
      ...benchMarkDefinitionPartial()
    }
  );

  // src/js/stores/benchmark/index.js
  var externalBenchmarkStore = modules_exports.createStore(
    /** @type {MobStoreParams<import('./type').ExternalStore>} */
    {
      data: () => ({
        value: [],
        type: Array,
        validate: (value) => value.length < 1001,
        strict: true,
        skipEqual: false
      }),
      counter: () => ({
        value: 0,
        type: Number
      }),
      time: () => ({
        value: 0,
        type: Number,
        transform: (value) => Math.round(value),
        skipEqual: false
      }),
      isLoading: () => ({
        value: false,
        type: Boolean
      })
    }
  );

  // src/js/component/pages/benchmark/repeat-no-key-bind-store/bench-mark-list-external-partial.js
  var setData2 = async ({ value, useShuffle = false }) => {
    const { set } = externalBenchmarkStore;
    set("isLoading", true);
    await modules_exports2.tick();
    modules_exports.useFrame(() => {
      modules_exports.useNextTick(async () => {
        const startTime2 = performance.now();
        set(
          "data",
          useShuffle ? shuffle(createBenchMarkArray(value)) : createBenchMarkArray(value)
        );
        await modules_exports2.tick();
        const endTime = performance.now();
        const difference = endTime - startTime2;
        set("time", difference);
        set("isLoading", false);
      });
    });
  };
  var benchMarkListExternalPartial = ({
    delegateEvents,
    setRef,
    getRef,
    getState,
    bindEffect
  }) => {
    const { update: update3 } = externalBenchmarkStore;
    return renderHtml`
        <div
            class="benchmark__loading"
            ${bindEffect({
      observe: "isLoading",
      toggleClass: { active: () => getState().isLoading }
    })}
        >
            generate components
        </div>
        <div class="benchmark__head__controls">
            <input
                class="benchmark__head__input"
                type="text"
                placeholder="Number of component"
                ${setRef("input")}
                ${delegateEvents({
      keydown: (event) => {
        if (event.code.toLowerCase() === "enter") {
          event.preventDefault();
          const value = Number(
            /** @type {HTMLInputElement} */
            event.target?.value ?? 0
          );
          setData2({ value });
        }
      }
    })}
            />
            <button
                type="button"
                class="benchmark__head__button"
                ${delegateEvents({
      click: () => {
        const { input } = getRef();
        const value = Number(
          /** @type {HTMLInputElement} */
          input?.value ?? 0
        );
        setData2({ value });
      }
    })}
            >
                Generate components
            </button>
            <button
                type="button"
                class="benchmark__head__button"
                ${delegateEvents({
      click: () => {
        const { data } = getState();
        setData2({
          value: data.length,
          useShuffle: true
        });
      }
    })}
            >
                Shuffle array
            </button>
            <button
                type="button"
                class="benchmark__head__button"
                ${delegateEvents({
      click: () => {
        update3("counter", (value) => value + 1);
      }
    })}
            >
                Update counter
            </button>
        </div>
    `;
  };

  // src/js/component/pages/benchmark/repeat-no-key-bind-store/benchmark-repeat-no-key-bind-store.js
  var BenchMarkRepeatNoKyBindStoreFn = ({
    onMount,
    delegateEvents,
    bindText,
    setRef,
    getRef,
    getState,
    bindProps,
    repeat,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    onMount(() => {
      return () => {
        getRef()?.input.remove();
        externalBenchmarkStore.set("data", []);
        externalBenchmarkStore.set("time", 0);
      };
    });
    return renderHtml`<div class="benchmark">
        <div class="benchmark__head">
            <h3 class="benchmark__head__subtitle">
                Repeat bind external store ( without key ):
            </h3>
            <p class="benchmark__head__title">
                Use extrernal store as state ( bindStore module ).<br />
                ( max value <strong>1000</strong> ).
            </p>
            ${benchMarkListExternalPartial({
      setRef,
      getRef,
      delegateEvents,
      getState,
      bindEffect
    })}

            <div class="benchmark__head__time">
                ${bindText`components generate in <strong>${"time"}ms</strong>`}
            </div>
        </div>
        <div class="benchmark__list">
            ${repeat({
      observe: () => proxi.data,
      useSync: true,
      afterUpdate: () => {
      },
      render: ({ sync, current }) => {
        return renderHtml`
                        <benchmark-fake-component
                            ${bindProps(
          /** @returns {ReturnBindProps<BenchMarkFakeComponent>} */
          () => ({
            index: current.index,
            label: current.value.label,
            counter: proxi.counter
          })
        )}
                            ${sync()}
                        >
                        </benchmark-fake-component>
                    `;
      }
    })}
        </div>
    </div>`;
  };

  // src/js/component/pages/benchmark/repeat-no-key-bind-store/definition.js
  var BenchMarkRepeatNoKeyBindStore = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').BenchMarkExternal>} */
    {
      tag: "benchmark-repeat-no-key-bind-store",
      component: BenchMarkRepeatNoKyBindStoreFn,
      bindStore: externalBenchmarkStore,
      state: {},
      child: [BenchMarkFakeComponent]
    }
  );

  // src/js/component/pages/benchmark/repeat-no-key-nested/benchmark-repeat-with-key-nested.js
  var BenchMarkRepeatWithNoKeyFnNested = ({
    onMount,
    delegateEvents,
    bindText,
    setRef,
    getRef,
    getState,
    setState,
    updateState,
    bindProps,
    repeat,
    bindObject,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    onMount(() => {
      return () => {
        getRef()?.input.remove();
      };
    });
    return renderHtml`<div class="benchmark">
        <div class="benchmark__head">
            <h3 class="benchmark__head__subtitle">
                Repeat ( nested without key ):
            </h3>
            <p class="benchmark__head__title">
                Repater without component with the same repeater with component
                inside<br />
                ( max value <strong>10</strong> ).
            </p>
            ${benchMarkListPartial({
      setRef,
      getRef,
      setState,
      updateState,
      delegateEvents,
      getState,
      bindEffect
    })}

            <div class="benchmark__head__time">
                ${bindText`components generate in <strong>${"time"}ms</strong>`}
            </div>
        </div>
        <div class="benchmark__list">
            ${repeat({
      observe: () => proxi.data,
      useSync: true,
      render: ({ current }) => {
        return renderHtml`<div class="benchmark__static-item">
                        <div class="benchmark__static-item__inner">
                            ${bindObject`label: ${() => current.value.label}`}
                        </div>
                        <div>
                            ${repeat({
          observe: () => proxi.data,
          useSync: true,
          render: ({ sync, current: current2 }) => {
            return renderHtml`
                                        <benchmark-fake-component
                                            ${bindProps(
              /** @returns {ReturnBindProps<BenchMarkFakeComponent>} */
              () => ({
                index: current2.index,
                label: current2.value.label,
                counter: proxi.counter
              })
            )}
                                            ${sync()}
                                        >
                                        </benchmark-fake-component>
                                    `;
          }
        })}
                        </div>
                    </div>`;
      }
    })}
        </div>
    </div>`;
  };

  // src/js/component/pages/benchmark/repeat-no-key-nested/definition.js
  var BenchMarkRepeatWithNoKeyNested = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('../type').BenchMark>} */
    {
      tag: "benchmark-repeat-key-no-nested",
      component: BenchMarkRepeatWithNoKeyFnNested,
      ...benchMarkDefinitionPartial(31)
    }
  );

  // src/js/pages/benchmark/index.js
  modules_exports2.useComponent([
    BenchMarkInvalidate,
    BenchMarkRepeatNoKey,
    BenchMarkRepeatWithKey,
    BenchMarkRepeatWithKeyNested,
    BenchMarkRepeatWithNoKeyNested,
    BenchMarkRepeatNoKeyBindStore
  ]);
  var benchMark = async ({ props }) => {
    const { rootComponent } = props;
    console.log(rootComponent);
    return renderHtml`<div class="l-benchMark"><${rootComponent}></${rootComponent}></div>`;
  };

  // src/js/component/common/quick-nav/utils.js
  var updateQuickNavState = ({
    active: active2 = true,
    nextRoute = "",
    prevRoute = "",
    backRoute = "",
    color = "white"
  }) => {
    const setQuickNavState = modules_exports2.setStateByName(quickNavName);
    setQuickNavState("active", active2);
    setQuickNavState("nextRoute", nextRoute);
    setQuickNavState("prevRoute", prevRoute);
    setQuickNavState("backRoute", backRoute);
    setQuickNavState("color", color);
  };

  // src/js/utils/canvas-utils.js
  var canvasBackground = "rgba(255, 255, 255, 0)";
  var getCanvasContext = ({ disableOffcanvas }) => {
    const useOffscreen = "OffscreenCanvas" in globalThis && !disableOffcanvas;
    const context = useOffscreen ? "bitmaprenderer" : "2d";
    return { useOffscreen, context };
  };
  var getOffsetCanvas = ({ useOffscreen, canvas }) => {
    const offscreen = useOffscreen ? new OffscreenCanvas(canvas.width, canvas.height) : null;
    const offScreenCtx = useOffscreen ? offscreen?.getContext("2d") : null;
    return { offscreen, offScreenCtx };
  };
  var copyCanvasBitmap = ({ useOffscreen, offscreen, ctx }) => {
    if (useOffscreen && offscreen && ctx) {
      const bitmap = offscreen.transferToImageBitmap();
      ctx.transferFromImageBitmap(bitmap);
    }
  };
  var roundRectIsSupported = (ctx) => "roundRect" in ctx;
  var roundRectCustom = (ctx, x, y, w, h, r) => {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  };
  var createGrid = ({
    canvas,
    numberOfRow,
    numberOfColumn,
    cellWidth,
    cellHeight,
    gutter
  }) => {
    const initValue = { row: 0, col: -1, items: [] };
    return [
      ...Array.from({
        length: numberOfRow * numberOfColumn + numberOfRow
      }).keys()
    ].reduce((previous) => {
      const { row, col, items: previousItems } = previous;
      const newCol = col < numberOfColumn ? col + 1 : 0;
      const newRow = newCol === 0 ? row + 1 : row;
      const x = (cellWidth + gutter) * newCol;
      const y = (cellHeight + gutter) * newRow;
      return {
        row: newRow,
        col: newCol,
        items: [
          ...previousItems,
          {
            width: cellWidth,
            height: cellHeight,
            x,
            y,
            centerX: x + cellWidth / 2,
            centerY: y + cellHeight / 2,
            offsetXCenter: getOffsetXCenter({
              canvasWidth: canvas.width,
              width: cellWidth,
              gutter,
              numberOfColumn
            }),
            offsetYCenter: getOffsetYCenter({
              canvasHeight: canvas.height,
              height: cellHeight,
              gutter,
              numberOfRow
            }),
            gutter,
            numberOfColumn
          }
        ]
      };
    }, initValue);
  };
  var getOffsetXCenter = ({
    canvasWidth,
    width,
    gutter,
    numberOfColumn
  }) => {
    return canvasWidth / 2 - (width + gutter) * numberOfColumn / 2 - width / 2;
  };
  var getOffsetYCenter = ({
    canvasHeight,
    height,
    gutter,
    numberOfRow
  }) => {
    return canvasHeight / 2 - (height + gutter) * (numberOfRow + 1) / 2 - height / 2;
  };

  // src/js/component/pages/animated-pattern/n0/animation/animation.js
  var animatedPatternN0Animation = ({
    canvas,
    numberOfRow,
    numberOfColumn,
    cellWidth,
    cellHeight,
    gutter,
    fill,
    disableOffcanvas,
    stagger,
    reorder
  }) => {
    const { useOffscreen, context } = getCanvasContext({ disableOffcanvas });
    let isActive2 = true;
    let ctx = canvas.getContext(context, { alpha: true });
    const activeRoute = modules_exports2.getActiveRoute();
    let { offscreen, offScreenCtx } = getOffsetCanvas({ useOffscreen, canvas });
    let wichContext = useOffscreen ? offScreenCtx : ctx;
    const useRadius = roundRectIsSupported(
      /** @type {CanvasRenderingContext2D} */
      wichContext
    );
    wichContext = null;
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    let gridData = createGrid({
      canvas,
      numberOfRow,
      numberOfColumn,
      cellWidth,
      cellHeight,
      gutter
    }).items;
    let data = reorder ? gridData.map((item, i) => {
      return {
        ...item,
        scale: 1,
        rotate: 0,
        hasFill: fill.includes(i)
      };
    }).sort((value) => value.hasFill ? -1 : 1).reverse() : gridData.map((item, i) => {
      const hasFill = fill.includes(i);
      return {
        ...item,
        scale: 1,
        rotate: 0,
        hasFill
      };
    });
    let gridTween = tween_exports.createTimeTween({
      ease: "easeInOutQuad",
      stagger,
      data: { scale: 1, rotate: 0 }
    });
    data.forEach((item) => {
      gridTween.subscribeCache(item, ({ scale, rotate }) => {
        item.rotate = rotate;
        item.scale = scale;
      });
    });
    const draw = () => {
      if (!ctx) return;
      if (useOffscreen && offscreen) {
        offscreen.width = canvas.width;
        offscreen.height = canvas.height;
      }
      const context2 = useOffscreen ? offScreenCtx : (
        /** @type {CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D} */
        ctx
      );
      if (!context2) return;
      canvas.width = canvas.width;
      data.forEach(
        ({
          x,
          y,
          centerX,
          centerY,
          width,
          height,
          rotate,
          scale,
          hasFill,
          offsetXCenter,
          offsetYCenter
        }) => {
          const rotation = Math.PI / 180 * rotate;
          const xx = Math.cos(rotation) * scale;
          const xy = Math.sin(rotation) * scale;
          context2.setTransform(
            xx,
            xy,
            -xy,
            xx,
            Math.round(centerX + offsetXCenter),
            Math.round(centerY + offsetYCenter)
          );
          if (useRadius) {
            context2.beginPath();
            context2.roundRect(
              Math.round(-centerX + x),
              Math.round(-centerY + y),
              width,
              height,
              5
            );
          } else {
            context2.beginPath();
            context2.rect(
              Math.round(-centerX + x),
              Math.round(-centerY + y),
              width,
              height
            );
          }
          if (hasFill) {
            context2.fillStyle = `#000000`;
            context2.fill();
          } else {
            context2.strokeStyle = `#000`;
            context2.fillStyle = `rgba(238, 238, 238, 0.9)`;
            context2.stroke();
            context2.fill();
          }
          context2.setTransform(1, 0, 0, 1, 0, 0);
        }
      );
      copyCanvasBitmap({ useOffscreen, offscreen, ctx });
    };
    let gridTimeline = timeline_exports.createAsyncTimeline({
      repeat: -1,
      yoyo: true,
      autoSet: false
    }).label({ name: "label1" }).goTo(gridTween, { scale: 1.5, rotate: 90 }, { duration: 1e3 }).goTo(gridTween, { scale: 0.5 }, { duration: 500 }).goTo(gridTween, { rotate: 180, scale: 1.2 }, { duration: 500 }).goTo(gridTween, { scale: 1.3 }, { duration: 500 }).goTo(gridTween, { scale: 1 }, { duration: 1200 });
    gridTimeline.onLoopEnd(({ direction: direction2, loop: loop2 }) => {
      console.log(`loop end: ${direction2}, ${loop2}`);
    });
    gridTimeline.play();
    const loop = () => {
      draw();
      if (!isActive2) return;
      modules_exports.useNextFrame(() => loop());
    };
    modules_exports.useFrame(() => {
      loop();
    });
    const unsubscribeResize = modules_exports.useResize(() => {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      data.forEach((item) => {
        const { width, height, gutter: gutter2, numberOfColumn: numberOfColumn2 } = item;
        item.offsetXCenter = getOffsetXCenter({
          canvasWidth: canvas.width,
          width,
          gutter: gutter2,
          numberOfColumn: numberOfColumn2
        });
        item.offsetYCenter = getOffsetYCenter({
          canvasHeight: canvas.height,
          height,
          gutter: gutter2,
          numberOfRow
        });
      });
      modules_exports.useFrame(() => draw());
    });
    const unWatchPause = navigationStore.watch("navigationIsOpen", (val2) => {
      if (val2) {
        gridTimeline?.pause();
        isActive2 = false;
        return;
      }
      setTimeout(async () => {
        isActive2 = true;
        const currentRoute = modules_exports2.getActiveRoute();
        if (currentRoute.route !== activeRoute.route) return;
        gridTimeline?.resume();
        modules_exports.useFrame(() => loop());
      }, 500);
    });
    return () => {
      gridTween.destroy();
      gridTimeline.destroy();
      unsubscribeResize();
      unWatchPause();
      gridTween = null;
      gridTimeline = null;
      ctx = null;
      offscreen = null;
      offScreenCtx = null;
      gridData = [];
      data = [];
      isActive2 = false;
    };
  };

  // src/js/component/pages/animated-pattern/n0/animated-pattern-n0.js
  var AnimatedPatternN0Fn = ({
    onMount,
    getState,
    setRef,
    getRef,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    document.body.style.background = canvasBackground;
    onMount(() => {
      const { canvas } = getRef();
      const destroyAnimation = animatedPatternN0Animation({
        canvas,
        ...getState()
      });
      modules_exports.useFrame(() => {
        proxi.isMounted = true;
      });
      return () => {
        destroyAnimation();
        document.body.style.background = "";
      };
    });
    return renderHtml`
        <div>
            <div class="c-canvas">
                <div
                    class="c-canvas__wrap"
                    ${bindEffect({
      toggleClass: { active: () => proxi.isMounted }
    })}
                >
                    <canvas ${setRef("canvas")}></canvas>
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/pages/animated-pattern/n0/definition.js
  var AnimatedPatternN0 = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').AnimatedPatternN0>} */
    {
      tag: "animatedpattern-n0",
      component: AnimatedPatternN0Fn,
      exportState: [
        "numberOfRow",
        "numberOfColumn",
        "cellWidth",
        "cellHeight",
        "gutter",
        "fill",
        "stagger",
        "reorder",
        "disableOffcanvas"
      ],
      state: {
        isMounted: false,
        numberOfRow: () => ({
          value: 10,
          type: Number
        }),
        numberOfColumn: () => ({
          value: 10,
          type: Number
        }),
        cellWidth: () => ({
          value: window.innerHeight / 16,
          type: Number
        }),
        cellHeight: () => ({
          value: window.innerHeight / 16,
          type: Number
        }),
        gutter: () => ({
          value: 1,
          type: Number
        }),
        fill: () => ({
          value: [16, 27, 38, 49, 60, 71, 82, 93],
          type: Array
        }),
        stagger: () => ({
          value: {
            each: 5,
            grid: { col: 11, row: 11, direction: "row" },
            waitComplete: false
          },
          type: "any"
        }),
        reorder: () => ({
          value: true,
          type: Boolean
        }),
        disableOffcanvas: () => ({
          value: detectFirefox() || detectSafari() ? true : false,
          type: Boolean
        })
      }
    }
  );

  // src/js/pages/canvas/animated-pattern-n0/animated-pattern-n0-params.js
  var animatedPatternN0Params = [
    {
      animation: {},
      nav: {
        prevRoute: "#async-timeline",
        nextRoute: "#animatedPatternN0?version=1&activeId=1",
        backRoute: "#canvas-overview"
      }
    },
    {
      title: "Animated pattern N.0 v1",
      animation: {
        fill: [
          0,
          13,
          20,
          45,
          65,
          71,
          72,
          73,
          74,
          75,
          76,
          77,
          83,
          92,
          96,
          113,
          117,
          134,
          138,
          155,
          156,
          157,
          158,
          159,
          189,
          209
        ],
        gutter: 1,
        numberOfColumn: 20,
        numberOfRow: 10,
        cellWidth: window.innerHeight / 18,
        cellHeight: window.innerHeight / 18,
        stagger: {
          each: 2,
          from: "random",
          waitComplete: false
        },
        reorder: false
      },
      nav: {
        prevRoute: "#animatedPatternN0?version=0&activeId=0",
        nextRoute: "#animatedPatternN0?version=2&activeId=2",
        backRoute: "#canvas-overview"
      }
    },
    {
      animation: {
        fill: [
          0,
          13,
          20,
          45,
          65,
          71,
          72,
          73,
          74,
          75,
          76,
          77,
          83,
          92,
          96,
          113,
          117,
          134,
          138,
          155,
          156,
          157,
          158,
          159,
          189,
          209
        ],
        gutter: 1,
        numberOfColumn: 10,
        numberOfRow: 10,
        stagger: {
          each: 10,
          from: "edges",
          waitComplete: false
        },
        reorder: false
      },
      nav: {
        prevRoute: "#animatedPatternN0?version=1&activeId=1",
        nextRoute: "#animatedPatternN0?version=3&activeId=3",
        backRoute: "#canvas-overview"
      }
    },
    {
      title: "Animated pattern N.0 v3",
      animation: {
        fill: [],
        gutter: 1,
        numberOfColumn: 12,
        numberOfRow: 13,
        cellWidth: window.innerHeight / 22,
        cellHeight: window.innerHeight / 22,
        stagger: {
          each: 20,
          from: { x: 6, y: 6 },
          grid: {
            col: 13,
            row: 13,
            direction: "radial"
          },
          waitComplete: false
        },
        reorder: false
      },
      nav: {
        prevRoute: "#animatedPatternN0?version=2&activeId=2",
        nextRoute: "#animatedPatternN1",
        backRoute: "#canvas-overview"
      }
    }
  ];

  // src/js/pages/canvas/animated-pattern-n0/index.js
  modules_exports2.useComponent([AnimatedPatternN0]);
  var animatedPatternN0 = ({ params }) => {
    const { version } = params;
    const props = animatedPatternN0Params[Math.max(
      0,
      Math.min(Number(version), animatedPatternN0Params.length - 1)
    )];
    updateQuickNavState({
      active: true,
      prevRoute: props.nav.prevRoute,
      nextRoute: props.nav.nextRoute,
      backRoute: props.nav.backRoute,
      color: "black"
    });
    return renderHtml`<div class="l-padding">
        <animatedpattern-n0
            ${modules_exports2.staticProps(
      /** @type {import('@pagesComponent/animated-pattern/n0/type').AnimatedPatternN0['state']} */
      {
        ...props.animation
      }
    )}
        ></animatedpattern-n0>
    </div>`;
  };

  // src/js/component/pages/animated-pattern/n1/animation/animation.js
  var animatedPatternN1Animation = ({
    canvas,
    numberOfRow,
    numberOfColumn,
    cellWidth,
    cellHeight,
    gutter,
    fill,
    disableOffcanvas
  }) => {
    const { useOffscreen, context } = getCanvasContext({ disableOffcanvas });
    let isActive2 = true;
    let { top, left } = offset(canvas);
    let ctx = canvas.getContext(context, { alpha: false });
    const activeRoute = modules_exports2.getActiveRoute();
    let { offscreen, offScreenCtx } = getOffsetCanvas({ useOffscreen, canvas });
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    let gridData = createGrid({
      canvas,
      numberOfRow,
      numberOfColumn,
      cellWidth,
      cellHeight,
      gutter
    }).items;
    let data = gridData.map((item, i) => {
      return {
        ...item,
        scale: 0,
        mouseX: 0,
        mouseY: 0,
        hasFill: fill.includes(i)
      };
    }).sort((value) => value.hasFill ? -1 : 1);
    let centerTween = tween_exports.createLerp({
      data: { mouseX: 0, mouseY: 0 }
    });
    data.forEach((item) => {
      centerTween.subscribeCache(item, ({ mouseX, mouseY }) => {
        item.mouseX = mouseX;
        item.mouseY = mouseY;
      });
    });
    let gridTween = tween_exports.createTimeTween({
      ease: "easeInOutSine",
      stagger: {
        each: 5,
        from: "center",
        // grid: { col: 15, row: 7, direction: 'row' },
        waitComplete: false
      },
      data: { scale: 0 }
    });
    data.forEach((item) => {
      gridTween.subscribeCache(item, ({ scale }) => {
        item.scale = scale;
      });
    });
    const draw = () => {
      if (!ctx) return;
      if (useOffscreen && offscreen) {
        offscreen.width = canvas.width;
        offscreen.height = canvas.height;
      }
      const context2 = useOffscreen ? offScreenCtx : (
        /** @type {CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D} */
        ctx
      );
      if (!context2) return;
      canvas.width = canvas.width;
      context2.fillStyle = "#fff";
      context2.fillRect(0, 0, canvas.width, canvas.height);
      data.forEach(
        ({
          x,
          y,
          centerX,
          centerY,
          width,
          height,
          mouseX,
          mouseY,
          scale,
          hasFill,
          offsetXCenter,
          offsetYCenter
        }) => {
          const mouseXparsed = mouseX - (canvas.width - (width + gutter) * numberOfColumn) / 2;
          const mouseYparsed = mouseY - (canvas.height - (height + gutter) * numberOfRow) / 2;
          const xScale = (x - mouseXparsed) / 250;
          const yScale = (y - mouseYparsed) / 250;
          const delta = Math.sqrt(
            Math.pow(Math.abs(xScale), 2) + Math.pow(Math.abs(yScale), 2)
          );
          const scaleFactor = core_exports.clamp(Math.abs(delta), 0, 2);
          const rotation = 0;
          const xx = Math.cos(rotation) * (scaleFactor + scale);
          const xy = Math.sin(rotation) * (scaleFactor + scale);
          context2.setTransform(
            xx,
            xy,
            -xy,
            xx,
            Math.round(centerX + offsetXCenter),
            Math.round(centerY + offsetYCenter)
          );
          context2.beginPath();
          context2.rect(
            Math.round(-centerX + x),
            Math.round(-centerY + y),
            width,
            height
          );
          if (hasFill) {
            context2.fillStyle = `#000000`;
            context2.fill();
          } else {
            context2.fillStyle = `#ffff`;
            context2.fill();
          }
          context2.setTransform(1, 0, 0, 1, 0, 0);
        }
      );
      copyCanvasBitmap({ useOffscreen, offscreen, ctx });
    };
    let gridTimeline = timeline_exports.createAsyncTimeline({
      repeat: -1,
      yoyo: true,
      autoSet: false
    }).goTo(gridTween, { scale: 0.3 }, { duration: 1e3 });
    gridTimeline.play();
    const move3 = ({ x, y }) => {
      centerTween.goTo({ mouseX: x - left, mouseY: y - top }).catch(() => {
      });
    };
    const unsubscribeMouseMove = modules_exports.useMouseMove(({ client }) => {
      const { x, y } = client;
      move3({ x, y });
    });
    const unsubscribeTouchMove = modules_exports.useTouchMove(({ client }) => {
      const { x, y } = client;
      move3({ x, y });
    });
    const loop = () => {
      draw();
      if (!isActive2) return;
      modules_exports.useNextFrame(() => loop());
    };
    modules_exports.useFrame(() => {
      loop();
    });
    const unsubscribeResize = modules_exports.useResize(() => {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      top = offset(canvas).top;
      left = offset(canvas).left;
      data.forEach((item) => {
        const { width, height, gutter: gutter2, numberOfColumn: numberOfColumn2 } = item;
        item.offsetXCenter = getOffsetXCenter({
          canvasWidth: canvas.width,
          width,
          gutter: gutter2,
          numberOfColumn: numberOfColumn2
        });
        item.offsetYCenter = getOffsetYCenter({
          canvasHeight: canvas.height,
          height,
          gutter: gutter2,
          numberOfRow
        });
      });
      modules_exports.useFrame(() => draw());
    });
    const unWatchPause = navigationStore.watch("navigationIsOpen", (val2) => {
      if (val2) {
        gridTimeline?.stop();
        isActive2 = false;
        return;
      }
      setTimeout(async () => {
        isActive2 = true;
        const currentRoute = modules_exports2.getActiveRoute();
        if (currentRoute.route !== activeRoute.route) return;
        gridTimeline?.play();
        modules_exports.useFrame(() => loop());
      }, 500);
    });
    return () => {
      gridTween.destroy();
      gridTimeline.destroy();
      centerTween.destroy();
      unsubscribeResize();
      unsubscribeMouseMove();
      unsubscribeTouchMove();
      unWatchPause();
      gridTween = null;
      gridTimeline = null;
      centerTween = null;
      ctx = null;
      offscreen = null;
      offScreenCtx = null;
      gridData = [];
      data = [];
      isActive2 = false;
    };
  };

  // src/js/component/pages/animated-pattern/n1/animated-pattern-n1.js
  var AnimatedPatternN1Fn = ({
    onMount,
    getState,
    setRef,
    getRef,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    document.body.style.background = canvasBackground;
    onMount(() => {
      const { canvas } = getRef();
      const destroyAnimation = animatedPatternN1Animation({
        canvas,
        ...getState()
      });
      modules_exports.useFrame(() => {
        proxi.isMounted = true;
      });
      return () => {
        document.body.style.background = "";
        destroyAnimation();
      };
    });
    return renderHtml`
        <div>
            <div class="c-canvas">
                <div
                    class="c-canvas__wrap"
                    ${bindEffect({
      toggleClass: { active: () => proxi.isMounted }
    })}
                >
                    <canvas ${setRef("canvas")}></canvas>
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/pages/animated-pattern/n1/definition.js
  var AnimatedPatternN1 = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').AnimatedPatternN1>} */
    {
      tag: "animatedpattern-n1",
      component: AnimatedPatternN1Fn,
      exportState: [
        "numberOfRow",
        "numberOfColumn",
        "cellWidth",
        "cellHeight",
        "gutter",
        "fill",
        "disableOffcanvas"
      ],
      state: {
        isMounted: false,
        numberOfRow: 7,
        numberOfColumn: 15,
        cellWidth: window.innerHeight / 13,
        cellHeight: window.innerHeight / 13,
        gutter: window.innerHeight / 150,
        fill: [
          2,
          18,
          10,
          27,
          21,
          22,
          23,
          24,
          25,
          25,
          26,
          37,
          42,
          53,
          58,
          69,
          74,
          85,
          86,
          87,
          88,
          89,
          90,
          44,
          60,
          65,
          66
        ],
        disableOffcanvas: () => ({
          value: detectFirefox() || detectSafari() ? true : false,
          type: Boolean
        })
      }
    }
  );

  // src/js/pages/canvas/animate-pattern-n1/index.js
  modules_exports2.useComponent([AnimatedPatternN1]);
  var animatedPatternN1 = () => {
    updateQuickNavState({
      active: true,
      prevRoute: "#animatedPatternN0?version=3&activeId=3",
      nextRoute: "#scrollerN0?version=0&activeId=0",
      backRoute: "#canvas-overview",
      color: "black"
    });
    return renderHtml`<div class="l-padding">
        <animatedpattern-n1></animatedpattern-n1>
    </div>`;
  };

  // src/js/component/pages/canvas/n0/animation/animation.js
  function getWithRounded({ width, relativeIndex, amountOfPath }) {
    return Math.sqrt(
      Math.pow(width * relativeIndex, 2) - Math.pow(
        width * relativeIndex / amountOfPath * relativeIndex,
        2
      )
    ) * 2;
  }
  function getHeightRounded({ height, relativeIndex, amountOfPath }) {
    return Math.sqrt(
      Math.pow(height * relativeIndex, 2) - Math.pow(
        height * relativeIndex / amountOfPath * relativeIndex,
        2
      )
    ) * 2;
  }
  var caterpillarN0Animation = ({
    canvas,
    amountOfPath,
    width,
    height,
    fill,
    stroke,
    opacity,
    spacerY,
    intialRotation,
    perpetualRatio,
    mouseMoveRatio,
    disableOffcanvas
  }) => {
    const { useOffscreen, context } = getCanvasContext({ disableOffcanvas });
    let isActive2 = true;
    let ctx = canvas.getContext(context, { alpha: true });
    let { left } = offset(canvas);
    const activeRoute = modules_exports2.getActiveRoute();
    let { offscreen, offScreenCtx } = getOffsetCanvas({ useOffscreen, canvas });
    const useRadius = false;
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    let stemData = [...Array.from({ length: amountOfPath }).keys()].map(
      (_item, i) => {
        const count = i;
        const index = count < amountOfPath / 2 ? amountOfPath - count : count;
        const relativeIndex = index - (amountOfPath - index);
        return {
          width: Math.floor(
            getWithRounded({ width, relativeIndex, amountOfPath })
          ),
          height: Math.floor(
            getHeightRounded({ height, relativeIndex, amountOfPath })
          ),
          fill,
          stroke,
          opacity: relativeIndex * opacity,
          rotate: 0,
          y: 0,
          relativeIndex,
          index: i
        };
      }
    );
    let steamDataReorded = stemData.splice(0, stemData.length / 2).concat(stemData.reverse());
    let mainTween = tween_exports.createSpring({
      data: { rotate: 0, y: 0 },
      stagger: { each: 5, from: "center" }
    });
    [...steamDataReorded].forEach((item) => {
      mainTween.subscribeCache(item, ({ rotate }) => {
        item.rotate = rotate;
      });
    });
    const draw = ({ time: time2 = 0 }) => {
      if (!ctx) return;
      if (useOffscreen && offscreen) {
        offscreen.width = canvas.width;
        offscreen.height = canvas.height;
      }
      const context2 = useOffscreen ? offScreenCtx : (
        /** @type {CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D} */
        ctx
      );
      if (!context2) return;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      canvas.width = canvas.width;
      steamDataReorded.forEach(
        ({ width: width2, height: height2, opacity: opacity2, rotate, relativeIndex, index: i }) => {
          const offset2 = Math.sin(time2 / 1e3) * perpetualRatio * relativeIndex;
          const offsetInverse = i < amountOfPath / 2 ? offset2 + 15 * relativeIndex / 2 : -offset2 - 15 * relativeIndex / 2;
          const centerDirection = i < amountOfPath / 2 ? -1 : 1;
          const scale = 1;
          const rotation = Math.PI / 180 * (rotate - intialRotation);
          const xx = Math.cos(rotation) * scale;
          const xy = Math.sin(rotation) * scale;
          context2.setTransform(
            xx,
            xy,
            -xy,
            xx,
            centerX,
            centerY + height2 / 2
          );
          if (useRadius) {
            context2.beginPath();
            context2.roundRect(
              -(width2 * centerDirection) / 2,
              -height2 / 2 + offsetInverse + spacerY(i < amountOfPath / 2),
              width2,
              height2,
              [200, 0]
            );
          } else {
            context2.beginPath();
            context2.rect(
              -(width2 * centerDirection) / 2,
              -height2 / 2 + offsetInverse + spacerY(i < amountOfPath / 2),
              width2,
              height2
            );
          }
          context2.strokeStyle = `rgba(0, 0, 0, ${opacity2})`;
          context2.fillStyle = `rgba(238, 238, 238, 0)`;
          context2.stroke();
          context2.fill();
          context2.setTransform(1, 0, 0, 1, 0, 0);
        }
      );
      copyCanvasBitmap({ useOffscreen, offscreen, ctx });
    };
    const loop = ({ time: time2 = 0 }) => {
      draw({ time: time2 });
      if (!isActive2) return;
      modules_exports.useNextFrame(({ time: time3 }) => loop({ time: time3 }));
    };
    modules_exports.useFrame(({ time: time2 }) => {
      loop({ time: time2 });
    });
    const unsubscribeResize = modules_exports.useResize(() => {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      left = offset(canvas).left;
      modules_exports.useFrame(({ time: time2 }) => {
        draw({ time: time2 });
      });
    });
    const move3 = ({ x }) => {
      const xCenter = x - canvas.width / 2 - left;
      mainTween.goTo({
        rotate: xCenter / mouseMoveRatio
      }).catch(() => {
      });
    };
    const unsubscribeMouseMove = modules_exports.useMouseMove(({ client }) => {
      const { x } = client;
      move3({ x });
    });
    const unsubscribeTouchMove = modules_exports.useTouchMove(({ client }) => {
      const { x } = client;
      move3({ x });
    });
    const unWatchPause = navigationStore.watch("navigationIsOpen", (val2) => {
      if (val2) {
        mainTween?.pause();
        isActive2 = false;
        return;
      }
      setTimeout(() => {
        isActive2 = true;
        mainTween?.resume();
        const currentRoute = modules_exports2.getActiveRoute();
        if (currentRoute.route !== activeRoute.route) return;
        modules_exports.useFrame(({ time: time2 }) => loop({ time: time2 }));
      }, 500);
    });
    return () => {
      mainTween.destroy();
      unsubscribeResize();
      unsubscribeMouseMove();
      unsubscribeTouchMove();
      unWatchPause();
      ctx = null;
      offscreen = null;
      offScreenCtx = null;
      mainTween = null;
      steamDataReorded = [];
      stemData = [];
      isActive2 = false;
    };
  };

  // src/js/component/pages/canvas/n0/caterpillar-n0.js
  var CaterpillarN0Fn = ({
    onMount,
    setRef,
    getRef,
    getState,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    document.body.style.background = canvasBackground;
    onMount(() => {
      const { canvas } = getRef();
      const destroyAnimation = caterpillarN0Animation({
        canvas,
        ...getState()
      });
      modules_exports.useFrame(() => {
        proxi.isMounted = true;
      });
      return () => {
        destroyAnimation();
        document.body.style.background = "";
      };
    });
    return renderHtml`
        <div>
            <div class="c-canvas">
                <div
                    class="c-canvas__wrap"
                    ${bindEffect({
      toggleClass: { active: () => proxi.isMounted }
    })}
                >
                    <canvas ${setRef("canvas")}></canvas>
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/pages/canvas/n0/definition.js
  var CaterpillarN0 = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').CaterpillarN0>} */
    {
      tag: "caterpillar-n0",
      component: CaterpillarN0Fn,
      exportState: [
        "nextRoute",
        "prevRoute",
        "amountOfPath",
        "width",
        "height",
        "radius",
        "fill",
        "stroke",
        "opacity",
        "spacerY",
        "intialRotation",
        "perpetualRatio",
        "mouseMoveRatio",
        "disableOffcanvas"
      ],
      state: {
        isMounted: false,
        nextRoute: () => ({
          value: "",
          type: String
        }),
        prevRoute: () => ({
          value: "",
          type: String
        }),
        amountOfPath: 17,
        width: window.innerHeight / 30,
        height: window.innerHeight / 30,
        radius: 0,
        fill: [-1],
        stroke: "#000",
        opacity: 0.05,
        spacerY: (condition) => condition ? 300 : -400,
        intialRotation: 33,
        perpetualRatio: 6,
        mouseMoveRatio: 10,
        disableOffcanvas: () => ({
          value: detectFirefox() || detectSafari() ? true : false,
          type: Boolean
        })
      }
    }
  );

  // src/js/pages/canvas/caterpillar-n0/index.js
  modules_exports2.useComponent([CaterpillarN0]);
  var caterpillarN0 = () => {
    updateQuickNavState({
      active: true,
      prevRoute: "",
      nextRoute: "#caterpillarN1",
      backRoute: "#canvas-overview",
      color: "black"
    });
    return renderHtml`<div class="l-padding">
        <caterpillar-n0></caterpillar-n0>
    </div>`;
  };

  // src/js/component/pages/canvas/n1/animation/animation.js
  var caterpillarN1Animation = ({
    canvas,
    numItems,
    width,
    height,
    fill,
    opacity,
    radius,
    rotationDuration,
    rotationEach,
    centerEach,
    disableOffcanvas
  }) => {
    const { useOffscreen, context } = getCanvasContext({ disableOffcanvas });
    let isActive2 = true;
    let ctx = canvas.getContext(context, { alpha: true });
    let { top, left } = offset(canvas);
    const activeRoute = modules_exports2.getActiveRoute();
    let { offscreen, offScreenCtx } = getOffsetCanvas({ useOffscreen, canvas });
    const useRadius = true;
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    let squareData = [...Array.from({ length: numItems }).keys()].map(
      (_item, i) => {
        const relativeIndex = i >= numItems / 2 ? numItems / 2 + (numItems / 2 - i) : i;
        const opacityVal = fill.includes(i) ? 1 : relativeIndex * opacity;
        return {
          width: relativeIndex * width,
          height: relativeIndex * height,
          x: 0,
          y: 0,
          hasFill: fill.includes(i),
          opacity: opacityVal,
          radius,
          rotate: 0,
          relativeIndex
        };
      }
    );
    let rotationTween = tween_exports.createTimeTween({
      data: { rotate: 0 },
      stagger: { each: rotationEach, from: "center" },
      ease: "easeLinear",
      relative: true
    });
    [...squareData].forEach((item) => {
      rotationTween.subscribeCache(item, ({ rotate }) => {
        item.rotate = rotate;
      });
    });
    let centerTween = tween_exports.createSpring({
      data: { x: 0, y: 0 },
      stagger: { each: centerEach, from: "end" }
    });
    [...squareData].forEach((item) => {
      centerTween.subscribeCache(item, ({ x, y }) => {
        item.x = x;
        item.y = y;
      });
    });
    const draw = () => {
      if (!ctx) return;
      if (useOffscreen && offscreen) {
        offscreen.width = canvas.width;
        offscreen.height = canvas.height;
      }
      const context2 = useOffscreen ? offScreenCtx : (
        /** @type {CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D} */
        ctx
      );
      if (!context2) return;
      canvas.width = canvas.width;
      squareData.forEach(({ width: width2, height: height2, x, y, rotate, hasFill }, i) => {
        const unitInverse = squareData.length - i;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 1;
        const rotation = Math.PI / 180 * rotate;
        const xx = Math.cos(rotation) * scale;
        const xy = Math.sin(rotation) * scale;
        context2.setTransform(
          xx,
          xy,
          -xy,
          xx,
          centerX + x + unitInverse * x / 20,
          centerY + y + unitInverse * y / 20
        );
        if (useRadius) {
          context2.beginPath();
          context2.roundRect(
            Math.round(-width2 / 2),
            Math.round(-height2 / 2),
            width2,
            height2,
            [40, 40]
          );
        } else {
          context2.beginPath();
          context2.rect(
            Math.round(-width2 / 2),
            Math.round(-height2 / 2),
            width2,
            height2
          );
        }
        if (hasFill) {
          context2.fillStyle = "#a86464";
        } else {
          context2.strokeStyle = `#000`;
          context2.fillStyle = `rgba(238, 238, 238, 0.9)`;
          context2.stroke();
        }
        context2.fill();
        context2.setTransform(1, 0, 0, 1, 0, 0);
      });
      copyCanvasBitmap({ useOffscreen, offscreen, ctx });
    };
    let rectTimeline = timeline_exports.createAsyncTimeline({
      repeat: -1,
      yoyo: false,
      autoSet: false
    });
    rectTimeline.goTo(
      rotationTween,
      { rotate: 360 },
      { duration: rotationDuration }
    );
    rectTimeline.play();
    const loop = () => {
      draw();
      if (!isActive2) return;
      modules_exports.useNextFrame(() => loop());
    };
    modules_exports.useFrame(() => loop());
    const unsubscribeResize = modules_exports.useResize(() => {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      top = offset(canvas).top;
      left = offset(canvas).left;
      draw();
    });
    const move3 = ({ x, y }) => {
      const winWidth = window.innerWidth;
      const winHeight = window.innerHeight;
      const xCenter = x - canvas.width / 2 - left;
      const yCenter = y - canvas.height / 2 - top;
      centerTween.goTo({
        x: core_exports.clamp(
          xCenter,
          -winWidth / 2 + 400 + left,
          winWidth / 2 - 400 - left
        ),
        y: core_exports.clamp(
          yCenter,
          -winHeight / 2 + 200 + top,
          winHeight / 2 - 200 - top
        )
      }).catch(() => {
      });
    };
    const unsubscribeMouseMove = modules_exports.useMouseMove(({ client }) => {
      const { x, y } = client;
      move3({ x, y });
    });
    const unsubscribeTouchMove = modules_exports.useTouchMove(({ client }) => {
      const { x, y } = client;
      move3({ x, y });
    });
    const unWatchPause = navigationStore.watch("navigationIsOpen", (val2) => {
      if (val2) {
        isActive2 = false;
        rectTimeline?.pause();
        rotationTween?.pause();
        centerTween?.pause();
        return;
      }
      setTimeout(() => {
        isActive2 = true;
        const currentRoute = modules_exports2.getActiveRoute();
        if (currentRoute.route !== activeRoute.route) return;
        rectTimeline?.resume();
        rotationTween?.resume();
        centerTween?.resume();
        modules_exports.useFrame(() => loop());
      }, 500);
    });
    return () => {
      rotationTween.destroy();
      centerTween.destroy();
      rectTimeline.destroy();
      unsubscribeResize();
      unsubscribeMouseMove();
      unsubscribeTouchMove();
      unWatchPause();
      rotationTween = null;
      centerTween = null;
      rectTimeline = null;
      ctx = null;
      offscreen = null;
      offScreenCtx = null;
      squareData = [];
      isActive2 = false;
    };
  };

  // src/js/component/pages/canvas/n1/caterpillar-n1.js
  var CaterpillarN1Fn = ({
    onMount,
    getState,
    getRef,
    setRef,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    document.body.style.background = canvasBackground;
    onMount(() => {
      const { canvas } = getRef();
      const destroyAnimation = caterpillarN1Animation({
        canvas,
        ...getState()
      });
      modules_exports.useFrame(() => {
        proxi.isMounted = true;
      });
      return () => {
        destroyAnimation();
        document.body.style.background = "";
      };
    });
    return renderHtml`
        <div>
            <div class="c-canvas">
                <div
                    class="c-canvas__wrap"
                    ${bindEffect({
      toggleClass: { active: () => proxi.isMounted }
    })}
                >
                    <canvas ${setRef("canvas")}></canvas>
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/pages/canvas/n1/definition.js
  var CaterpillarN1 = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').CaterpillarN1>} */
    {
      tag: "caterpillar-n1",
      component: CaterpillarN1Fn,
      exportState: [
        "numItems",
        "width",
        "height",
        "fill",
        "opacity",
        "radius",
        "rotationEach",
        "centerEach",
        "rotationDuration",
        "disableOffcanvas"
      ],
      state: {
        isMounted: false,
        numItems: 20,
        width: window.innerHeight / 30,
        height: window.innerHeight / 30,
        fill: [14],
        opacity: 0.05,
        radius: 0,
        rotationEach: 15,
        centerEach: 3,
        rotationDuration: 5e3,
        disableOffcanvas: () => ({
          value: detectFirefox() || detectSafari() ? true : false,
          type: Boolean
        })
      }
    }
  );

  // src/js/pages/canvas/caterpillar-n1/index.js
  modules_exports2.useComponent([CaterpillarN1]);
  var caterpillarN1 = () => {
    updateQuickNavState({
      active: true,
      prevRoute: "#caterpillarN0",
      nextRoute: "#caterpillarN2",
      backRoute: "#canvas-overview",
      color: "black"
    });
    return renderHtml`<div class="l-padding">
        <caterpillar-n1></caterpillar-n1>
    </div>`;
  };

  // src/js/component/pages/canvas/n2/animation/animation.js
  var logAddMethods = ({ value, direction: direction2, isForced }) => {
    if (isForced) return;
    console.log(`current: ${value}, direction: ${direction2}`);
  };
  var caterpillarN2Animation = ({
    canvas,
    numItems,
    width,
    height,
    radius,
    fill,
    opacity,
    xAmplitude,
    yAmplitude,
    duration: duration2,
    friction,
    rotationDefault,
    disableOffcanvas
  }) => {
    const { useOffscreen, context } = getCanvasContext({ disableOffcanvas });
    let isActive2 = true;
    let ctx = canvas.getContext(context, { alpha: true });
    let userRotation = rotationDefault;
    const activeRoute = modules_exports2.getActiveRoute();
    let { offscreen, offScreenCtx } = getOffsetCanvas({ useOffscreen, canvas });
    const useRadius = true;
    let squareData = [...Array.from({ length: numItems }).keys()].map(
      (_item, i) => {
        const relativeIndex = i >= numItems / 2 ? numItems / 2 + (numItems / 2 - i) : i;
        const itemWidth = width + width / 3 * relativeIndex;
        const itemHeight = height + height / 3 * relativeIndex;
        const opacityVal = fill.includes(i) ? 1 : (numItems - i) * opacity;
        return {
          width: itemWidth,
          height: itemHeight,
          x: 0,
          y: 0,
          hasFill: fill.includes(i),
          opacity: opacityVal,
          radius,
          rotate: 0
        };
      }
    );
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    let infiniteTween = tween_exports.createSequencer({
      stagger: { each: 6 },
      data: { x: duration2 / 4, rotate: 0 },
      duration: duration2
    }).goTo(
      { x: duration2 + duration2 / 4 },
      { start: 0, end: duration2, ease: "easeLinear" }
    ).goTo(
      { rotate: () => -userRotation },
      { start: 0, end: 5, ease: "easeInOutBack" }
    ).goTo({ rotate: 0 }, { start: 5, end: duration2, ease: "easeInOutBack" }).label("mylabel", 2).add(({ isForced, direction: direction2 }) => {
      logAddMethods({ isForced, direction: direction2, value: 1 });
    }, 1).add(({ isForced, direction: direction2 }) => {
      logAddMethods({ isForced, direction: direction2, value: 5 });
    }, 5).add(({ isForced, direction: direction2 }) => {
      logAddMethods({ isForced, direction: direction2, value: 9 });
    }, 9);
    squareData.forEach((item) => {
      infiniteTween.subscribeCache(item, ({ x, rotate }) => {
        const val2 = x / friction;
        const factor = 2 / (3 - Math.cos(2 * val2));
        const xr = factor * Math.cos(val2) * xAmplitude;
        const yr = factor * Math.sin(2 * val2) / 2 * yAmplitude;
        item.x = xr;
        item.y = yr;
        item.rotate = rotate;
      });
    });
    let syncTimeline = timeline_exports.createSyncTimeline({
      repeat: -1,
      yoyo: false,
      duration: 4e3
    }).add(infiniteTween);
    syncTimeline.onLoopEnd(({ loop: loop2, direction: direction2 }) => {
      console.log(`loop end: ${loop2} , ${direction2}`);
    });
    const draw = () => {
      if (!ctx) return;
      if (useOffscreen && offscreen) {
        offscreen.width = canvas.width;
        offscreen.height = canvas.height;
      }
      const context2 = useOffscreen ? offScreenCtx : (
        /** @type {CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D} */
        ctx
      );
      if (!context2) return;
      canvas.width = canvas.width;
      squareData.forEach(({ width: width2, height: height2, x, y, rotate, hasFill }) => {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 1;
        const rotation = Math.PI / 180 * rotate;
        const xx = Math.cos(rotation) * scale;
        const xy = Math.sin(rotation) * scale;
        context2.setTransform(xx, xy, -xy, xx, centerX + x, centerY + y);
        if (useRadius) {
          context2.beginPath();
          context2.roundRect(
            Math.round(-width2 / 2),
            Math.round(-height2 / 2),
            width2,
            height2,
            [40, 40]
          );
        } else {
          context2.beginPath();
          context2.rect(
            Math.round(-width2 / 2),
            Math.round(-height2 / 2),
            width2,
            height2
          );
        }
        if (hasFill) {
          context2.fillStyle = `#000000`;
        } else {
          context2.strokeStyle = `#000`;
          context2.fillStyle = `rgba(238, 238, 238, 0.9)`;
          context2.stroke();
        }
        context2.fill();
        context2.setTransform(1, 0, 0, 1, 0, 0);
      });
      copyCanvasBitmap({ useOffscreen, offscreen, ctx });
    };
    const loop = () => {
      draw();
      if (!isActive2) return;
      modules_exports.useNextFrame(() => loop());
    };
    modules_exports.useFrame(() => loop());
    syncTimeline.play();
    const unsubscribeResize = modules_exports.useResize(() => {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      draw();
    });
    const unWatchPause = navigationStore.watch("navigationIsOpen", (val2) => {
      if (val2) {
        isActive2 = false;
        syncTimeline?.pause();
        return;
      }
      setTimeout(() => {
        isActive2 = true;
        const currentRoute = modules_exports2.getActiveRoute();
        if (currentRoute.route !== activeRoute.route) return;
        syncTimeline?.resume();
        modules_exports.useFrame(() => loop());
      }, 500);
    });
    return {
      destroy: () => {
        isActive2 = false;
        unsubscribeResize();
        unWatchPause();
        infiniteTween.destroy();
        infiniteTween = null;
        syncTimeline.destroy();
        syncTimeline = null;
        ctx = null;
        offscreen = null;
        offScreenCtx = null;
        squareData = [];
      },
      play: () => {
        syncTimeline.play();
      },
      playReverse: () => {
        syncTimeline.playReverse();
      },
      playUseCurrent: () => syncTimeline.play({ useCurrent: true }),
      playReverseUseCurrent: () => syncTimeline.playReverse({ useCurrent: true }),
      playFromLabel: () => {
        syncTimeline.playFrom("mylabel");
      },
      plaFromLabelReverse: () => {
        syncTimeline.playFromReverse("mylabel");
      },
      stop: () => syncTimeline.stop(),
      pause: () => syncTimeline.pause(),
      resume: () => syncTimeline.resume(),
      reverse: () => syncTimeline.reverse(),
      setRotation: (value) => userRotation = value
    };
  };

  // src/js/component/pages/canvas/n2/caterpillar-n2.js
  function getControls({ buttons: buttons5 }) {
    return Object.entries(buttons5).map(([className, value]) => {
      const { label } = value;
      return renderHtml` <li class="c-canvas__controls__item">
                <button
                    type="button"
                    class="c-canvas__controls__btn ${className}"
                >
                    ${label}
                </button>
            </li>`;
    }).join("");
  }
  var CaterpillarN2Fn = ({
    onMount,
    getState,
    setRef,
    getRef,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    document.body.style.background = canvasBackground;
    onMount(({ element }) => {
      const { canvas, rangeValue, rotationButton } = getRef();
      const animationMethods = caterpillarN2Animation({
        canvas,
        ...getState()
      });
      const { destroy: destroy3, setRotation } = animationMethods;
      Object.entries(proxi.buttons).forEach(([className, value]) => {
        const { method } = value;
        const btn = element.querySelector(`.${className}`);
        btn?.addEventListener("click", () => animationMethods?.[method]());
      });
      rotationButton.addEventListener("change", () => {
        const value = rotationButton.value;
        setRotation(Number(value));
        rangeValue.textContent = value;
      });
      modules_exports.useFrame(() => {
        proxi.isMounted = true;
      });
      return () => {
        document.body.style.background = "";
        destroy3();
      };
    });
    return renderHtml`
        <div>
            <div class="c-canvas">
                <div
                    class="c-canvas__wrap"
                    ${bindEffect({
      toggleClass: { active: () => proxi.isMounted }
    })}
                >
                    <ul class="c-canvas__controls">
                        ${getControls({ buttons: proxi.buttons })}
                        <li class="c-canvas__controls__item is-like-button">
                            <label class="c-canvas__controls__label">
                                deg:
                                <span
                                    class="js-range-value"
                                    ${setRef("rangeValue")}
                                    >${proxi.rotationDefault}</span
                                >
                            </label>
                            <div class="c-canvas__controls__range">
                                <input
                                    type="range"
                                    min="0"
                                    max="720"
                                    value="${proxi.rotationDefault}"
                                    step="1"
                                    ${setRef("rotationButton")}
                                />
                            </div>
                        </li>
                    </ul>
                    <canvas ${setRef("canvas")}></canvas>
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/pages/canvas/n2/definition.js
  var duration = 10;
  var buttons = {
    "js-CN2-play": {
      label: "play",
      method: "play"
    },
    "js-CN2-playReverse": {
      label: "play reverse",
      method: "playReverse"
    },
    "js-CN2-play-current": {
      label: "go forward if is backward",
      method: "playUseCurrent"
    },
    "js-CN2-playReverse-current": {
      label: "go backward if is forward",
      method: "playReverseUseCurrent"
    },
    "js-CN2-play-label": {
      label: "play from label",
      method: "playFromLabel"
    },
    "js-CN2-playReverse-label": {
      label: "play from label reverse",
      method: "plaFromLabelReverse"
    },
    "js-CN2-reverse": {
      label: "reverse",
      method: "reverse"
    },
    "js-CN2-stop": {
      label: "stop",
      method: "stop"
    },
    "js-CN2-pause": {
      label: "pause",
      method: "pause"
    },
    "js-CN2-resume": {
      label: "resume",
      method: "resume"
    }
  };
  var CaterpillarN2 = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').CaterpillarN2>} */
    {
      tag: "caterpillar-n2",
      component: CaterpillarN2Fn,
      exportState: [
        "numItems",
        "width",
        "height",
        "radius",
        "fill",
        "opacity",
        "xAmplitude",
        "yAmplitude",
        "duration",
        "rotationDefault",
        "friction",
        "disableOffcanvas"
      ],
      state: {
        isMounted: false,
        numItems: 20,
        width: window.innerHeight / 13,
        height: window.innerHeight / 13,
        radius: 0,
        fill: [2],
        opacity: 0.02,
        xAmplitude: 500,
        yAmplitude: 400,
        duration: 10,
        rotationDefault: 360,
        friction: duration / 2 / Math.PI,
        disableOffcanvas: () => ({
          value: detectFirefox() || detectSafari() ? true : false,
          type: Boolean
        }),
        buttons: () => ({
          value: buttons,
          type: "Any"
        })
      }
    }
  );

  // src/js/pages/canvas/caterpillar-n2/index.js
  modules_exports2.useComponent([CaterpillarN2]);
  var caterpillarN2 = () => {
    updateQuickNavState({
      active: true,
      prevRoute: "#caterpillarN1",
      nextRoute: "#async-timeline",
      backRoute: "#canvas-overview",
      color: "black"
    });
    return renderHtml`<div class="l-padding">
        <caterpillar-n2></caterpillar-n2>
    </div>`;
  };

  // src/js/component/common/scroll-down-label/utils.js
  var activateScrollDownArrow = () => {
    const setScrollDownState = modules_exports2.setStateByName(scrollDownLabelName);
    setScrollDownState("active", true);
  };
  var deactivateScrollDownArrow = () => {
    const setScrollDownState = modules_exports2.setStateByName(scrollDownLabelName);
    setScrollDownState("active", false);
  };

  // src/js/component/pages/scroller/n0/animation/animation.js
  var scrollerN0Animation = ({
    canvas,
    canvasScroller,
    numberOfRow,
    numberOfColumn,
    cellWidth,
    cellHeight,
    gutter,
    fill,
    stagger,
    reorder,
    disableOffcanvas
  }) => {
    const { useOffscreen, context } = getCanvasContext({ disableOffcanvas });
    let isActive2 = true;
    let masterSequencer = tween_exports.createMasterSequencer();
    let ctx = canvas.getContext(context, { alpha: true });
    const activeRoute = modules_exports2.getActiveRoute();
    let { offscreen, offScreenCtx } = getOffsetCanvas({ useOffscreen, canvas });
    let wichContext = useOffscreen ? offScreenCtx : ctx;
    const useRadius = roundRectIsSupported(
      /** @type {CanvasRenderingContext2D} */
      wichContext
    );
    wichContext = null;
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    let gridData = createGrid({
      canvas,
      numberOfRow,
      numberOfColumn,
      cellWidth,
      cellHeight,
      gutter
    }).items;
    let data = reorder ? gridData.map((item, i) => {
      return {
        ...item,
        scale: 0,
        rotate: 0,
        hasFill: fill.includes(i)
      };
    }).sort((value) => value.hasFill ? -1 : 1) : gridData.map((item, i) => {
      return {
        ...item,
        scale: 0,
        rotate: 0,
        hasFill: fill.includes(i)
      };
    });
    let staggers = tween_exports.createStaggers({
      items: data,
      stagger
    });
    let sequencersInstances = staggers.map(({ item, start, end }) => {
      const scale = item.hasFill ? 1.1 : 1;
      const sequencer = tween_exports.createSequencer({ data: { scale: 0 } }).goTo(
        { scale },
        { start, end, ease: "easeInOutQuad" }
      );
      const unsubscribe3 = sequencer.subscribe(({ scale: scale2 }) => {
        item.scale = scale2;
      });
      masterSequencer.add(sequencer);
      return { sequencer, unsubscribe: unsubscribe3 };
    });
    const draw = () => {
      if (!ctx) return;
      if (useOffscreen && offscreen) {
        offscreen.width = canvas.width;
        offscreen.height = canvas.height;
      }
      const context2 = useOffscreen ? offScreenCtx : (
        /** @type {CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D} */
        ctx
      );
      if (!context2) return;
      canvas.width = canvas.width;
      data.forEach(
        ({
          x,
          y,
          centerX,
          centerY,
          width,
          height,
          rotate,
          scale,
          hasFill,
          offsetXCenter,
          offsetYCenter
        }) => {
          const rotation = Math.PI / 180 * rotate;
          const xx = Math.cos(rotation) * scale;
          const xy = Math.sin(rotation) * scale;
          context2.setTransform(
            xx,
            xy,
            -xy,
            xx,
            Math.round(centerX + offsetXCenter),
            Math.round(centerY + offsetYCenter)
          );
          roundRectCustom(
            /** @type {CanvasRenderingContext2D} */
            context2,
            Math.round(-centerX + x),
            Math.round(-centerY + y),
            width,
            height,
            5
          );
          if (useRadius) {
            context2.beginPath();
            context2.roundRect(
              Math.round(-centerX + x),
              Math.round(-centerY + y),
              width,
              height,
              5
            );
          } else {
            context2.beginPath();
            context2.rect(
              Math.round(-centerX + x),
              Math.round(-centerY + y),
              width,
              height
            );
          }
          if (hasFill) {
            context2.fillStyle = `#000000`;
            context2.fill();
          } else {
            context2.strokeStyle = `#000`;
            context2.fillStyle = `rgba(238, 238, 238, 0.9)`;
            context2.stroke();
            context2.fill();
            if (!useRadius) {
              context2.strokeStyle = "#ccc";
              context2.stroke();
            }
          }
          context2.setTransform(1, 0, 0, 1, 0, 0);
        }
      );
      copyCanvasBitmap({ useOffscreen, offscreen, ctx });
    };
    let scrollerInstance = scroller_exports.createScrollTrigger({
      trigger: canvasScroller,
      propierties: "tween",
      tween: masterSequencer,
      dynamicStart: {
        position: "bottom",
        value: () => window.innerHeight
      },
      dynamicEnd: {
        position: "bottom",
        value: () => outerHeight(canvasScroller)
      },
      reverse: true,
      ease: true,
      easeType: "lerp"
    });
    scrollerInstance.init();
    const loop = () => {
      draw();
      if (!isActive2) return;
      modules_exports.useNextFrame(() => loop());
    };
    modules_exports.useFrame(() => {
      loop();
    });
    const unsubscribeResize = modules_exports.useResize(() => {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      data.forEach((item) => {
        const { width, height, gutter: gutter2, numberOfColumn: numberOfColumn2 } = item;
        item.offsetXCenter = getOffsetXCenter({
          canvasWidth: canvas.width,
          width,
          gutter: gutter2,
          numberOfColumn: numberOfColumn2
        });
        item.offsetYCenter = getOffsetYCenter({
          canvasHeight: canvas.height,
          height,
          gutter: gutter2,
          numberOfRow
        });
      });
      modules_exports.useFrame(() => draw());
    });
    const unWatchPause = navigationStore.watch("navigationIsOpen", (val2) => {
      if (val2) {
        isActive2 = false;
        return;
      }
      setTimeout(async () => {
        isActive2 = true;
        const currentRoute = modules_exports2.getActiveRoute();
        if (currentRoute.route !== activeRoute.route) return;
        modules_exports.useFrame(() => loop());
      }, 500);
    });
    return () => {
      unsubscribeResize();
      unWatchPause();
      sequencersInstances.forEach(({ sequencer, unsubscribe: unsubscribe3 }) => {
        sequencer.destroy();
        unsubscribe3();
      });
      sequencersInstances = [];
      masterSequencer.destroy();
      masterSequencer = null;
      staggers = [];
      scrollerInstance.destroy();
      scrollerInstance = null;
      ctx = null;
      offscreen = null;
      offScreenCtx = null;
      gridData = [];
      data = [];
      isActive2 = false;
    };
  };

  // src/js/component/pages/scroller/n0/scroller-n0.js
  var ScrollerN0Fn = ({
    onMount,
    getState,
    setRef,
    getRef,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    document.body.style.background = canvasBackground;
    onMount(() => {
      activateScrollDownArrow();
      const { canvas, canvasScroller } = getRef();
      window.scrollTo(0, 0);
      const destroyAnimation = scrollerN0Animation({
        canvas,
        canvasScroller,
        ...getState()
      });
      modules_exports.useFrame(() => {
        proxi.isMounted = true;
      });
      return () => {
        destroyAnimation();
        deactivateScrollDownArrow();
        document.body.style.background = "";
      };
    });
    return renderHtml`
        <div>
            <div class="c-canvas c-canvas--fixed ">
                <div
                    class="c-canvas__wrap"
                    ${bindEffect({
      toggleClass: { active: () => proxi.isMounted }
    })}
                >
                    <canvas ${setRef("canvas")}></canvas>
                </div>
            </div>
            <div class="c-canvas-scroller" ${setRef("canvasScroller")}></div>
        </div>
    `;
  };

  // src/js/component/pages/scroller/n0/definition.js
  var ScrollerN0 = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').ScrollerN0>} */
    {
      tag: "scroller-n0",
      component: ScrollerN0Fn,
      exportState: [
        "numberOfRow",
        "numberOfColumn",
        "cellWidth",
        "cellHeight",
        "gutter",
        "fill",
        "stagger",
        "reorder",
        "disableOffcanvas"
      ],
      state: {
        isMounted: false,
        numberOfRow: () => ({
          value: 10,
          type: Number
        }),
        numberOfColumn: () => ({
          value: 10,
          type: Number
        }),
        cellWidth: () => ({
          value: window.innerHeight / 16,
          type: Number
        }),
        cellHeight: () => ({
          value: window.innerHeight / 16,
          type: Number
        }),
        gutter: () => ({
          value: 1,
          type: Number
        }),
        fill: () => ({
          value: [
            36,
            37,
            38,
            39,
            40,
            47,
            51,
            58,
            62,
            69,
            73,
            80,
            81,
            82,
            83,
            84
          ],
          type: Array
        }),
        stagger: () => ({
          value: {
            type: "equal",
            each: 6,
            from: "random"
          },
          type: "Any"
        }),
        reorder: () => ({
          value: true,
          type: Boolean
        }),
        disableOffcanvas: () => ({
          value: detectFirefox() || detectSafari() ? true : false,
          type: Boolean
        })
      }
    }
  );

  // src/js/pages/canvas/scroller/scroller-params.js
  var scrollerParams = [
    {
      animation: {},
      nav: {
        prevRoute: "#animatedPatternN1",
        nextRoute: "#scrollerN0?version=1&activeId=1",
        backRoute: "#canvas-overview"
      }
    },
    {
      title: "Scroller N.0 v1",
      animation: {
        stagger: {
          type: "end",
          each: 1,
          from: { x: 0, y: 0 },
          grid: { col: 11, row: 10, direction: "radial" }
        },
        reorder: false
      },
      nav: {
        prevRoute: "#scrollerN0?version=0&activeId=0",
        nextRoute: "#scrollerN0?version=2&activeId=2",
        backRoute: "#canvas-overview"
      }
    },
    {
      animation: {
        stagger: {
          type: "equal",
          each: 7,
          from: "center",
          grid: { col: 11, row: 10, direction: "col" }
        },
        reorder: false
      },
      nav: {
        prevRoute: "#scrollerN0?version=1&activeId=1",
        nextRoute: "#scrollerN0?version=3&activeId=3",
        backRoute: "#canvas-overview"
      }
    },
    {
      title: "Scroller N.0 v3",
      animation: {
        stagger: {
          type: "equal",
          each: 3,
          from: "end",
          grid: { col: 11, row: 10, direction: "row" }
        },
        reorder: false
      },
      nav: {
        prevRoute: "#scrollerN0?version=2&activeId=2",
        nextRoute: "#scrollerN0?version=4&activeId=4",
        backRoute: "#canvas-overview"
      }
    },
    {
      title: "Scroller N.0 v4",
      animation: {
        stagger: {
          type: "equal",
          each: 2,
          from: "end"
        },
        reorder: false
      },
      nav: {
        prevRoute: "#scrollerN0?version=3&activeId=3",
        nextRoute: "#scrollerN1",
        backRoute: "#canvas-overview"
      }
    }
  ];

  // src/js/pages/canvas/scroller/index.js
  modules_exports2.useComponent([ScrollerN0]);
  var scrollerN0 = ({ params }) => {
    const { version } = params;
    const props = scrollerParams[Math.max(0, Math.min(Number(version), scrollerParams.length - 1))];
    updateQuickNavState({
      active: true,
      prevRoute: props.nav.prevRoute,
      nextRoute: props.nav.nextRoute,
      backRoute: props.nav.backRoute,
      color: "black"
    });
    return renderHtml`<div>
        <scroller-n0
            ${modules_exports2.staticProps(
      /** @type {import('@pagesComponent/scroller/n0/type').ScrollerN0['state']} */
      {
        ...props.animation
      }
    )}
        ></scroller-n0>
    </div>`;
  };

  // src/js/component/pages/scroller/n1/animation/animation.js
  function getWithRounded2({ width, relativeIndex, amountOfPath }) {
    return Math.sqrt(
      Math.pow(width * relativeIndex, 2) - Math.pow(
        width * relativeIndex / amountOfPath * relativeIndex,
        2
      )
    ) * 2;
  }
  function getHeightRounded2({ height, relativeIndex, amountOfPath }) {
    return Math.sqrt(
      Math.pow(height * relativeIndex, 2) - Math.pow(
        height * relativeIndex / amountOfPath * relativeIndex,
        2
      )
    ) * 2;
  }
  var scrollerN1Animation = ({
    canvas,
    canvasScroller,
    amountOfPath,
    width,
    height,
    opacity,
    intialRotation,
    endRotation,
    disableOffcanvas
  }) => {
    const { useOffscreen, context } = getCanvasContext({ disableOffcanvas });
    let isActive2 = true;
    let ctx = canvas.getContext(context, { alpha: true });
    const activeRoute = modules_exports2.getActiveRoute();
    let { offscreen, offScreenCtx } = getOffsetCanvas({ useOffscreen, canvas });
    const useRadius = false;
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    let stemData = [...Array.from({ length: amountOfPath }).keys()].map(
      (_item, i) => {
        const relativeIndex = i >= amountOfPath / 2 ? amountOfPath / 2 + (amountOfPath / 2 - i) : i;
        return {
          width: Math.floor(
            getWithRounded2({ width, relativeIndex, amountOfPath })
          ),
          height: Math.floor(
            getHeightRounded2({ height, relativeIndex, amountOfPath })
          ),
          opacity: relativeIndex * opacity,
          rotate: 0,
          relativeIndex,
          index: i
        };
      }
    );
    let scrollerTween = tween_exports.createScrollerTween({
      from: { rotate: 0 },
      to: { rotate: endRotation },
      stagger: { each: 5, from: "center" }
    });
    [...stemData].forEach((item) => {
      scrollerTween.subscribeCache(item, ({ rotate }) => {
        item.rotate = rotate;
      });
    });
    const draw = () => {
      if (!ctx) return;
      if (useOffscreen && offscreen) {
        offscreen.width = canvas.width;
        offscreen.height = canvas.height;
      }
      const context2 = useOffscreen ? offScreenCtx : (
        /** @type {CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D} */
        ctx
      );
      if (!context2) return;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      canvas.width = canvas.width;
      stemData.forEach(({ width: width2, height: height2, opacity: opacity2, rotate, index }) => {
        const unitInverse = stemData.length / 2 - index;
        const scale = 1;
        const rotation = Math.PI / 180 * (rotate - intialRotation);
        const xx = Math.cos(rotation) * scale;
        const xy = Math.sin(rotation) * scale;
        context2.setTransform(
          xx,
          xy,
          -xy,
          xx,
          centerX,
          centerY + unitInverse * 19
        );
        if (useRadius) {
          context2.beginPath();
          context2.roundRect(
            -width2 / 2,
            -height2 / 2 + unitInverse * 19,
            width2,
            height2,
            150
          );
        } else {
          context2.beginPath();
          context2.rect(
            Math.round(-width2 / 2),
            Math.round(-height2 / 2),
            width2,
            height2
          );
        }
        context2.strokeStyle = `#000`;
        context2.fillStyle = `rgba(238, 238, 238, ${opacity2})`;
        context2.stroke();
        context2.fill();
        context2.setTransform(1, 0, 0, 1, 0, 0);
      });
      copyCanvasBitmap({ useOffscreen, offscreen, ctx });
    };
    let scrollerInstance = scroller_exports.createScrollTrigger({
      trigger: canvasScroller,
      propierties: "tween",
      tween: scrollerTween,
      dynamicStart: {
        position: "bottom",
        value: () => window.innerHeight
      },
      dynamicEnd: {
        position: "bottom",
        value: () => outerHeight(canvasScroller)
      },
      ease: true,
      easeType: "spring"
    });
    scrollerInstance.init();
    const loop = () => {
      draw();
      if (!isActive2) return;
      modules_exports.useNextFrame(() => loop());
    };
    modules_exports.useFrame(() => {
      loop();
    });
    const unsubscribeResize = modules_exports.useResize(() => {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      modules_exports.useFrame(() => {
        draw();
      });
    });
    const unWatchPause = navigationStore.watch("navigationIsOpen", (val2) => {
      if (val2) {
        isActive2 = false;
        return;
      }
      setTimeout(() => {
        isActive2 = true;
        const currentRoute = modules_exports2.getActiveRoute();
        if (currentRoute.route !== activeRoute.route) return;
        modules_exports.useFrame(() => loop());
      }, 500);
    });
    return () => {
      scrollerTween.destroy();
      unsubscribeResize();
      unWatchPause();
      scrollerTween.destroy();
      scrollerTween = null;
      scrollerInstance.destroy();
      scrollerInstance = null;
      ctx = null;
      offscreen = null;
      offScreenCtx = null;
      scrollerTween = null;
      stemData = [];
      isActive2 = false;
    };
  };

  // src/js/component/pages/scroller/n1/scroller-n1.js
  var ScrollerN1Fn = ({
    onMount,
    getState,
    setState,
    setRef,
    getRef,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    document.body.style.background = canvasBackground;
    onMount(() => {
      activateScrollDownArrow();
      const { canvas, canvasScroller } = getRef();
      const destroyAnimation = scrollerN1Animation({
        canvas,
        canvasScroller,
        ...getState()
      });
      modules_exports.useFrame(() => {
        setState("isMounted", true);
      });
      return () => {
        destroyAnimation();
        deactivateScrollDownArrow();
        document.body.style.background = "";
      };
    });
    return renderHtml`
        <div>
            <div class="c-canvas c-canvas--fixed ">
                <div
                    class="c-canvas__wrap"
                    ${bindEffect({
      toggleClass: { active: () => proxi.isMounted }
    })}
                >
                    <canvas ${setRef("canvas")}></canvas>
                </div>
            </div>
            <div class="c-canvas-scroller" ${setRef("canvasScroller")}></div>
        </div>
    `;
  };

  // src/js/component/pages/scroller/n1/definition.js
  var ScrollerN1 = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').ScrollerN1>} */
    {
      tag: "scroller-n1",
      component: ScrollerN1Fn,
      exportState: [
        "amountOfPath",
        "width",
        "height",
        "radius",
        "opacity",
        "intialRotation",
        "endRotation",
        "disableOffcanvas"
      ],
      state: {
        isMounted: false,
        amountOfPath: 17,
        width: 15,
        height: 40,
        radius: 0,
        opacity: 0.05,
        intialRotation: 33,
        endRotation: 720,
        disableOffcanvas: () => ({
          value: detectFirefox() || detectSafari() ? true : false,
          type: Boolean
        })
      }
    }
  );

  // src/js/pages/canvas/scroller-n1/index.js
  modules_exports2.useComponent([ScrollerN1]);
  var scrollerN1 = () => {
    updateQuickNavState({
      active: true,
      prevRoute: "#scrollerN0?version=4&activeId=4",
      nextRoute: "",
      backRoute: "#canvas-overview",
      color: "black"
    });
    return renderHtml`<div class="l-padding">
        <scroller-n1></scroller-n1>
    </div>`;
  };

  // src/js/component/pages/dynamic-list/button/dynamic-list-button.js
  var DynamicListButtonFn = ({ getProxi, bindEffect }) => {
    const proxi = getProxi();
    return renderHtml`
        <button
            type="button"
            class="c-dynamic-list-button"
            ${bindEffect({
      observe: "active",
      toggleClass: { active: () => proxi.active }
    })}
        >
            ${proxi.label}
        </button>
    `;
  };

  // src/js/component/pages/dynamic-list/button/definition.js
  var DynamicListButton = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DynamicListButton>} */
    {
      tag: "dynamic-list-button",
      component: DynamicListButtonFn,
      exportState: ["active", "label"],
      state: {
        label: () => ({
          value: "",
          type: String
        }),
        active: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/pages/dynamic-list/card/innerCard/dynamic-list-card-inner.js
  var DynamicListCardInnerFn = ({ bindText }) => {
    return renderHtml`<span class="dynamic-list-card-inner">
        <span>${bindText`${"key"}`}</span>
    </span>`;
  };

  // src/js/component/pages/dynamic-list/card/innerCard/definition.js
  var DynamicListCardInner = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DynamicListCardInner>} */
    {
      tag: "dynamic-list-card-inner",
      component: DynamicListCardInnerFn,
      exportState: ["key"],
      state: {
        key: () => ({
          value: "",
          type: String
        })
      }
    }
  );

  // src/js/component/pages/dynamic-list/data/index.js
  var startData = [
    {
      key: "a",
      label: "A"
    },
    {
      key: "b",
      label: "B"
    },
    {
      key: "c",
      label: "C"
    },
    {
      key: "d",
      label: "D"
    }
  ];
  var state1 = [
    {
      key: "f",
      label: "F"
    },
    {
      key: "b",
      label: "B"
    },
    {
      key: "e",
      label: "E"
    },
    {
      key: "c",
      label: "C"
    },
    {
      key: "b",
      label: "B"
    },
    {
      key: "a",
      label: "A"
    },
    {
      key: "g",
      label: "G"
    },
    {
      key: "h",
      label: "H"
    },
    {
      key: "d",
      label: "D"
    },
    {
      key: "b",
      label: "B"
    }
  ];
  var state2 = [
    {
      key: "m",
      label: "M"
    },
    {
      key: "q",
      label: "Q"
    },
    {
      key: "z",
      label: "Z"
    },
    {
      key: "i",
      label: "I"
    },
    {
      key: "b",
      label: "B"
    },
    {
      key: "e",
      label: "E"
    },
    {
      key: "n",
      label: "N"
    },
    {
      key: "a",
      label: "A"
    },
    {
      key: "g",
      label: "G"
    },
    {
      key: "h",
      label: "H"
    },
    {
      key: "l",
      label: "L"
    },
    {
      key: "j",
      label: "J"
    },
    {
      key: "d",
      label: "D"
    }
  ];
  var state3 = [
    {
      key: "h",
      label: "H"
    },
    {
      key: "f",
      label: "F"
    },
    {
      key: "a",
      label: "A"
    },
    {
      key: "d",
      label: "D"
    }
  ];
  var innerData = [
    [{ key: 4 }],
    [
      { key: 20 },
      { key: 10 },
      { key: 10 },
      { key: 6 },
      { key: 10 },
      { key: 10 },
      { key: 30 }
    ],
    [
      { key: 3 },
      { key: 20 },
      { key: 5 },
      { key: 20 },
      { key: 5 },
      { key: 5 },
      { key: 5 },
      { key: 5 },
      { key: 60 },
      { key: 5 },
      { key: 5 },
      { key: 5 },
      { key: 5 },
      { key: 5 },
      { key: 5 },
      { key: 5 },
      { key: 5 },
      { key: 10 },
      { key: 5 }
    ]
  ];

  // src/js/component/pages/dynamic-list/dynamic-list.js
  var buttons2 = [
    {
      buttonLabel: "sample1",
      data: state1
    },
    {
      buttonLabel: "salmple2",
      data: state2
    },
    {
      buttonLabel: "sample3",
      data: state3
    },
    {
      buttonLabel: "Initial",
      data: startData
    }
  ];
  var repeaters = [
    {
      label: "repeater with key",
      key: "key",
      clean: false
    },
    {
      label: "repeater without key",
      key: "",
      clean: false
    },
    {
      label: "repeater clear",
      key: "",
      clean: true
    }
  ];
  function getButton({ staticProps: staticProps2, delegateEvents, bindProps, proxi }) {
    return buttons2.map((column, index) => {
      const { data, buttonLabel } = column;
      return renderHtml`
                <dynamic-list-button
                    class="c-dynamic-list__top__button"
                    ${staticProps2(
        /** @type {DynamicListButton['state']} */
        {
          label: buttonLabel
        }
      )}
                    ${delegateEvents({
        click: async () => {
          proxi.data = data;
          proxi.activeSample = index;
          await modules_exports2.tick();
        }
      })}
                    ${bindProps(
        /** @returns {ReturnBindProps<DynamicListButton>} */
        () => ({
          active: index === proxi.activeSample
        })
      )}
                ></dynamic-list-button>
            `;
    }).join("");
  }
  function getRepeaters({ bindProps, staticProps: staticProps2, proxi }) {
    return repeaters.map((item, index) => {
      const { key, clean: clean2, label } = item;
      return renderHtml`
                <dynamic-list-repeater
                    ${staticProps2(
        /** @type {DynamicListRepeater['state']} */
        {
          listId: index,
          key,
          clean: clean2,
          label
        }
      )}
                    ${bindProps(
        /** @returns {ReturnBindProps<DynamicListRepeater>} */
        () => ({
          data: proxi.data,
          counter: proxi.counter
        })
      )}
                ></dynamic-list-repeater>
            `;
    }).join("");
  }
  var DynamicListFn = ({
    updateState,
    staticProps: staticProps2,
    bindProps,
    delegateEvents,
    invalidate,
    bindText,
    getProxi
  }) => {
    const proxi = getProxi();
    return renderHtml`
        <div class="c-dynamic-list">
            <div class="c-dynamic-list__header">
                <div class="c-dynamic-list__top">
                    ${getButton({
      delegateEvents,
      staticProps: staticProps2,
      bindProps,
      proxi
    })}
                    <dynamic-list-button
                        class="c-dynamic-list__top__button"
                        ${staticProps2(
      /** @type {DynamicListButton['state']} */
      {
        label: "+ counter ( max: 10 )"
      }
    )}
                        ${delegateEvents({
      click: async () => {
        updateState("counter", (prev2) => {
          return prev2 + 1;
        });
      }
    })}
                    ></dynamic-list-button>
                    <dynamic-list-button
                        class="c-dynamic-list__top__button"
                        ${staticProps2(
      /** @type {DynamicListButton['state']} */
      {
        label: "- counter: ( min 0 )"
      }
    )}
                        ${delegateEvents({
      click: async () => {
        updateState("counter", (prev2) => {
          if (prev2 > 0) return prev2 -= 1;
          return prev2;
        });
      }
    })}
                    ></dynamic-list-button>
                </div>
            </div>

            <!-- Invalidate -->
            <div class="c-dynamic-list__invalidate">
                <h4 class="c-dynamic-list__invalidate__title">
                    Invalidate component on counter mutation:
                </h4>
                <div class="c-dynamic-list__invalidate__wrap">
                    ${invalidate({
      observe: () => proxi.counter,
      render: () => {
        return renderHtml`<div class="validate-test-wrapper">
                                <dynamic-list-card-inner
                                    ${bindProps(
          /** @returns {ReturnBindProps<DynamicListCardInner>} */
          () => ({
            key: `${proxi.counter}`
          })
        )}
                                ></dynamic-list-card-inner>
                            </div>`;
      }
    })}
                </div>
            </div>

            <div class="c-dynamic-list__counter">
                <h4>List counter</h4>
                <span>${bindText`${"counter"}`}</span>
            </div>

            <!-- Repeaters -->
            <div class="c-dynamic-list__container">
                <div class="c-dynamic-list__grid">
                    ${getRepeaters({ bindProps, staticProps: staticProps2, proxi })}
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/pages/dynamic-list/counter/dynamic-list-counter.js
  var DynamicListCounterFn = ({ getState, bindText }) => {
    const { parentListId } = getState();
    return renderHtml`<div class="dynamic-counter">
        <p class="c-dynamic-counter__title">Nested:</p>
        <p class="c-dynamic-counter__subtitle">(slotted)</p>
        <p class="c-dynamic-counter__list">list index: ${parentListId}</p>
        <span>${bindText`${"counter"}`}</span>
    </div>`;
  };

  // src/js/component/pages/dynamic-list/counter/definition.js
  var DynamicCounter = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DynamicCounter>} */
    {
      tag: "dynamic-list-counter",
      component: DynamicListCounterFn,
      exportState: ["counter", "parentListId"],
      state: {
        parentListId: () => ({
          value: -1,
          type: Number
        }),
        counter: () => ({
          value: 0,
          type: Number
        })
      }
    }
  );

  // src/js/component/pages/dynamic-list/empty/dynamic-list-empty.js
  var DynamicListEmptyFn = () => {
    return renderHtml`<div class="c-dynamic-list-empty">
        <p>empty comp</p>
        <mobjs-slot name="empty-slot"></mobjs-slot>
    </div>`;
  };

  // src/js/component/pages/dynamic-list/empty/definition.js
  var DynamicListEmpty = modules_exports2.createComponent(
    /** @type {CreateComponentParams<any>} */
    {
      tag: "dynamic-list-empty",
      component: DynamicListEmptyFn
    }
  );

  // src/js/component/pages/dynamic-list/card/dynamic-list-card.js
  function createArray(numberOfItem) {
    return [...Array.from({ length: numberOfItem }).keys()].map((i) => i + 1);
  }
  var getInvalidateRender = ({ staticProps: staticProps2, delegateEvents, proxi }) => {
    return renderHtml`
        ${createArray(proxi.counter).map((item) => {
      return renderHtml`
                    <div class="validate-test-wrapper">
                        <dynamic-list-card-inner
                            ${staticProps2(
        /** @type {DynamicListCardInner['state']} */
        {
          key: `${item}`
        }
      )}
                            ${delegateEvents({
        click: () => {
          console.log(
            "invalidate inside reepater click"
          );
        }
      })}
                        >
                        </dynamic-list-card-inner>
                    </div>
                `;
    }).join("")}
    `;
  };
  var DynamicListCardFn = ({
    onMount,
    key,
    staticProps: staticProps2,
    bindProps,
    id,
    delegateEvents,
    invalidate,
    repeat,
    bindText,
    bindEffect,
    getProxi,
    computed
  }) => {
    const proxi = getProxi();
    let repeaterIndex = 0;
    computed(
      () => proxi.innerDataUnivoque,
      () => proxi.innerData.filter(
        (value, index, self) => self.map(({ key: key2 }) => key2).indexOf(value.key) === index
      )
    );
    onMount(async () => {
      (async () => {
        await modules_exports2.tick();
        proxi.isMounted = true;
      })();
      return () => {
      };
    });
    const isFullClass = proxi.isFull ? "is-full" : "";
    return renderHtml`
        <div
            class="c-dynamic-card ${isFullClass}"
            ${bindEffect({
      toggleClass: {
        active: () => proxi.isMounted,
        "is-selected": () => proxi.isSelected
      }
    })}
        >
            <div class="c-dynamic-card__container">
                <p class="c-dynamic-card__title">card content</p>
                <dynamic-list-button
                    class="c-dynamic-card__button"
                    ${delegateEvents({
      click: () => {
        proxi.isSelected = !proxi.isSelected;
      }
    })}
                    ${bindProps(
      /** @returns {ReturnBindProps<DynamicListButton>} */
      () => ({
        active: proxi.isSelected
      })
    )}
                >
                    Select
                </dynamic-list-button>
                <div class="id">id: ${id}</div>
                <div class="parentId">list index: ${proxi.parentListId}</div>
                <div class="index">${bindText`index: ${"index"}`}</div>
                <div class="label">${bindText`label: ${"label"}`}</div>
                <div class="counter">${bindText`counter: ${"counter"}`}</div>
                <div class="key">key: ${key.length > 0 ? key : "no-key"}</div>
                <mobjs-slot name="card-label-slot"></mobjs-slot>
                <dynamic-list-empty>
                    <dynamic-list-counter
                        slot="empty-slot"
                        ${staticProps2(
      /** @type {DynamicCounter['state']} */
      {
        parentListId: proxi.parentListId
      }
    )}
                        ${bindProps(
      /** @returns {ReturnBindProps<DynamicCounter>} */
      () => ({
        counter: proxi.counter
      })
    )}
                    />
                </dynamic-list-empty>

                <!-- Inner repeater -->
                <div class="c-dynamic-card__repeater-container">
                    <p><strong>Inner repeater:</strong></p>
                    <dynamic-list-button
                        class="c-dynamic-card__button"
                        ${delegateEvents({
      click: async () => {
        repeaterIndex = repeaterIndex < innerData.length - 1 ? repeaterIndex + 1 : 0;
        proxi.innerData = innerData[repeaterIndex];
        await modules_exports2.tick();
      }
    })}
                    >
                        Update:
                    </dynamic-list-button>

                    <!-- repeater by key -->
                    <div class="c-dynamic-card__repeater">
                        ${repeat({
      observe: () => proxi.innerDataUnivoque,
      key: "key",
      render: ({ current }) => {
        return renderHtml`<dynamic-list-card-inner
                                    ${bindProps(
          /** @returns {ReturnBindProps<DynamicListCardInner>} */
          () => ({
            key: `${current.value.key}`
          })
        )}
                                ></dynamic-list-card-inner>`;
      }
    })}
                    </div>

                    <!-- repeater no key -->
                    <div class="c-dynamic-card__repeater">
                        ${repeat({
      observe: () => proxi.innerData,
      render: ({ current }) => {
        return renderHtml`<dynamic-list-card-inner
                                    ${bindProps(
          /** @returns {ReturnBindProps<DynamicListCardInner>} */
          () => ({
            key: `${current.value.key}`
          })
        )}
                                ></dynamic-list-card-inner>`;
      }
    })}
                    </div>
                </div>

                <!-- Invalidate -->
                <div class="c-dynamic-card__invalidate">
                    <p>
                        <strong
                            >Inner invalidate<br />
                            on counter mutation:</strong
                        >
                    </p>
                    <div class="c-dynamic-card__invalidate__wrap">
                        ${invalidate({
      observe: () => proxi.counter,
      render: () => {
        return getInvalidateRender({
          delegateEvents,
          staticProps: staticProps2,
          proxi
        });
      }
    })}
                    </div>
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/pages/dynamic-list/card/definition.js
  var DynamicListCard = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DynamicListCard>} */
    {
      tag: "dynamic-list-card",
      component: DynamicListCardFn,
      exportState: ["isFull", "label", "index", "counter", "parentListId"],
      state: {
        parentListId: () => ({
          value: -1,
          type: Number
        }),
        isFull: () => ({
          value: false,
          type: Boolean
        }),
        label: () => ({
          value: "-",
          type: String
        }),
        index: () => ({
          value: -1,
          type: Number
        }),
        counter: () => ({
          value: 1,
          type: Number
        }),
        innerData: () => ({
          value: innerData[0],
          type: Array
        }),
        innerDataUnivoque: () => ({
          value: innerData[0],
          type: Array
        }),
        isSelected: () => ({
          value: false,
          type: Boolean
        }),
        isMounted: () => ({
          value: false,
          type: Boolean
        })
      },
      child: [
        DynamicCounter,
        DynamicListEmpty,
        DynamicListCardInner,
        DynamicListButton
      ]
    }
  );

  // src/js/component/pages/dynamic-list/slotted-label/dynamic-list-slotted-label.js
  var DynamicListSlottedLabelFn = ({ bindText }) => {
    return renderHtml`<div class="c-dynamic-list-slotted-label">
        <p class="content">${bindText`slotted: ${"label"}`}</p>
    </div>`;
  };

  // src/js/component/pages/dynamic-list/slotted-label/definition.js
  var DynamicListSlottedLabel = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DynamicListSlottedLabel>} */
    {
      tag: "dynamic-slotted-label",
      component: DynamicListSlottedLabelFn,
      exportState: ["label"],
      state: {
        label: () => ({
          value: "",
          type: String
        })
      }
    }
  );

  // src/js/component/pages/dynamic-list/repeaters/dynamic-list-repeater.js
  function getRepeaterCard({
    staticProps: staticProps2,
    bindProps,
    delegateEvents,
    current,
    proxi
  }) {
    return renderHtml`
        <div class="c-dynamic-list-repeater__item">
            <dynamic-list-card
                ${staticProps2(
      /** @type {DynamicListCard['state']} */
      {
        parentListId: proxi.listId
      }
    )}
                ${bindProps(
      /** @returns {ReturnBindProps<DynamicListCard>} */
      () => ({
        counter: proxi.counter,
        label: current.value.label,
        index: current.index
      })
    )}
                ${delegateEvents({
      click: () => {
        console.log(current.value?.label, current.index);
      }
    })}
            >
                <dynamic-slotted-label
                    slot="card-label-slot"
                    ${bindProps(
      /** @returns {ReturnBindProps<DynamicListSlottedLabel>} */
      () => ({
        label: `label: ${current.value.label} <br/> counter: ${proxi.counter}`
      })
    )}
                >
                </dynamic-slotted-label>
            </dynamic-list-card>
        </div>
    `;
  }
  var DynamicListRepeaterFn = ({
    staticProps: staticProps2,
    bindProps,
    delegateEvents,
    repeat,
    getProxi
  }) => {
    const proxi = getProxi();
    const keyParsed = proxi.key.length > 0 ? proxi.key : void 0;
    return renderHtml`
        <div class="c-dynamic-list-repeater">
            <h4 class="c-dynamic-list-repeater__title">${proxi.label}</h4>
            <div class="c-dynamic-list-repeater__list">
                ${repeat({
      observe: () => proxi.data,
      clean: proxi.clean,
      key: keyParsed,
      afterUpdate: () => {
        console.log("repeater updated");
      },
      render: ({ current }) => {
        return getRepeaterCard({
          staticProps: staticProps2,
          bindProps,
          delegateEvents,
          current,
          proxi
        });
      }
    })}
            </div>
        </div>
    `;
  };

  // src/js/component/pages/dynamic-list/repeaters/definition.js
  var DynamicListRepeater = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DynamicListRepeater>} */
    {
      tag: "dynamic-list-repeater",
      component: DynamicListRepeaterFn,
      exportState: [
        "label",
        "clean",
        "data",
        "listId",
        "key",
        "listId",
        "counter"
      ],
      state: {
        data: () => ({
          value: [],
          type: Array
        }),
        key: () => ({
          value: "",
          type: String
        }),
        clean: () => ({
          value: false,
          type: Boolean
        }),
        listId: () => ({
          value: -1,
          type: Number
        }),
        counter: () => ({
          value: -1,
          type: Number
        }),
        label: () => ({
          value: "",
          type: String
        })
      },
      child: [DynamicListCard, DynamicListSlottedLabel]
    }
  );

  // src/js/component/pages/dynamic-list/definition.js
  var DynamicList = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DynamicList>} */
    {
      tag: "dynamic-list",
      component: DynamicListFn,
      state: {
        counter: () => ({
          value: 1,
          type: Number,
          validate: (val2) => val2 <= 10 && val2 >= 0,
          strict: true
        }),
        data: () => ({
          value: startData,
          type: Array
        }),
        activeSample: () => ({
          value: 3,
          type: Number
        })
      },
      child: [DynamicListButton, DynamicListRepeater, DynamicListCardInner]
    }
  );

  // src/js/pages/dynamic-list/index.js
  modules_exports2.useComponent([DynamicList]);
  var dynamic_list = () => {
    return renderHtml` <dynamic-list> </dynamic-list> `;
  };

  // src/js/component/lib/animation/simple-intro.js
  var simpleIntroAnimation = ({ refs }) => {
    let introTween = tween_exports.createTimeTween({
      data: { opacity: 0, scale: 0.5 },
      duration: 2e3,
      ease: "easeOutQuart",
      stagger: { each: 8, from: "end" }
    });
    let loopTween = tween_exports.createTimeTween({
      data: { scale: 1 },
      duration: 6e3,
      ease: "easeInOutQuad",
      stagger: { each: 12, from: "end" }
    });
    refs.forEach((item) => {
      introTween.subscribeCache(item, ({ scale, opacity }) => {
        item.style.scale = `${scale}`;
        item.style.opacity = `${opacity}`;
      });
      loopTween.subscribe(({ scale }) => {
        item.style.scale = `${scale}`;
      });
    });
    let introTl = timeline_exports.createAsyncTimeline({
      repeat: 1,
      autoSet: false
    }).goTo(introTween, {
      opacity: 1,
      scale: 1
    });
    let loopTimeline = timeline_exports.createAsyncTimeline({
      repeat: -1,
      yoyo: true,
      autoSet: false
    }).goTo(loopTween, {
      scale: 1.1
    });
    return {
      playIntro: () => introTl?.play(),
      playSvg: () => {
        loopTimeline?.play();
      },
      destroy: () => {
        introTween.destroy();
        introTween = null;
        introTl.destroy();
        introTl = null;
        loopTween.destroy();
        loopTween = null;
        loopTimeline.destroy();
        loopTimeline = null;
      }
    };
  };

  // src/js/component/pages/homepage/home.js
  var playAnimation = async ({ playIntro, playSvg }) => {
    await playIntro();
    playSvg();
  };
  var HomeComponentFn = ({ onMount, getState, setState }) => {
    const { svg } = getState();
    onMount(({ element }) => {
      const svg_group = [...element.querySelectorAll('[ref="svg_group"]')];
      const { destroy: destroy3, playIntro, playSvg } = simpleIntroAnimation({
        refs: (
          /** @type {HTMLElement[]} */
          svg_group
        )
      });
      setTimeout(() => {
        playAnimation({ playIntro, playSvg });
        setState("isMounted", true);
      }, 500);
      return () => {
        destroy3();
      };
    });
    return renderHtml`<div class="l-index">
        <div class="l-index__logo">${svg}</div>
    </div>`;
  };

  // src/js/component/pages/homepage/definition.js
  var HomeComponent = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').HomeComponent>} */
    {
      tag: "home-component",
      component: HomeComponentFn,
      exportState: ["svg"],
      state: {
        svg: () => ({
          value: "",
          type: String
        }),
        isMounted: () => ({
          value: false,
          type: Boolean
        })
      },
      child: []
    }
  );

  // src/js/pages/home/index.js
  modules_exports2.useComponent([HomeComponent]);
  var home = async () => {
    const { data: svg } = await loadTextContent({
      source: "./asset/svg/ms_nord.svg?v=1.3"
    });
    return renderHtml`
        <home-component
            ${modules_exports2.staticProps(
      /** @type {import('@pagesComponent/homepage/type').HomeComponent['state']} */
      {
        svg
      }
    )}
        ></home-component>
    `;
  };

  // src/js/component/pages/matrioska/matrioska.js
  var buttons3 = [
    {
      state: "level1",
      maxItem: 10,
      ref: "level1_counter",
      label_plus: "level1 +",
      label_minus: "level1 -"
    },
    {
      state: "level2",
      maxItem: 10,
      ref: "level2_counter",
      label_plus: "level2 +",
      label_minus: "level2 -"
    },
    {
      state: "level3",
      maxItem: 6,
      ref: "level3_counter",
      label_plus: "level3 +",
      label_minus: "level3 -"
    }
  ];
  function getRandomInt2(max2) {
    return Math.floor(Math.random() * max2);
  }
  var getButtons2 = ({ delegateEvents, updateState, invalidate, getState }) => {
    return renderHtml`
        ${buttons3.map((button) => {
      return renderHtml` <div class="matrioska__head__item">
                    <dynamic-list-button
                        class="matrioska__button"
                        ${delegateEvents({
        click: async () => {
          updateState(
            /** @type {'level1' | 'level2' | 'level3'} */
            button.state,
            (val2) => {
              return val2.slice(0, -1);
            }
          );
          await modules_exports2.tick();
        }
      })}
                        >${button.label_minus}</dynamic-list-button
                    >
                    <dynamic-list-button
                        class="matrioska__button"
                        ${delegateEvents({
        click: async () => {
          updateState(
            /** @type {'level1' | 'level2' | 'level3'} */
            button.state,
            (val2) => {
              return [
                ...val2,
                {
                  key: getRandomInt2(1e3),
                  value: modules_exports.getUnivoqueId()
                }
              ];
            }
          );
          await modules_exports2.tick();
        }
      })}
                        >${button.label_plus}</dynamic-list-button
                    >
                    <div class="matrioska__head__counter">
                        ${invalidate({
        observe: (
          /** @type {'level1' | 'level2' | 'level3'} */
          button.state
        ),
        render: () => {
          const data = getState()?.[button.state];
          return renderHtml`
                                    Number of items: ${data.length} ( max
                                    ${button.maxItem} )
                                `;
        }
      })}
                    </div>
                </div>`;
    }).join("")}
        <div class="matrioska__head__cta-counter">
            <dynamic-list-button
                class="matrioska__button"
                ${delegateEvents({
      click: () => {
        updateState("counter", (val2) => val2 + 1);
      }
    })}
                >Increment counter</dynamic-list-button
            >
        </div>
    `;
  };
  var getSecondLevel = ({
    repeat,
    staticProps: staticProps2,
    bindProps,
    delegateEvents,
    proxi
  }) => {
    return renderHtml`
        <div class="matrioska__level matrioska__level--2">
            ${repeat({
      observe: () => proxi.level2,
      render: ({ current }) => {
        return renderHtml`
                        <div
                            class="matrioska__item-wrap matrioska__item-wrap--2"
                        >
                            <matrioska-item
                                class="matrioska-item--2"
                                ${staticProps2(
          /** @type {MatrioskaItem['state']} */
          {
            level: "level 2"
          }
        )}
                                ${bindProps(
          /** @returns {ReturnBindProps<MatrioskaItem>} */
          () => ({
            key: `${current.value.key}`,
            value: `${current.value.value}`,
            index: current.index,
            counter: proxi.counter
          })
        )}
                            >
                                ${getThirdLevel({
          repeat,
          staticProps: staticProps2,
          delegateEvents,
          bindProps,
          proxi
        })}
                            </matrioska-item>
                        </div>
                    `;
      }
    })}
        </div>
    `;
  };
  var getThirdLevel = ({
    repeat,
    staticProps: staticProps2,
    bindProps,
    delegateEvents,
    proxi
  }) => {
    return renderHtml`
        <div class="matrioska__level matrioska__level--3">
            ${repeat({
      observe: () => proxi.level3,
      render: ({ current }) => {
        const name = modules_exports.getUnivoqueId();
        const name2 = modules_exports.getUnivoqueId();
        return renderHtml`
                        <div
                            class="matrioska__item-wrap matrioska__item-wrap--3"
                        >
                            <matrioska-item
                                class="matrioska-item--3"
                                name="${name}"
                                ${staticProps2(
          /** @type {MatrioskaItem['state']} */
          {
            level: "level 3"
          }
        )}
                                ${bindProps(
          /** @returns {ReturnBindProps<MatrioskaItem>} */
          () => ({
            key: `${current.value.key}`,
            value: `${current.value.value}`,
            index: current.index,
            counter: proxi.counter
          })
        )}
                                ${delegateEvents({
          click: () => {
            const updateActiveState = modules_exports2.updateStateByName(name);
            updateActiveState(
              "active",
              (val2) => !val2
            );
          }
        })}
                            >
                            </matrioska-item>
                            <matrioska-item
                                class="matrioska-item--3"
                                name="${name2}"
                                ${staticProps2(
          /** @type {MatrioskaItem['state']} */
          {
            level: "level 3"
          }
        )}
                                ${bindProps({
          props: () => {
            return {
              key: `${current.value.key}`,
              value: `${current.value.value}`,
              index: current.index,
              counter: proxi.counter
            };
          }
        })}
                                ${delegateEvents({
          click: () => {
            const updateActiveState = modules_exports2.updateStateByName(name2);
            updateActiveState(
              "active",
              (val2) => !val2
            );
          }
        })}
                            >
                            </matrioska-item>
                        </div>
                    `;
      }
    })}
        </div>
    `;
  };
  var MatrioskaFn = ({
    delegateEvents,
    updateState,
    repeat,
    staticProps: staticProps2,
    bindProps,
    invalidate,
    getState,
    getProxi
  }) => {
    const proxi = getProxi();
    return renderHtml`<div class="matrioska">
        <div class="matrioska__head">
            ${getButtons2({
      delegateEvents,
      updateState,
      invalidate,
      getState
    })}
        </div>
        <h4 class="matrioska__head__title">
            Nested repater like matrioska in same component.
            <span> First/Second/third level repeater without key. </span>
            <span> Third level use shuffle order. </span>
        </h4>
        <div class="matrioska__body">
            <div class="matrioska__level matrioska__level--1">
                ${repeat({
      observe: () => proxi.level1,
      render: ({ current }) => {
        return renderHtml`
                            <div
                                class="matrioska__item-wrap matrioska__item-wrap--1"
                            >
                                <matrioska-item
                                    class="matrioska-item--1"
                                    ${staticProps2(
          /** @type {MatrioskaItem['state']} */
          {
            level: "level 1"
          }
        )}
                                    ${bindProps(
          /** @returns {ReturnBindProps<MatrioskaItem>} */
          () => ({
            key: `${current.value.key}`,
            value: `${current.value.value}`,
            index: current.index,
            counter: proxi.counter
          })
        )}
                                >
                                    ${getSecondLevel({
          repeat,
          staticProps: staticProps2,
          bindProps,
          delegateEvents,
          proxi
        })}
                                </matrioska-item>
                            </div>
                        `;
      }
    })}
            </div>
        </div>
    </div>`;
  };

  // src/js/component/pages/matrioska/item/matrioska-item.js
  var MatrioskaItemFn = ({ getProxi, bindText, id, bindEffect }) => {
    const proxi = getProxi();
    return renderHtml`<matrioska-item
        class="matrioska-item"
        ${bindEffect({
      toggleClass: { active: () => proxi.active }
    })}
    >
        <div class="matrioska-item__info">
            <h4 class="matrioska-item__level">${proxi.level}:</h4>
            <h6 class="matrioska-item__key">
                ${bindText`key: <span>${"key"}</span>`}
            </h6>
            <h6 class="matrioska-item__key">
                ${bindText`index: <span>${"index"}</span>`}
            </h6>
            <h6 class="matrioska-item__value">
                ${bindText`Value: <span>${"value"}</span>`}
            </h6>
            <h6 class="matrioska-item__value">
                ${bindText`counter: <span>${"counter"}</span>`}
            </h6>
            <h6 class="matrioska-item__value">
                Component id: <span>${id}</span>
            </h6>
        </div>
        <div class="matrioska-item__child">
            <mobjs-slot></mobjs-slot>
        </div>
    </matrioska-item>`;
  };

  // src/js/component/pages/matrioska/item/definition.js
  var MatrioskaItem = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').MatrioskaItem>} */
    {
      tag: "matrioska-item",
      component: MatrioskaItemFn,
      exportState: ["level", "key", "value", "active", "counter", "index"],
      state: {
        level: () => ({
          value: "",
          type: String
        }),
        key: () => ({
          value: "",
          strict: true,
          type: String
        }),
        index: () => ({
          value: 0,
          strict: true,
          type: Number
        }),
        value: () => ({
          value: "",
          type: String
        }),
        active: () => ({
          value: false,
          type: Boolean
        }),
        counter: () => ({
          value: -1,
          type: Number
        })
      },
      child: [],
      style: (
        /* CSS */
        `:host { display: block; } `
      )
      // connectedCallback: ({ context, params }) => {
      //     console.log(context, params);
      // },
    }
  );

  // src/js/component/pages/matrioska/definition.js
  var shuffle2 = (array) => {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  };
  var Matrioska = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').Matrioska>} */
    {
      tag: "page-matrioska",
      component: MatrioskaFn,
      exportState: [],
      state: {
        level1: () => ({
          value: [{ key: 1, value: modules_exports.getUnivoqueId() }],
          type: Array,
          validate: (val2) => val2.length <= 10,
          strict: true
        }),
        level2: () => ({
          value: [
            { key: 1, value: modules_exports.getUnivoqueId() },
            { key: 2, value: modules_exports.getUnivoqueId() }
          ],
          type: Array,
          validate: (val2) => val2.length <= 10,
          strict: true
        }),
        level3: () => ({
          value: [
            { key: 1, value: modules_exports.getUnivoqueId() },
            { key: 2, value: modules_exports.getUnivoqueId() }
          ],
          type: Array,
          transform: (val2, oldVal) => {
            return val2 > oldVal ? shuffle2(val2) : val2;
          },
          validate: (val2) => val2.length <= 6,
          strict: true
        }),
        counter: () => ({
          value: 0,
          type: Number
        })
      },
      child: [DynamicListButton, MatrioskaItem]
    }
  );

  // src/js/pages/matrioska/index.js
  modules_exports2.useComponent([Matrioska]);
  var matrioska_page = () => {
    return renderHtml` <page-matrioska> </page-matrioska> `;
  };

  // src/js/component/pages/horizontal-scroller/animation/animation.js
  var sideWidth = 0;
  var createPins = ({ indicators, setState }) => {
    return [...indicators].map((button, i) => {
      return scroller_exports.createScrollTrigger({
        item: button,
        pin: true,
        animateAtStart: false,
        animatePin: true,
        useThrottle: true,
        ease: false,
        dynamicStart: {
          position: "right",
          value: () => {
            return window.innerWidth + sideWidth - outerWidth(button) * (i + 1);
          }
        },
        dynamicEnd: {
          position: "right",
          value: () => {
            const relativeIndex = indicators.length - (i - 2);
            return window.innerWidth / 10 * 9 * relativeIndex;
          }
        },
        onEnter: () => {
          setState("currentId", -1);
          setState("currentIdFromScroll", i);
        },
        onLeaveBack: () => {
          setState("currentIdFromScroll", i - 1);
        }
      });
    });
  };
  var refreshPins = ({ pins }) => {
    pins.forEach((pin) => pin.refresh());
  };
  var createParallax2 = ({ titles }) => {
    return [...titles].map((title) => {
      return scroller_exports.createParallax({
        item: title,
        propierties: "x",
        reverse: true,
        range: 9
      });
    });
  };
  var showNav = ({ nav }) => {
    nav.classList.add("active");
    const indicators = document.querySelectorAll(".js-indicator");
    [...indicators].forEach((indicator) => {
      indicator.classList.add("active");
    });
  };
  var hideNav = ({ nav }) => {
    nav.classList.remove("active");
    const indicators = document.querySelectorAll(".js-indicator");
    [...indicators].forEach((indicator) => {
      indicator.classList.remove("active");
    });
  };
  var horizontalScrollerAnimation = ({
    indicators,
    titles,
    nav,
    animatePin,
    setState,
    rootRef
  }) => {
    let pins = createPins({ indicators, setState });
    let titlesParallax = createParallax2({ titles });
    const side = document.querySelector(".l-navcontainer__side");
    sideWidth = outerWidth(side) / 2;
    const unsubscribeResize = modules_exports.useResize(() => {
      sideWidth = outerWidth(side) / 2;
    });
    let horizontalCustom = new MobHorizontalScroller({
      root: rootRef,
      container: ".js-container",
      row: ".js-row",
      column: ".js-column",
      trigger: ".js-trigger",
      shadowClass: ".shadowClass",
      useWillChange: true,
      useDrag: true,
      useSticky: !animatePin,
      useThrottle: true,
      animateAtStart: false,
      ease: true,
      easeType: "lerp",
      addCss: true,
      columnHeight: 70,
      columnWidth: 100,
      columnAlign: "center",
      animatePin,
      breakpoint: "tablet",
      children: [...pins, ...titlesParallax],
      onEnter: () => {
        showNav({ nav });
      },
      onEnterBack: () => {
        refreshPins({ pins });
        showNav({ nav });
      },
      onLeave: () => {
        hideNav({ nav });
      },
      onLeaveBack: () => {
        hideNav({ nav });
      }
    });
    horizontalCustom.init();
    return {
      destroy: () => {
        pins.forEach((pin) => {
          pin?.destroy();
        });
        pins = [];
        titlesParallax.forEach((item) => {
          item?.destroy();
        });
        titlesParallax = [];
        horizontalCustom.destroy();
        horizontalCustom = null;
        unsubscribeResize();
      },
      refresh: () => horizontalCustom.refresh()
    };
  };

  // src/js/component/pages/horizontal-scroller/horizontal-scroller.js
  var getColumns = ({ numOfCol, pinIsVisible, staticProps: staticProps2 }) => {
    const pinClass = pinIsVisible ? "" : "hidden";
    return [...Array.from({ length: numOfCol }).keys()].map((_col, i) => {
      return renderHtml`
                <horizontal-scroller-section
                    ${staticProps2(
        /** @type {import('./section/type').HorizontalScrollerSection['state']} */
        {
          id: i,
          pinClass
        }
      )}
                ></horizontal-scroller-section>
            `;
    }).join("");
  };
  var getNav = ({
    numOfCol,
    setState,
    bindProps,
    staticProps: staticProps2,
    delegateEvents,
    proxi
  }) => {
    return [...Array.from({ length: numOfCol }).keys()].map((_col, i) => {
      return renderHtml`
                <horizontal-scroller-button
                    ${staticProps2(
        /** @type {HorizontalScrollerButton['state']} */
        {
          id: i
        }
      )}
                    ${delegateEvents({
        click: () => setState("currentId", i)
      })}
                    ${bindProps(
        /** @returns {ReturnBindProps<HorizontalScrollerButton>} */
        () => ({
          active: proxi.currentId === i || proxi.currentIdFromScroll === i
        })
      )}
                ></horizontal-scroller-button>
            `;
    }).join("");
  };
  var HorizontalScrollerFn = ({
    onMount,
    getState,
    setState,
    watch,
    staticProps: staticProps2,
    bindProps,
    delegateEvents,
    setRef,
    getRef,
    getProxi
  }) => {
    const { animatePin } = getState();
    const proxi = getProxi();
    onMount(({ element }) => {
      if (core_exports.mq("max", "desktop")) return;
      const indicators = [...element.querySelectorAll(".js-indicator")];
      const nav = element.querySelector(".js-nav");
      const titles = [...element.querySelectorAll(".js-title h1")];
      const { destroy: destroy3 } = horizontalScrollerAnimation({
        rootRef: getRef().js_root,
        // @ts-ignore
        indicators,
        // @ts-ignore
        titles,
        // @ts-ignore
        nav,
        ...getState(),
        setState
      });
      window.scrollTo(0, 0);
      watch(
        () => proxi.currentId,
        (id) => {
          if (id === -1) return;
          const shadowCenter = element.querySelector(
            `.shadowClass--section-${id} .shadowClass--in-center`
          );
          const { top } = offset(shadowCenter);
          const height = outerHeight(shadowCenter);
          const scrollValue = (
            /**
             * Need previous and current value difference > 0 so add 1px. active: currentId ||
             * currentIdFromScroll ( onLeaveBack issue )
             */
            // @ts-ignore
            Number.parseInt(id) === 0 ? window.innerHeight + 1 : top + height - window.innerHeight
          );
          MobBodyScroll.to(scrollValue, { duration: 2e3 });
        }
      );
      return () => {
        destroy3();
      };
    });
    if (core_exports.mq("max", "desktop"))
      return renderHtml`<div><only-desktop></only-desktop></div>`;
    return renderHtml`<div class="l-h-scroller">
        <only-desktop></only-desktop>
        <div class="l-h-scroller__top">scroll down</div>
        <ul class="l-h-scroller__nav js-nav" ${setRef("js_nav")}>
            ${getNav({
      numOfCol: 10,
      setState,
      bindProps,
      staticProps: staticProps2,
      delegateEvents,
      proxi
    })}
        </ul>
        <div class="l-h-scroller__root js-root" ${setRef("js_root")}>
            <div
                class="l-h-scroller__container js-container"
                ${setRef("js_container")}
            >
                <div class="l-h-scroller__row js-row" ${setRef("js_root")}>
                    ${getColumns({
      numOfCol: 10,
      pinIsVisible: !animatePin,
      staticProps: staticProps2
    })}
                    <section
                        class="l-h-scroller__fakeColumn js-column"
                        ${setRef("js_column")}
                    ></section>
                </div>
                <div
                    class="l-h-scroller__trigger js-trigger"
                    ${setRef("js_trigger")}
                ></div>
            </div>
        </div>
        <div class="l-h-scroller__bottom">scroll up</div>
    </div>`;
  };

  // src/js/component/pages/horizontal-scroller/button/horizontal-scroller-button.js
  var HorizontalScrollerButtonFn = ({ getProxi, bindEffect }) => {
    const proxi = getProxi();
    return renderHtml`
        <li>
            <button
                type="button"
                data-id="${proxi.id}"
                class="l-h-scroller__nav__btn"
                ${bindEffect({
      toggleClass: { active: () => proxi.active }
    })}
            >
                ${proxi.id}
            </button>
        </li>
    `;
  };

  // src/js/component/pages/horizontal-scroller/button/definition.js
  var HorizontalScrollerButton = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').HorizontalScrollerButton>} */
    {
      tag: "horizontal-scroller-button",
      component: HorizontalScrollerButtonFn,
      exportState: ["id", "active"],
      state: {
        id: () => ({
          value: -1,
          type: Number
        }),
        active: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/pages/horizontal-scroller/section/horizontal-scroller-section.js
  var HorizontalScrollerSectionFn = ({ getState }) => {
    const { id, pinClass } = getState();
    return renderHtml`
        <section
            class="l-h-scroller__column js-column"
            data-shadow="section-${id}"
        >
            <div class="l-h-scroller__wrap">
                <span class="l-h-scroller__indicator js-indicator ${pinClass}">
                    <span></span>
                </span>
                <div class="l-h-scroller__title js-title">
                    <h1>${id}</h1>
                </div>
            </div>
        </section>
    `;
  };

  // src/js/component/pages/horizontal-scroller/section/definition.js
  var HorizontalScrollerSection = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').HorizontalScrollerSection>} */
    {
      tag: "horizontal-scroller-section",
      component: HorizontalScrollerSectionFn,
      exportState: ["id", "pinClass"],
      state: {
        id: () => ({
          value: -1,
          type: Number
        }),
        pinClass: () => ({
          value: "",
          type: String
        })
      }
    }
  );

  // src/js/component/pages/horizontal-scroller/definition.js
  var HorizontalScroller = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').HorizontalScroller>} */
    {
      tag: "horizontal-scroller",
      component: HorizontalScrollerFn,
      exportState: [
        "nextRoute",
        "prevRoute",
        "backRoute",
        "currentId",
        "currentIdFromScroll",
        "animatePin"
      ],
      state: {
        currentId: () => ({
          value: 0,
          type: Number
        }),
        currentIdFromScroll: () => ({
          value: 0,
          type: Number
        }),
        animatePin: () => ({
          value: false,
          type: Boolean
        })
      },
      child: [HorizontalScrollerButton, HorizontalScrollerSection]
    }
  );

  // src/js/pages/plugin/horizontal-scroller/index.js
  modules_exports2.useComponent([HorizontalScroller]);
  var horizontalScroller = async () => {
    updateQuickNavState({
      active: true,
      prevRoute: "",
      nextRoute: "#move3D-shape1",
      backRoute: "#plugin-overview",
      color: "black"
    });
    return renderHtml`<div>
        <horizontal-scroller
            ${modules_exports2.staticProps(
      /** @type {import('@pagesComponent/horizontal-scroller/type').HorizontalScroller['state']} */
      {
        animatePin: false
      }
    )}
        ></horizontal-scroller>
    </div>`;
  };

  // src/js/component/common/svg-shape/star/star-svg.js
  var StarSvgFn = ({ getState }) => {
    const { fill } = getState();
    return renderHtml`
        <svg
            viewBox="0 0 105.83333 105.83334"
            version="1.1"
            id="svg1713"
            xmlns="http://www.w3.org/2000/svg"
            xmlns:svg="http://www.w3.org/2000/svg"
            fill=${fill}
        >
            <path
                d="M 314.66331,372.25958 93.889916,264.46734 -120.06656,385.22612 -85.772782,141.94851 -266.73739,-24.219674 -24.76928,-66.781266 77.344916,-290.23763 192.59565,-73.264538 436.67031,-45.199981 265.93107,131.45836 Z"
                transform="matrix(0.13816225,0,0,0.13816225,41.19189,46.490067)"
            />
        </svg>
    `;
  };

  // src/js/component/common/svg-shape/star/definition.js
  var StarSvg = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').StarSvg>} */
    {
      tag: "svg-star",
      component: StarSvgFn,
      exportState: ["fill"],
      state: {
        fill: () => ({
          value: "#000000",
          type: String
        })
      }
    }
  );

  // src/js/component/pages/move-3d/move-3d-page.js
  var getControls2 = ({ delegateEvents, bindObject, proxiState }) => {
    return renderHtml`<div class="c-move3d-page__controls">
        <div class="c-move3d-page__controls__block">
            <div class="c-move3d-page__controls__range">
                <input
                    type="range"
                    value=${proxiState.factor}
                    ${delegateEvents({
      input: (event) => {
        const value = (
          /** @type {HTMLInputElement} */
          event.target.value ?? 0
        );
        proxiState.factor = Number(value);
      }
    })}
                />
            </div>
            <div>${bindObject`factor: ${() => proxiState.factor}`}</div>
        </div>
        <div class="c-move3d-page__controls__block">
            <div class="c-move3d-page__controls__range">
                <input
                    type="range"
                    value=${proxiState.xDepth}
                    ${delegateEvents({
      input: (event) => {
        const value = (
          /** @type {HTMLInputElement} */
          event.target.value ?? 0
        );
        proxiState.xDepth = Number(value);
      }
    })}
                />
            </div>
            <div>${bindObject`xDepth: ${() => proxiState.xDepth}`}</div>
        </div>
        <div class="c-move3d-page__controls__block">
            <div class="c-move3d-page__controls__range">
                <input
                    type="range"
                    value=${proxiState.xLimit}
                    max=${proxiState.xLimit}
                    ${delegateEvents({
      input: (event) => {
        const value = (
          /** @type {HTMLInputElement} */
          event.target.value ?? 0
        );
        proxiState.xLimit = Number(value);
      }
    })}
                />
            </div>
            <div>${bindObject`xLimit: ${() => proxiState.xLimit}`}</div>
        </div>
        <div class="c-move3d-page__controls__block">
            <div class="c-move3d-page__controls__range">
                <input
                    type="range"
                    value=${proxiState.yDepth}
                    ${delegateEvents({
      input: (event) => {
        const value = (
          /** @type {HTMLInputElement} */
          event.target.value ?? 0
        );
        proxiState.yDepth = Number(value);
      }
    })}
                />
            </div>
            <div>${bindObject`yDepth: ${() => proxiState.yDepth}`}</div>
        </div>
        <div class="c-move3d-page__controls__block">
            <div class="c-move3d-page__controls__range">
                <input
                    type="range"
                    value=${proxiState.yLimit}
                    max=${proxiState.yLimit}
                    ${delegateEvents({
      input: (event) => {
        const value = (
          /** @type {HTMLInputElement} */
          event.target.value ?? 0
        );
        proxiState.yLimit = Number(value);
      }
    })}
                />
            </div>
            <div>${bindObject`yLimit: ${() => proxiState.yLimit}`}</div>
        </div>
        <div class="c-move3d-page__controls__block">
            <button
                type="button"
                class="c-move3d-page__controls__button"
                ${delegateEvents({
      click: () => {
        proxiState.debug = !proxiState.debug;
      }
    })}
            >
                Toggle Debug
            </button>
        </div>
    </div>`;
  };
  var Move3DPagefn = ({
    bindProps,
    delegateEvents,
    bindObject,
    getProxi
  }) => {
    const proxiState = getProxi();
    return renderHtml`<div>
        ${getControls2({ delegateEvents, bindObject, proxiState })}
        <move-3d
            ${bindProps(
      /** @returns {ReturnBindProps<import('../../common/move-3d/type').Move3D>} */
      () => ({
        shape: proxiState.data,
        xDepth: proxiState.xDepth,
        yDepth: proxiState.yDepth,
        xLimit: proxiState.xLimit,
        yLimit: proxiState.yLimit,
        factor: proxiState.factor,
        debug: proxiState.debug
      })
    )}
        ></move-3d>
        <move-3d
            ${bindProps(
      /** @returns {ReturnBindProps<import('../../common/move-3d/type').Move3D>} */
      () => ({
        shape: proxiState.data,
        xDepth: proxiState.xDepth,
        yDepth: proxiState.yDepth,
        xLimit: proxiState.xLimit,
        yLimit: proxiState.yLimit,
        factor: proxiState.factor,
        debug: proxiState.debug
      })
    )}
        ></move-3d>
    </div>`;
  };

  // src/js/component/common/move-3d/partials/recursive-3d-shape.js
  var getDebug = ({ debug, id }) => {
    return debug ? renderHtml`<span class="c-move3d-item__debug">${id}</span>` : "";
  };
  var Recursive3Dshape = ({ data, root: root2, childrenId, debug }) => {
    return data.map(({ children, props }) => {
      return renderHtml`<move-3d-item
                name="${childrenId}"
                ${modules_exports2.staticProps(
        /** @type {import('../move-3d-item/type').Move3DItem['state']} */
        {
          root: root2,
          ...props
        }
      )}
            >
                ${getDebug({ debug, id: props.id })}
                ${Recursive3Dshape({
        data: children ?? [],
        root: false,
        childrenId,
        debug
      })}
            </move-3d-item>`;
    }).join("");
  };

  // src/js/component/common/move-3d/utils.js
  var getMove3DDimension = ({ element }) => {
    return {
      height: outerHeight(element),
      width: outerWidth(element),
      offSetLeft: offset(element).left,
      offSetTop: offset(element).top
    };
  };
  var getChildrenMethod = ({ childrenId }) => {
    const methods = modules_exports2.useMethodArrayByName(childrenId);
    return methods.map((method) => {
      return (props) => method?.move?.(props);
    });
  };
  var createUnit3D = ({ ratio }) => {
    return {
      get3dItemUnit: (value) => {
        return `min(${value}px, calc((((100vw) * ${value}) / ${ratio} )))`;
      }
    };
  };

  // src/js/component/common/move-3d/move-3d.js
  var NOOP2 = () => {
  };
  var Move3Dfn = ({
    onMount,
    setRef,
    getRef,
    watch,
    computed,
    invalidate,
    getProxi,
    bindEffect
  }) => {
    const childrenId = modules_exports.getUnivoqueId();
    const proxi = getProxi();
    let height = 0;
    let width = 0;
    let offSetLeft = 0;
    let offSetTop = 0;
    let lastX = 0;
    let dragX = 0;
    let lastY = 0;
    let dragY = 0;
    let onDrag = false;
    let firstDrag = false;
    let pageCoord = { x: 0, y: 0 };
    let lastScrolledTop = 0;
    let unsubscribeTouchStart = NOOP2;
    let unsubscribeTouchEnd = NOOP2;
    let unsubscribeTouchDown = NOOP2;
    let unsubscribeTouchUp = NOOP2;
    let unsubscribeTouchMove = NOOP2;
    let unsubscribeScroll = NOOP2;
    let childrenMethods = [];
    let spring = tween_exports.createSpring({ data: { delta: 0, ax: 0, ay: 0 } });
    const onMouseUp = () => {
      onDrag = false;
    };
    const onMove = () => {
      const { vw, vh } = proxi.centerToViewoport || proxi.drag ? {
        vw: window.innerWidth,
        vh: window.innerHeight
      } : {
        vw: width,
        vh: height
      };
      const x = pageCoord.x;
      const y = pageCoord.y;
      const { xgap, ygap } = (() => {
        if (!onDrag) return { xgap: 0, ygap: 0 };
        if (firstDrag) {
          firstDrag = false;
          return {
            xgap: 0,
            ygap: 0
          };
        } else {
          return {
            xgap: x - lastX,
            ygap: y - lastY
          };
        }
      })();
      if (onDrag) {
        dragX += xgap;
        dragY += ygap;
      }
      const { xInMotion, yInMotion } = onDrag ? {
        xInMotion: dragX,
        yInMotion: dragY
      } : {
        xInMotion: x,
        yInMotion: y
      };
      const { ax, ay } = proxi.centerToViewoport || proxi.drag ? {
        ax: -(vw / 2 - xInMotion) / proxi.xDepth,
        ay: (vh / 2 - yInMotion) / proxi.yDepth
      } : {
        ax: -(vw / 2 - (xInMotion - offSetLeft)) / proxi.xDepth,
        ay: (vh / 2 - (yInMotion - offSetTop)) / proxi.yDepth
      };
      lastX = x;
      lastY = y;
      const xLimitReached = ax > proxi.xLimit || ax < -proxi.xLimit;
      const yLimitReached = ay > proxi.yLimit || ay < -proxi.yLimit;
      if (xLimitReached) dragX -= xgap;
      if (yLimitReached) dragY -= ygap;
      const axClamped = core_exports.clamp(ax, -proxi.xLimit, proxi.xLimit);
      const ayClamped = core_exports.clamp(ay, -proxi.yLimit, proxi.yLimit);
      const delta = Math.sqrt(
        Math.pow(Math.abs(ayClamped), 2) + Math.pow(Math.abs(axClamped), 2)
      );
      spring.goTo({ delta, ax: axClamped, ay: ayClamped }).catch(() => {
      });
      childrenMethods.forEach((moveChild) => {
        moveChild({ delta, factor: proxi.factor });
      });
    };
    const onScroll = (scrollY2) => {
      if (lastScrolledTop !== scrollY2) {
        pageCoord.y -= lastScrolledTop;
        lastScrolledTop = scrollY2;
        pageCoord.y += lastScrolledTop;
      }
      onMove();
    };
    const draggable = ({ page }) => {
      return page.y > offSetTop && page.y < offSetTop + height && page.x > offSetLeft && page.x < offSetLeft + width;
    };
    const onMouseDown = ({ page }) => {
      if (draggable({ page })) {
        onDrag = true;
        firstDrag = true;
      }
    };
    const addScrollListener = () => {
      unsubscribeScroll();
      unsubscribeScroll = proxi.useScroll ? modules_exports.useScroll(({ scrollY: scrollY2 }) => {
        onScroll(scrollY2);
      }) : () => {
      };
    };
    onMount(({ element }) => {
      const { container } = getRef();
      proxi.afterInit(element);
      const unsubscribeSpring = spring.subscribe(({ delta, ax, ay }) => {
        container.style.transform = `translate3D(0,0,0) rotateY(${ax}deg) rotateX(${ay}deg)`;
        proxi.onUpdate({ delta, deltaX: ax, deltaY: ay });
      });
      const unsubscribeOnComplete = spring.onComplete(({ ax, ay }) => {
        container.style.transform = `rotateY(${ax}deg) rotateX(${ay}deg)`;
      });
      const unsubscribeMouseMove = modules_exports.useMouseMove(({ page }) => {
        pageCoord = { x: page.x, y: page.y };
        onMove();
      });
      const unsubscribeResize = modules_exports.useResize(() => {
        ({ height, width, offSetTop, offSetLeft } = getMove3DDimension({
          element
        }));
      });
      watch(
        () => proxi.drag,
        (value) => {
          unsubscribeTouchMove();
          unsubscribeTouchUp();
          unsubscribeTouchDown();
          unsubscribeTouchEnd();
          unsubscribeTouchStart();
          if (value) {
            dragX = window.innerWidth / 2;
            dragY = window.innerHeight / 2;
            unsubscribeTouchStart = modules_exports.useTouchStart(
              ({ page }) => {
                onMouseDown({ page });
              }
            );
            unsubscribeTouchEnd = modules_exports.useTouchEnd(() => {
              onMouseUp();
            });
            unsubscribeTouchDown = modules_exports.useMouseDown(({ page }) => {
              onMouseDown({ page });
            });
            unsubscribeTouchUp = modules_exports.useMouseUp(() => {
              onMouseUp();
            });
            unsubscribeTouchMove = modules_exports.useTouchMove(({ page }) => {
              pageCoord = { x: page.x, y: page.y };
              onMove();
            });
            return;
          }
        },
        { immediate: true }
      );
      watch(
        () => proxi.useScroll,
        (value, prevValue) => {
          if (value) {
            addScrollListener();
            return;
          }
          if (value !== prevValue) unsubscribeScroll();
        }
      );
      computed(
        () => proxi.useScroll,
        () => {
          return !proxi.drag && !proxi.centerToViewoport;
        }
      );
      modules_exports.useNextLoop(() => {
        ({ height, width, offSetTop, offSetLeft } = getMove3DDimension({
          element
        }));
        pageCoord = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        onMove();
      });
      return () => {
        unsubscribeSpring();
        unsubscribeOnComplete();
        unsubscribeResize();
        unsubscribeMouseMove();
        unsubscribeScroll();
        unsubscribeTouchStart();
        unsubscribeTouchEnd();
        unsubscribeTouchDown();
        unsubscribeTouchUp();
        unsubscribeTouchMove();
        spring.destroy();
        childrenMethods = [];
        spring = null;
        height = null;
        width = null;
        offSetLeft = null;
        offSetTop = null;
        lastX = null;
        dragX = null;
        lastY = null;
        dragY = null;
        onDrag = null;
        firstDrag = null;
        pageCoord = null;
        lastScrolledTop = null;
      };
    });
    return renderHtml`<div
        class="c-move-3d"
        ${bindEffect({
      toggleClass: { "move3D--drag": () => proxi.drag }
    })}
    >
        <div
            class="c-move-3d__scene"
            ${bindEffect({
      toggleStyle: {
        perspective: () => `${proxi.perspective}px`
      }
    })}
        >
            <div class="c-move-3d__container" ${setRef("container")}>
                ${invalidate({
      observe: [() => proxi.shape, () => proxi.debug],
      afterUpdate: () => {
        childrenMethods = getChildrenMethod({
          childrenId
        });
      },
      render: () => {
        return Recursive3Dshape({
          data: proxi.shape,
          root: true,
          childrenId,
          debug: proxi.debug
        });
      }
    })}
            </div>
        </div>
    </div>`;
  };

  // src/js/component/common/move-3d/move-3d-item/utils.js
  var getRotate = ({ startRotation, range, delta, limit }) => {
    return Number.parseFloat(
      (range * delta / limit - startRotation).toFixed(2)
    );
  };
  var getRotateFromPosition = ({
    rotate,
    anchorPoint,
    baseRotateX,
    baseRotateY
  }) => {
    if (!rotate || !anchorPoint)
      return {
        rotateX: 0,
        rotateY: 0
      };
    switch (rotate.toUpperCase()) {
      case "X": {
        return (() => {
          switch (anchorPoint.toUpperCase()) {
            case "BOTTOM": {
              return {
                rotateX: baseRotateX,
                rotateY: 0
              };
            }
            case "TOP": {
              return {
                rotateX: -baseRotateX,
                rotateY: 0
              };
            }
            default: {
              return {
                rotateX: 0,
                rotateY: 0
              };
            }
          }
        })();
      }
      case "Y": {
        return (() => {
          switch (anchorPoint.toUpperCase()) {
            case "LEFT": {
              return {
                rotateX: 0,
                rotateY: baseRotateY
              };
            }
            case "RIGHT": {
              return {
                rotateX: 0,
                rotateY: -baseRotateY
              };
            }
            default: {
              return {
                rotateX: 0,
                rotateY: 0
              };
            }
          }
        })();
      }
      case "XY": {
        return (() => {
          switch (anchorPoint.toUpperCase()) {
            case "TOP-LEFT": {
              return {
                rotateX: -baseRotateX,
                rotateY: baseRotateY
              };
            }
            case "TOP-RIGHT": {
              return {
                rotateX: -baseRotateX,
                rotateY: -baseRotateY
              };
            }
            case "BOTTOM-LEFT": {
              return {
                rotateX: baseRotateX,
                rotateY: baseRotateY
              };
            }
            case "BOTTOM-RIGHT": {
              return {
                rotateX: baseRotateX,
                rotateY: -baseRotateY
              };
            }
            default: {
              return {
                rotateX: 0,
                rotateY: 0
              };
            }
          }
        })();
      }
      default: {
        return {
          rotateX: 0,
          rotateY: 0
        };
      }
    }
  };

  // src/js/component/common/move-3d/move-3d-item/move-3d-item.js
  var getComponent = (component) => {
    if (component?.tagName.length === 0) {
      return "";
    }
    return renderHtml`
        <div class="c-move3d-item__component ${component?.className}">
            <${component.tagName} ${modules_exports2.staticProps(component?.props ?? {})}>
            </${component.tagName}>
        </div>`;
  };
  var move = ({
    delta: currentDelta,
    factor,
    initialRotate,
    depth,
    range,
    rotate,
    anchorPoint,
    lerp: lerp2
  }) => {
    const currentDepth = Math.round(depth * currentDelta / factor);
    const getRotateData = {
      startRotation: initialRotate ?? 0,
      range: range ?? 20,
      delta: currentDelta,
      limit: factor
    };
    const baseRotateX = getRotate(getRotateData);
    const baseRotateY = getRotate(getRotateData);
    const getRotateFromPositionData = {
      rotate: rotate ?? "center",
      anchorPoint,
      baseRotateX,
      baseRotateY
    };
    const { rotateX, rotateY } = getRotateFromPosition(
      getRotateFromPositionData
    );
    lerp2.goTo({ depth: currentDepth, rotateX, rotateY }).catch(() => {
    });
  };
  var Move3DItemfn = ({ getState, addMethod, onMount }) => {
    const {
      root: root2,
      anchorPoint,
      animate,
      depth,
      rotate,
      width,
      height,
      offsetX,
      offsetY,
      range,
      initialRotate,
      initialDepth,
      classList,
      component
    } = getState();
    const rootClass = root2 ? "is-root" : "is-children";
    const widthCssVar = `--item-width:${width};`;
    const heightCssVar = `--item-height:${height};`;
    const offsetXCssVar = `--offset-x:${offsetX};`;
    const offsetYCssVar = `--offset-y:${offsetY};`;
    let lerp2 = tween_exports.createLerp({
      data: { depth: 0, rotateX: 0, rotateY: 0 }
    });
    addMethod("move", ({ delta, factor }) => {
      if (animate) {
        move({
          delta,
          factor,
          initialRotate,
          depth,
          range,
          rotate,
          anchorPoint,
          lerp: lerp2
        });
      }
    });
    onMount(({ element }) => {
      const unsubscribelerp = lerp2.subscribe(
        ({ depth: depth2, rotateX, rotateY }) => {
          const currentDepth2 = depth2 + initialDepth;
          element.style.transform = `translate3D(0,0,${currentDepth2}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        }
      );
      const unsubscribeOnComplete = lerp2.onComplete(
        ({ depth: depth2, rotateX, rotateY }) => {
          const currentDepth2 = depth2 + initialDepth;
          element.style.transform = `translateZ(${currentDepth2}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        }
      );
      const currentDepth = initialDepth;
      element.style.transform = `translateZ(${currentDepth}px)`;
      return () => {
        unsubscribelerp();
        unsubscribeOnComplete();
        lerp2.destroy();
        lerp2 = null;
      };
    });
    return renderHtml`<div
        class="c-move3d-item ${rootClass} anchor-${anchorPoint}"
        style="${widthCssVar}${heightCssVar}${offsetXCssVar}${offsetYCssVar}"
    >
        <div class="c-move3d-item__content ${classList}"></div>
        ${getComponent({
      tagName: component?.tagName ?? "",
      className: component?.className ?? "",
      props: component?.props ?? {}
    })}
        <mobjs-slot></mobjs-slot>
    </div>`;
  };

  // src/js/component/common/move-3d/move-3d-item/definition.js
  var Move3DItem = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').Move3DItem>} */
    {
      tag: "move-3d-item",
      component: Move3DItemfn,
      exportState: [
        "root",
        "depth",
        "rotate",
        "width",
        "height",
        "offsetX",
        "offsetY",
        "range",
        "animate",
        "anchorPoint",
        "classList",
        "component",
        "initialRotate",
        "initialDepth"
      ],
      state: {
        root: () => ({
          value: true,
          type: Boolean
        }),
        depth: () => ({
          value: 0,
          type: Number
        }),
        rotate: () => ({
          value: "x",
          type: String
        }),
        id: () => ({
          value: "",
          type: String
        }),
        width: () => ({
          value: "0px",
          type: String
        }),
        height: () => ({
          value: "0px",
          type: String
        }),
        offsetX: () => ({
          value: "0px",
          type: String
        }),
        offsetY: () => ({
          value: "0px",
          type: String
        }),
        range: () => ({
          value: 20,
          type: Number
        }),
        anchorPoint: () => ({
          value: "center",
          type: String
        }),
        animate: () => ({
          value: true,
          type: Boolean
        }),
        initialRotate: () => ({
          value: 0,
          type: Number
        }),
        initialDepth: () => ({
          value: 0,
          type: Number
        }),
        classList: () => ({
          value: "",
          type: String
        }),
        component: {
          tagName: () => ({
            value: "",
            type: String
          }),
          className: () => ({
            value: "",
            type: String
          }),
          props: () => ({
            value: "",
            type: "any"
          })
        }
      }
    }
  );

  // src/js/component/common/move-3d/definition.js
  var Move3D = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').Move3D>} */
    {
      tag: "move-3d",
      component: Move3Dfn,
      exportState: [
        "drag",
        "centerToViewoport",
        "xDepth",
        "yDepth",
        "xLimit",
        "yLimit",
        "factor",
        "shape",
        "debug",
        "perspective",
        "afterInit",
        "onUpdate"
      ],
      state: {
        drag: () => ({
          value: false,
          type: Boolean
        }),
        centerToViewoport: () => ({
          value: false,
          type: Boolean
        }),
        useScroll: () => ({
          value: true,
          type: Boolean
        }),
        perspective: () => ({
          value: 700,
          type: Number
        }),
        xDepth: () => ({
          value: 20,
          type: Number,
          validate: (value) => {
            return value > 1;
          },
          strict: true
        }),
        yDepth: () => ({
          value: 20,
          type: Number,
          validate: (value) => {
            return value > 1;
          },
          strict: true
        }),
        xLimit: () => ({
          value: 1e4,
          type: Number
        }),
        yLimit: () => ({
          value: 1e4,
          type: Number
        }),
        factor: () => ({
          value: 45,
          type: Number,
          validate: (value) => {
            return value > 1;
          },
          strict: true
        }),
        shape: () => ({
          value: [],
          type: Array
        }),
        debug: () => ({
          value: false,
          type: Boolean
        }),
        afterInit: () => ({
          value: () => {
          },
          type: Function
        }),
        onUpdate: () => ({
          value: () => {
          },
          type: Function
        })
      },
      child: [Move3DItem]
    }
  );

  // src/js/component/pages/move-3d/definition.js
  var Move3DPage = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').Move3DPage>} */
    {
      tag: "move-3d-page",
      component: Move3DPagefn,
      exportState: ["data", "prevRoute", "nextRoute"],
      state: {
        data: () => ({
          value: [],
          type: Array
        }),
        xDepth: () => ({
          value: 20,
          type: Number
        }),
        yDepth: () => ({
          value: 20,
          type: Number
        }),
        xLimit: () => ({
          value: 1e3,
          type: Number
        }),
        yLimit: () => ({
          value: 1e3,
          type: Number
        }),
        perspective: () => ({
          value: 700,
          type: Number
        }),
        debug: () => ({
          value: false,
          type: Boolean
        }),
        factor: () => ({
          value: 45,
          type: Number,
          validate: (value) => {
            return value > 1;
          },
          strict: true
        })
      },
      child: [Move3D]
    }
  );

  // src/js/pages/plugin/move-3d/index.js
  modules_exports2.useComponent([Move3DPage, StarSvg]);
  var move3DRoute = async ({ props }) => {
    const { data, prevRoute, nextRoute } = props;
    updateQuickNavState({
      active: true,
      prevRoute,
      nextRoute,
      backRoute: "#plugin-overview",
      color: "white"
    });
    return renderHtml`<move-3d-page
        ${modules_exports2.staticProps(
      /** @type {import('@pagesComponent/move-3d/type').Move3DPage['state']} */
      { data }
    )}
    ></move-3d-page> `;
  };

  // src/js/component/common/move-3d/shape/shape1.js
  var { get3dItemUnit } = createUnit3D({ ratio: 1980 });
  var move3DShape1 = [
    {
      props: {
        id: 0,
        depth: 0,
        anchorPoint: "center",
        classList: "move3d-square",
        animate: true,
        width: get3dItemUnit(150),
        height: get3dItemUnit(150)
      },
      children: [
        {
          props: {
            id: 1,
            depth: 200,
            width: get3dItemUnit(150),
            height: get3dItemUnit(150),
            rotate: "",
            anchorPoint: "center",
            initialDepth: 100,
            classList: "move3d-square has-star pippo",
            component: {
              tagName: "svg-star",
              className: "move3d-square__star",
              props: {
                fill: "#f28f3b"
              }
            },
            animate: true
          },
          children: []
        },
        {
          props: {
            id: 2,
            depth: 200,
            width: get3dItemUnit(80),
            height: get3dItemUnit(80),
            offsetX: get3dItemUnit(40),
            offsetY: get3dItemUnit(40),
            rotate: "",
            initialDepth: 200,
            anchorPoint: "center",
            classList: "move3d-square is-small is-grey is-center",
            animate: true
          },
          children: []
        },
        {
          props: {
            id: 3,
            depth: 200,
            width: get3dItemUnit(80),
            height: get3dItemUnit(80),
            offsetX: get3dItemUnit(-10),
            offsetY: get3dItemUnit(80),
            rotate: "",
            initialDepth: 50,
            anchorPoint: "center",
            classList: "move3d-square is-small is-grey is-center",
            animate: true
          },
          children: []
        },
        {
          props: {
            id: 4,
            depth: 200,
            width: get3dItemUnit(80),
            height: get3dItemUnit(80),
            offsetX: get3dItemUnit(80),
            offsetY: get3dItemUnit(80),
            rotate: "",
            initialDepth: 50,
            anchorPoint: "center",
            classList: "move3d-square is-small is-grey is-center",
            animate: true
          },
          children: []
        },
        {
          props: {
            id: 5,
            depth: 200,
            width: get3dItemUnit(80),
            height: get3dItemUnit(80),
            offsetX: get3dItemUnit(-10),
            offsetY: get3dItemUnit(-10),
            rotate: "",
            initialDepth: 50,
            anchorPoint: "center",
            classList: "move3d-square is-small is-grey is-center",
            animate: true
          },
          children: []
        },
        {
          props: {
            id: 6,
            depth: 200,
            width: get3dItemUnit(80),
            height: get3dItemUnit(80),
            offsetX: get3dItemUnit(80),
            offsetY: get3dItemUnit(-10),
            rotate: "",
            initialDepth: 50,
            anchorPoint: "center",
            classList: "move3d-square is-small is-grey is-center",
            animate: true
          },
          children: []
        },
        {
          props: {
            id: 7,
            depth: 100,
            width: get3dItemUnit(150),
            height: get3dItemUnit(150),
            rotate: "x",
            range: 20,
            anchorPoint: "bottom",
            classList: "move3d-square",
            animate: true
          },
          children: [
            {
              props: {
                id: 8,
                depth: 0,
                width: get3dItemUnit(150),
                height: get3dItemUnit(150),
                rotate: "x",
                range: 30,
                anchorPoint: "bottom",
                classList: "move3d-square",
                animate: true
              },
              children: []
            }
          ]
        },
        {
          props: {
            id: 9,
            depth: 100,
            width: get3dItemUnit(150),
            height: get3dItemUnit(150),
            rotate: "x",
            range: 20,
            anchorPoint: "top",
            classList: "move3d-square",
            animate: true
          },
          children: [
            {
              props: {
                id: 10,
                depth: 0,
                width: get3dItemUnit(150),
                height: get3dItemUnit(150),
                rotate: "x",
                range: 20,
                anchorPoint: "top",
                classList: "move3d-square",
                animate: true
              },
              children: []
            }
          ]
        },
        {
          props: {
            id: 11,
            depth: 100,
            width: get3dItemUnit(150),
            height: get3dItemUnit(150),
            rotate: "y",
            range: 20,
            anchorPoint: "left",
            classList: "move3d-square",
            animate: true
          },
          children: [
            {
              props: {
                id: 12,
                depth: 0,
                width: get3dItemUnit(150),
                height: get3dItemUnit(150),
                rotate: "y",
                range: 30,
                anchorPoint: "left",
                classList: "move3d-square",
                animate: true
              },
              children: [
                {
                  props: {
                    id: 13,
                    depth: 0,
                    width: get3dItemUnit(150),
                    height: get3dItemUnit(150),
                    rotate: "y",
                    range: 40,
                    anchorPoint: "left",
                    classList: "move3d-square",
                    animate: true
                  },
                  children: []
                }
              ]
            }
          ]
        },
        {
          props: {
            id: 13,
            depth: 100,
            width: get3dItemUnit(150),
            height: get3dItemUnit(150),
            rotate: "y",
            range: 20,
            anchorPoint: "right",
            classList: "move3d-square",
            animate: true
          },
          children: [
            {
              props: {
                id: 14,
                depth: 0,
                width: get3dItemUnit(150),
                height: get3dItemUnit(150),
                rotate: "y",
                range: 30,
                anchorPoint: "right",
                classList: "move3d-square",
                animate: true
              },
              children: [
                {
                  props: {
                    id: 15,
                    depth: 0,
                    width: get3dItemUnit(150),
                    height: get3dItemUnit(150),
                    rotate: "y",
                    range: 40,
                    anchorPoint: "right",
                    classList: "move3d-square",
                    animate: true
                  },
                  children: []
                }
              ]
            }
          ]
        },
        {
          props: {
            id: 16,
            depth: 150,
            rotate: "xy",
            width: get3dItemUnit(150),
            height: get3dItemUnit(150),
            offsetX: get3dItemUnit(20),
            offsetY: get3dItemUnit(20),
            range: 20,
            anchorPoint: "bottom-left",
            classList: "move3d-square",
            animate: true
          },
          children: [
            {
              props: {
                id: 17,
                depth: 100,
                rotate: "",
                width: get3dItemUnit(150),
                height: get3dItemUnit(150),
                range: 100,
                anchorPoint: "center",
                classList: "move3d-square is-small is-grey is-center",
                animate: true
              },
              children: []
            }
          ]
        },
        {
          props: {
            id: 18,
            depth: 150,
            rotate: "xy",
            width: get3dItemUnit(150),
            height: get3dItemUnit(150),
            offsetX: get3dItemUnit(20),
            offsetY: get3dItemUnit(20),
            range: 20,
            anchorPoint: "bottom-right",
            classList: "move3d-square",
            animate: true
          },
          children: [
            {
              props: {
                id: 19,
                depth: 100,
                rotate: "",
                width: get3dItemUnit(150),
                height: get3dItemUnit(150),
                range: 100,
                anchorPoint: "center",
                classList: "move3d-square is-small is-grey is-center",
                animate: true
              },
              children: []
            }
          ]
        },
        {
          props: {
            id: 20,
            depth: 150,
            rotate: "xy",
            width: get3dItemUnit(150),
            height: get3dItemUnit(150),
            offsetX: get3dItemUnit(20),
            offsetY: get3dItemUnit(20),
            range: 20,
            anchorPoint: "top-left",
            classList: "move3d-square",
            animate: true
          },
          children: [
            {
              props: {
                id: 21,
                depth: 100,
                rotate: "",
                width: get3dItemUnit(150),
                height: get3dItemUnit(150),
                range: 100,
                anchorPoint: "center",
                classList: "move3d-square is-small is-grey is-center",
                animate: true
              },
              children: []
            }
          ]
        },
        {
          props: {
            id: 22,
            depth: 150,
            rotate: "xy",
            width: get3dItemUnit(150),
            height: get3dItemUnit(150),
            offsetX: get3dItemUnit(20),
            offsetY: get3dItemUnit(20),
            range: 20,
            anchorPoint: "top-right",
            classList: "move3d-square",
            animate: true
          },
          children: [
            {
              props: {
                id: 23,
                depth: 100,
                rotate: "",
                width: get3dItemUnit(150),
                height: get3dItemUnit(150),
                range: 100,
                anchorPoint: "center",
                classList: "move3d-square is-small is-grey is-center",
                animate: true
              },
              children: []
            }
          ]
        }
      ]
    }
  ];

  // src/js/pages/plugin/move-3d/props.js
  var move3DrouteProps = {
    shape1: {
      prevRoute: "#horizontalScroller?version=0&activeId=0",
      nextRoute: "",
      data: move3DShape1
    }
  };

  // src/js/component/common/any-component/any-component.js
  var AnyComponentFn = ({ getState }) => {
    const { content } = getState();
    return renderHtml`${content}`;
  };

  // src/js/component/common/any-component/definition.js
  var AnyComponent = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').AnyComponent>} */
    {
      tag: "any-component",
      component: AnyComponentFn,
      exportState: ["content"],
      state: {
        content: () => ({
          value: "",
          type: String
        })
      }
    }
  );

  // src/js/utils/parse-svg.js
  var parseSvg = ({ svg, id }) => {
    const fragment = document.createRange().createContextualFragment(svg);
    const layers = fragment.querySelectorAll('[type="layer"]');
    const layerToRemove = fragment.querySelectorAll('[type="delete"]');
    [...layers].forEach((layer) => {
      const currentId = layer.id;
      if (currentId !== id) layer.remove();
    });
    [...layerToRemove].forEach((layer) => {
      layer.remove();
    });
    const serialized = serializeFragment(fragment);
    return serialized;
  };

  // src/js/pages/svg/mob-01/data.js
  var rdp_01_schema = ({
    u0,
    u1,
    o,
    o_b,
    m1,
    m2,
    m3,
    m4,
    b1,
    b1_b,
    b3,
    b4,
    b5,
    sign,
    m1_b,
    m3_b,
    m4_b,
    b1_stone,
    m1_stone
  }) => {
    return [
      {
        props: {
          id: 0,
          depth: 200,
          anchorPoint: "center",
          classList: "",
          animate: true
        },
        children: [
          {
            props: {
              id: 1,
              depth: -500,
              anchorPoint: "center",
              classList: "",
              animate: true,
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: u0
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 1,
              depth: -50,
              anchorPoint: "center",
              classList: "",
              animate: true,
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: u1
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 2,
              depth: 20,
              initialDepth: 0,
              anchorPoint: "center",
              classList: "",
              animate: true,
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: o
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 2,
              depth: 21,
              initialDepth: 0,
              anchorPoint: "center",
              classList: "",
              animate: true,
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: o_b
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 3,
              depth: 150,
              anchorPoint: "center",
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: m1
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 3,
              depth: 150,
              anchorPoint: "center",
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: m1_b
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 6,
              depth: 155,
              initialDepth: 1,
              anchorPoint: "center",
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: m4
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 6,
              depth: 155,
              initialDepth: 1,
              anchorPoint: "center",
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: m4_b
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 6,
              depth: 170,
              initialDepth: 1,
              anchorPoint: "center",
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: m1_stone
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 4,
              depth: 180,
              initialDepth: 1,
              anchorPoint: "center",
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: m2
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 4,
              depth: 180,
              initialDepth: 1,
              anchorPoint: "center",
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: sign
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 5,
              depth: 100,
              anchorPoint: "center",
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: m3
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 5,
              depth: 100,
              anchorPoint: "center",
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: m3_b
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 6,
              depth: 50,
              anchorPoint: "center",
              initialDepth: 1,
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: b1
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 6,
              depth: 51,
              anchorPoint: "center",
              initialDepth: 1,
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: b1_b
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 7,
              depth: 120,
              anchorPoint: "center",
              initialDepth: 20,
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: b1_stone
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 8,
              depth: 100,
              initialDepth: 10,
              anchorPoint: "center",
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: b3
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 10,
              depth: 170,
              anchorPoint: "center",
              initialDepth: 10,
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: b4
                }
              }
            },
            children: []
          },
          {
            props: {
              id: 11,
              depth: 100,
              anchorPoint: "center",
              initialDepth: 1,
              classList: "",
              animate: true,
              rotate: "y",
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-mob-01__block",
                props: {
                  content: b5
                }
              }
            },
            children: []
          }
        ]
      }
    ];
  };

  // src/js/pages/svg/mob-01/index.js
  modules_exports2.useComponent([Move3D, AnyComponent]);
  var lettering01 = async () => {
    const { data: letteringMob } = await loadTextContent({
      source: "./asset/svg/lettering-mob.svg?v=0.9"
    });
    const [
      u0,
      u1,
      o,
      o_b,
      m1,
      m1_b,
      m2,
      m3,
      m3_b,
      m4,
      m4_b,
      b1,
      b1_b,
      b3,
      b4,
      b5,
      sign,
      b1_stone,
      m1_stone
    ] = [
      "U0_block",
      "U1_block",
      "O_block",
      "O_b_block",
      "M1_block",
      "M1_b_block",
      "M2_block",
      "M3_block",
      "M3_b_block",
      "M4_block",
      "M4_b_block",
      "B1_block",
      "B1_b_block",
      "B3_block",
      "B4_block",
      "B5_block",
      "sign",
      "Bstone_1_block",
      "Mstone_1_block"
    ].map((id) => {
      return parseSvg({
        svg: letteringMob,
        id
      });
    });
    updateQuickNavState({
      active: true,
      prevRoute: "#rdp-01",
      nextRoute: "",
      backRoute: "#svg-overview",
      color: "black"
    });
    return renderHtml`<div class="l-mob-01">
        <move-3d
            ${modules_exports2.staticProps(
      /** @type {import('@commonComponent/move-3d/type').Move3D['state']} */
      {
        shape: rdp_01_schema({
          u0,
          u1,
          o,
          o_b,
          m1,
          m2,
          m3,
          m4,
          b1,
          b1_b,
          b3,
          b4,
          b5,
          sign,
          m1_b,
          m3_b,
          m4_b,
          b1_stone,
          m1_stone
        }),
        xDepth: 100,
        yDepth: 30,
        factor: 20,
        xLimit: 20,
        yLimit: 20,
        drag: true,
        perspective: 1e3
      }
    )}
        ></move-3d>
    </div>`;
  };

  // src/js/component/common/only-desktop-cta/only-desktop-cta.js
  var shouldActivateCta = () => {
    return (
      /** @type {boolean} */
      core_exports.mq("min", "desktop")
    );
  };
  var OnlyDesktopFnCta = ({ onMount, getProxi, bindEffect }) => {
    const proxi = getProxi();
    proxi.active = shouldActivateCta();
    onMount(() => {
      const unsubscribeResize = modules_exports.useResize(() => {
        proxi.active = shouldActivateCta();
      });
      return () => {
        unsubscribeResize();
      };
    });
    return renderHtml`
        <a
            href="#home"
            class="l-only-desktop__link"
            ${bindEffect({
      toggleClass: {
        active: () => proxi.active
      }
    })}
        >
            home page
        </a>
    `;
  };

  // src/js/component/common/only-desktop-cta/definition.js
  var OnlyDesktopCta = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').OnlyDesktop>} */
    {
      tag: "only-desktop-cta",
      component: OnlyDesktopFnCta,
      state: {
        active: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/pages/onlyDesktop/index.js
  modules_exports2.useComponent([OnlyDesktopCta]);
  var onlyDesktop = async () => {
    const { data: letteringMob } = await loadTextContent({
      source: "./asset/svg/lettering-mob-only-desktop.svg?v=0.1"
    });
    return renderHtml`
        <div class="l-only-desktop">
            <div class="l-only-desktop__content">
                <h4 class="l-only-desktop__title">
                    This site is available only on desktop<br />
                    .. at now
                </h4>
                <div>
                    <only-desktop-cta></only-desktop-cta>
                </div>
                <div class="l-only-desktop__svg">${letteringMob}</div>
            </div>
        </div>
    `;
  };

  // src/js/component/pages/async-timeline/animation/animation.js
  var asyncTimelineanimation = ({ canvas, disableOffcanvas }) => {
    const { useOffscreen, context } = getCanvasContext({ disableOffcanvas });
    let isActive2 = true;
    let ctx = canvas.getContext(context, { alpha: true });
    const activeRoute = modules_exports2.getActiveRoute();
    let { offscreen, offScreenCtx } = getOffsetCanvas({ useOffscreen, canvas });
    let wichContext = useOffscreen ? offScreenCtx : ctx;
    const useRadius = roundRectIsSupported(
      /** @type {CanvasRenderingContext2D} */
      wichContext
    );
    wichContext = null;
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    const numberOfRow = 10;
    const numberOfColumn = 10;
    const cellWidth = window.innerHeight / 18;
    const cellHeight = window.innerHeight / 18;
    const gutter = 1;
    let gridData = createGrid({
      canvas,
      numberOfRow,
      numberOfColumn,
      cellWidth,
      cellHeight,
      gutter
    }).items;
    let data = gridData.map((item) => {
      return {
        ...item,
        scale: 1,
        rotate: 0
      };
    });
    const getCoordinate = ({ row, col }) => {
      const rowIndex = (numberOfColumn + 1) * row;
      return data[rowIndex + col];
    };
    const initialTweenAroundData = {
      ...getCoordinate({ row: 1, col: 1 }),
      scale: 1,
      rotate: 0
    };
    let tweenAroundTarget = initialTweenAroundData;
    const initialTweenRotateData = {
      ...getCoordinate({ row: 4, col: 5 }),
      scale: 1,
      rotate: 0
    };
    let tweenRotateTarget = initialTweenRotateData;
    let tweenGrid = tween_exports.createTimeTween({
      ease: "easeInOutQuad",
      stagger: {
        each: 10,
        from: "edges"
      },
      data: { scale: 1, rotate: 0 }
    });
    let tweenAround = tween_exports.createTimeTween({
      data: tweenAroundTarget,
      duration: 1e3,
      ease: "easeInOutBack"
    });
    let tweenGridRotate = tween_exports.createSpring({
      data: tweenRotateTarget
    });
    data.forEach((item) => {
      tweenGrid.subscribeCache(item, ({ scale, rotate }) => {
        item.rotate = rotate;
        item.scale = scale;
      });
    });
    tweenAround.subscribe((data2) => {
      tweenAroundTarget = data2;
    });
    tweenGridRotate.subscribe((data2) => {
      tweenRotateTarget = data2;
    });
    let gridTimeline = timeline_exports.createAsyncTimeline({
      repeat: -1,
      autoSet: false,
      yoyo: true
    });
    gridTimeline.goTo(
      tweenGrid,
      { scale: 0.2, rotate: 90 },
      { duration: 1e3 }
    );
    let timeline = timeline_exports.createAsyncTimeline({
      repeat: -1,
      yoyo: true,
      autoSet: false
    });
    timeline.goTo(tweenAround, {
      x: getCoordinate({ row: 1, col: 8 }).x,
      rotate: 360,
      scale: 2
    }).createGroup({ waitComplete: false }).goTo(tweenAround, {
      y: getCoordinate({ row: 8, col: 8 }).y,
      rotate: 180
    }).goTo(
      tweenGridRotate,
      { y: getCoordinate({ row: 0, col: 8 }).y },
      { delay: 500 }
    ).closeGroup().label({ name: "my-label" }).createGroup({ waitComplete: false }).goTo(tweenAround, {
      x: getCoordinate({ row: 8, col: 1 }).x,
      rotate: 0,
      scale: 1
    }).goTo(
      tweenGridRotate,
      {
        rotate: 360,
        scale: 2
      },
      { delay: 0 }
    ).closeGroup().createGroup({ waitComplete: false }).goTo(
      tweenAround,
      { y: getCoordinate({ row: 1, col: 1 }).y, rotate: -180 },
      { duration: 1e3 }
    ).goTo(
      tweenGridRotate,
      {
        rotate: 0,
        y: getCoordinate({ row: 8, col: 8 }).y,
        scale: 1
      },
      { delay: 200 }
    ).closeGroup();
    const draw = () => {
      if (!ctx) return;
      if (useOffscreen && offscreen) {
        offscreen.width = canvas.width;
        offscreen.height = canvas.height;
      }
      const context2 = useOffscreen ? offScreenCtx : (
        /** @type {CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D} */
        ctx
      );
      if (!context2) return;
      canvas.width = canvas.width;
      data.forEach(
        ({
          x,
          y,
          width,
          height,
          rotate,
          scale,
          offsetXCenter,
          offsetYCenter
        }, index) => {
          if (index === 40) {
            {
              const rotation2 = Math.PI / 180 * tweenAroundTarget.rotate;
              const xx2 = Math.cos(rotation2) * tweenAroundTarget.scale;
              const xy2 = Math.sin(rotation2) * tweenAroundTarget.scale;
              context2.setTransform(
                xx2,
                xy2,
                -xy2,
                xx2,
                Math.floor(
                  tweenAroundTarget.offsetXCenter + tweenAroundTarget.x
                ),
                Math.floor(
                  tweenAroundTarget.offsetYCenter + tweenAroundTarget.y
                )
              );
              if (useRadius) {
                context2.beginPath();
                context2.roundRect(
                  Math.floor(-tweenAroundTarget.width / 2),
                  Math.floor(-tweenAroundTarget.height / 2),
                  Math.floor(tweenAroundTarget.width),
                  tweenAroundTarget.height,
                  5
                );
              } else {
                context2.beginPath();
                context2.rect(
                  Math.floor(-tweenAroundTarget.width / 2),
                  Math.floor(-tweenAroundTarget.height / 2),
                  Math.floor(tweenAroundTarget.width),
                  Math.floor(tweenAroundTarget.height)
                );
              }
              context2.fillStyle = "#000000";
              context2.fill();
            }
          }
          const rotation = Math.PI / 180 * rotate;
          const xx = Math.cos(rotation) * scale;
          const xy = Math.sin(rotation) * scale;
          context2.setTransform(
            xx,
            xy,
            -xy,
            xx,
            Math.floor(offsetXCenter + x),
            Math.floor(offsetYCenter + y)
          );
          if (useRadius) {
            context2.beginPath();
            context2.roundRect(
              Math.floor(-width / 2),
              Math.floor(-height / 2),
              width,
              height,
              5
            );
          } else {
            context2.beginPath();
            context2.rect(
              Math.floor(-width / 2),
              Math.floor(-height / 2),
              width,
              height
            );
          }
          context2.strokeStyle = `#000`;
          context2.fillStyle = `rgba(238, 238, 238, 0.9)`;
          context2.stroke();
          context2.fill();
        }
      );
      {
        const rotation = Math.PI / 180 * tweenRotateTarget.rotate;
        const xx = Math.cos(rotation) * tweenRotateTarget.scale;
        const xy = Math.sin(rotation) * tweenRotateTarget.scale;
        context2.setTransform(
          xx,
          xy,
          -xy,
          xx,
          Math.floor(
            tweenRotateTarget.offsetXCenter + tweenRotateTarget.x
          ),
          Math.floor(
            tweenRotateTarget.offsetYCenter + tweenRotateTarget.y
          )
        );
        if (useRadius) {
          context2.beginPath();
          context2.roundRect(
            Math.floor(-tweenRotateTarget.width / 2),
            Math.floor(-tweenRotateTarget.height / 2),
            Math.floor(tweenRotateTarget.width),
            Math.floor(tweenRotateTarget.height),
            5
          );
        } else {
          context2.beginPath();
          context2.rect(
            Math.floor(-tweenRotateTarget.width / 2),
            Math.floor(-tweenRotateTarget.height / 2),
            Math.floor(tweenRotateTarget.width),
            Math.floor(tweenRotateTarget.height)
          );
        }
        context2.fillStyle = "#a86464";
        context2.fill();
      }
      copyCanvasBitmap({ useOffscreen, offscreen, ctx });
    };
    const loop = () => {
      draw();
      if (!isActive2) return;
      modules_exports.useNextFrame(() => loop());
    };
    modules_exports.useFrame(() => {
      loop();
    });
    const unWatchPause = navigationStore.watch(
      "navigationIsOpen",
      modules_exports.useDebounce((val2) => {
        if (val2) {
          timeline.pause();
          gridTimeline.pause();
          isActive2 = false;
          return;
        }
        setTimeout(async () => {
          const currentRoute = modules_exports2.getActiveRoute();
          if (currentRoute.route !== activeRoute.route) return;
          timeline.resume();
          gridTimeline.resume();
          isActive2 = true;
          modules_exports.useFrame(() => loop());
        }, 200);
      }, 200)
    );
    return {
      destroy: () => {
        unWatchPause();
        ctx = null;
        offscreen = null;
        offScreenCtx = null;
        gridData = [];
        data = [];
        isActive2 = false;
        tweenGrid?.destroy?.();
        tweenAround?.destroy?.();
        tweenGridRotate?.destroy?.();
        timeline?.destroy?.();
        gridTimeline?.destroy?.();
        tweenGrid = null;
        tweenAround = null;
        tweenGridRotate = null;
        timeline = null;
        gridTimeline = null;
      },
      play: () => {
        timeline.play();
        if (!gridTimeline.isActive()) gridTimeline.play();
      },
      playReverse: () => {
        timeline.playReverse();
        if (!gridTimeline.isActive()) gridTimeline.play();
      },
      playFromLabel: () => {
        timeline.setTween("my-label", [tweenAround, tweenGridRotate]).then(() => {
          timeline.playFrom("my-label").then(() => {
            console.log("resolve promise playFrom");
          });
        });
        if (!gridTimeline.isActive()) gridTimeline.play();
      },
      playFromLabelReverse: () => {
        timeline.setTween("my-label", [tweenAround, tweenGridRotate]).then(() => {
          timeline.playFromReverse("my-label").then(() => {
            console.log("resolve promise playFrom");
          });
        });
        if (!gridTimeline.isActive()) gridTimeline.play();
      },
      revertNext: () => {
        timeline.reverseNext();
      },
      pause: () => {
        timeline.pause();
        gridTimeline.pause();
      },
      resume: () => {
        timeline.resume();
        gridTimeline.resume();
      },
      stop: () => {
        timeline.stop();
        gridTimeline.stop();
      }
    };
  };

  // src/js/component/pages/async-timeline/async-timeline.js
  function getControls3({ buttons: buttons5 }) {
    return Object.entries(buttons5).map(([className, value]) => {
      const { label } = value;
      return renderHtml` <li class="c-canvas__controls__item">
                <button
                    type="button"
                    class="c-canvas__controls__btn ${className}"
                >
                    ${label}
                </button>
            </li>`;
    }).join("");
  }
  var AsyncTimelineFn = ({
    onMount,
    getState,
    setRef,
    getRef,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    document.body.style.background = canvasBackground;
    let methods = {};
    let destroy3 = () => {
    };
    onMount(({ element }) => {
      const { canvas } = getRef();
      methods = asyncTimelineanimation({
        canvas,
        ...getState()
      });
      destroy3 = methods.destroy;
      const unsubscribeResize = modules_exports.useResize(() => {
        destroy3();
        methods = asyncTimelineanimation({
          canvas,
          ...getState()
        });
        destroy3 = methods.destroy;
        methods?.play?.();
      });
      Object.entries(proxi.buttons).forEach(([className, value]) => {
        const { method } = value;
        const btn = element.querySelector(`.${className}`);
        btn?.addEventListener("click", () => methods?.[method]());
      });
      modules_exports.useFrame(() => {
        proxi.isMounted = true;
      });
      methods?.play?.();
      return () => {
        unsubscribeResize();
        destroy3();
        document.body.style.background = "";
      };
    });
    return renderHtml`
        <div>
            <div class="c-canvas">
                <div
                    class="c-canvas__wrap"
                    ${bindEffect({
      toggleClass: { active: () => proxi.isMounted }
    })}
                >
                    <ul class="c-canvas__controls">
                        ${getControls3({ buttons: proxi.buttons })}
                    </ul>
                    <canvas ${setRef("canvas")}></canvas>
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/pages/async-timeline/definition.js
  var buttons4 = {
    "js-async-timeline-play": {
      label: "play",
      method: "play"
    },
    "js-async-timeline-playReverse": {
      label: "play reverse",
      method: "playReverse"
    },
    "js-async-timeline-play-label": {
      label: "play from label",
      method: "playFromLabel"
    },
    "js-async-timeline-playReverse-label": {
      label: "play from label reverse",
      method: "playFromLabelReverse"
    },
    "js-async-timeline-pause": {
      label: "pause",
      method: "pause"
    },
    "js-async-timeline-resume": {
      label: "resume",
      method: "resume"
    },
    "js-async-timeline-revert-next": {
      label: "revert next",
      method: "revertNext"
    },
    "js-async-timeline-stop": {
      label: "stop",
      method: "stop"
    }
  };
  var AsyncTimeline = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').AsyncTimeline>} */
    {
      tag: "async-timeline",
      component: AsyncTimelineFn,
      exportState: ["disableOffcanvas"],
      state: {
        isMounted: false,
        disableOffcanvas: () => ({
          value: detectFirefox() || detectSafari() ? true : false,
          type: Boolean
        }),
        buttons: () => ({
          value: buttons4,
          type: "Any"
        })
      }
    }
  );

  // src/js/pages/canvas/async-timeline/index.js
  modules_exports2.useComponent([AsyncTimeline]);
  var asyncTimeline = () => {
    updateQuickNavState({
      active: true,
      prevRoute: "#caterpillarN2",
      nextRoute: "#animatedPatternN0?version=0&activeId=0",
      backRoute: "#canvas-overview",
      color: "black"
    });
    return renderHtml`<div class="l-padding">
        <async-timeline
            ${modules_exports2.staticProps(
      /** @type {import('@pagesComponent/async-timeline/type').AsyncTimeline['state']} */
      {
        disableOffcanvas: false
      }
    )}
        ></async-timeline
    </div>`;
  };

  // src/js/pages/svg/rdp/data.js
  var rdp_01_scehema = ({
    letter_d,
    letter_p,
    letter_r,
    letter_r_shadow,
    letter_d_shadow,
    letter_p_shadow,
    letter_r_pieces,
    letter_d_pieces,
    letter_p_pieces,
    letter_r_fill,
    letter_d_fill,
    letter_p_fill
  }) => {
    return [
      {
        props: {
          id: 0,
          depth: 200,
          anchorPoint: "center",
          classList: "",
          animate: true
        },
        children: [
          {
            props: {
              id: 0,
              depth: 100,
              offsetX: "-2",
              offsetY: "-2",
              anchorPoint: "center",
              classList: "",
              animate: true,
              component: {
                tagName: "any-component",
                className: "u-any-center-svg l-rdp-01__block",
                props: {
                  content: letter_d
                }
              }
            },
            children: [
              {
                props: {
                  id: 0,
                  depth: -10,
                  initialDepth: -1,
                  anchorPoint: "center",
                  classList: "",
                  animate: true,
                  component: {
                    tagName: "any-component",
                    className: "u-any-center-svg l-rdp-01__block",
                    props: {
                      content: letter_d_shadow
                    }
                  }
                },
                children: []
              },
              {
                props: {
                  id: 0,
                  depth: 40,
                  anchorPoint: "center",
                  classList: "",
                  animate: true,
                  component: {
                    tagName: "any-component",
                    className: "u-any-center-svg l-rdp-01__block",
                    props: {
                      content: letter_d_pieces
                    }
                  }
                },
                children: []
              },
              {
                props: {
                  id: 0,
                  depth: 100,
                  anchorPoint: "center",
                  classList: "",
                  animate: true,
                  component: {
                    tagName: "any-component",
                    className: "u-any-center-svg l-rdp-01__block",
                    props: {
                      content: letter_d_fill
                    }
                  }
                },
                children: []
              },
              {
                props: {
                  id: 0,
                  depth: -100,
                  initialDepth: -1,
                  offsetX: "-10",
                  anchorPoint: "right",
                  rotate: "y",
                  classList: "",
                  animate: true,
                  component: {
                    tagName: "any-component",
                    className: "u-any-center-svg l-rdp-01__block",
                    props: {
                      content: letter_r
                    }
                  }
                },
                children: [
                  {
                    props: {
                      id: 0,
                      depth: -10,
                      initialDepth: -1,
                      anchorPoint: "center",
                      rotate: "y",
                      classList: "",
                      animate: true,
                      component: {
                        tagName: "any-component",
                        className: "u-any-center-svg l-rdp-01__block",
                        props: {
                          content: letter_r_shadow
                        }
                      }
                    },
                    children: []
                  },
                  {
                    props: {
                      id: 0,
                      depth: 20,
                      anchorPoint: "center",
                      classList: "",
                      animate: true,
                      component: {
                        tagName: "any-component",
                        className: "u-any-center-svg l-rdp-01__block",
                        props: {
                          content: letter_r_pieces
                        }
                      }
                    },
                    children: []
                  },
                  {
                    props: {
                      id: 0,
                      depth: 30,
                      initialDepth: 1,
                      anchorPoint: "center",
                      classList: "",
                      animate: true,
                      component: {
                        tagName: "any-component",
                        className: "u-any-center-svg l-rdp-01__block",
                        props: {
                          content: letter_r_fill
                        }
                      }
                    },
                    children: []
                  }
                ]
              },
              {
                props: {
                  id: 0,
                  depth: -100,
                  initialDepth: -1,
                  offsetX: "-10",
                  anchorPoint: "right",
                  classList: "",
                  animate: true,
                  component: {
                    tagName: "any-component",
                    className: "u-any-center-svg l-rdp-01__block",
                    props: {
                      content: letter_p
                    }
                  }
                },
                children: [
                  {
                    props: {
                      id: 0,
                      depth: -10,
                      initialDepth: -1,
                      anchorPoint: "center",
                      rotate: "y",
                      classList: "",
                      animate: true,
                      component: {
                        tagName: "any-component",
                        className: "u-any-center-svg l-rdp-01__block",
                        props: {
                          content: letter_p_shadow
                        }
                      }
                    },
                    children: []
                  },
                  {
                    props: {
                      id: 0,
                      depth: 20,
                      anchorPoint: "center",
                      classList: "",
                      animate: true,
                      component: {
                        tagName: "any-component",
                        className: "u-any-center-svg l-rdp-01__block",
                        props: {
                          content: letter_p_pieces
                        }
                      }
                    },
                    children: []
                  },
                  {
                    props: {
                      id: 0,
                      depth: 30,
                      initialDepth: 1,
                      anchorPoint: "center",
                      classList: "",
                      animate: true,
                      component: {
                        tagName: "any-component",
                        className: "u-any-center-svg l-rdp-01__block",
                        props: {
                          content: letter_p_fill
                        }
                      }
                    },
                    children: []
                  }
                ]
              }
            ]
          }
        ]
      }
    ];
  };

  // src/js/pages/svg/rdp/index.js
  modules_exports2.useComponent([Move3D, AnyComponent]);
  var rdp = async () => {
    const { data: lettering012 } = await loadTextContent({
      source: "./asset/svg/rdp.svg?v=0.4"
    });
    const [
      letter_d,
      letter_r,
      letter_p,
      letter_r_shadow,
      letter_d_shadow,
      letter_p_shadow,
      letter_r_pieces,
      letter_d_pieces,
      letter_p_pieces,
      letter_r_fill,
      letter_d_fill,
      letter_p_fill
    ] = [
      "letter_d",
      "letter_r",
      "letter_p",
      "letter_r_shadow",
      "letter_d_shadow",
      "letter_p_shadow",
      "letter_r_pieces",
      "letter_d_pieces",
      "letter_p_pieces",
      "letter_r_fill",
      "letter_d_fill",
      "letter_p_fill"
    ].map((id) => {
      return parseSvg({
        svg: lettering012,
        id
      });
    });
    updateQuickNavState({
      active: true,
      prevRoute: "",
      nextRoute: "#mob-01",
      backRoute: "#svg-overview",
      color: "black"
    });
    return renderHtml`<div class="l-rdp-01">
        <move-3d
            ${modules_exports2.staticProps(
      /** @type {import('@commonComponent/move-3d/type').Move3D['state']} */
      {
        shape: rdp_01_scehema({
          letter_d,
          letter_r,
          letter_p,
          letter_r_shadow,
          letter_d_shadow,
          letter_p_shadow,
          letter_r_pieces,
          letter_d_pieces,
          letter_p_pieces,
          letter_r_fill,
          letter_d_fill,
          letter_p_fill
        }),
        xDepth: 100,
        yDepth: 30,
        factor: 20,
        xLimit: 20,
        yLimit: 20,
        drag: true,
        perspective: 1e3
      }
    )}
        ></move-3d>
    </div>`;
  };

  // src/js/pages/index.js
  var PAGE_TEMPLATE_COMPONENT_MOBJS = "templateMobJsComponent";
  var PAGE_TEMPLATE_DOCS_DEFAULT = "templateDocDefault";
  var PAGE_TEMPLATE_LINKS = "templateLinks";
  var PAGE_TEMPLATE_ANIMATION = "templateAnimation";
  var mobJsComponentBreadCrumbs = [
    {
      url: "./#mobJs-overview",
      title: "mobJs"
    },
    {
      url: "./#mobJs-component",
      title: "component"
    }
  ];
  var mobJsOverviewBreadCrumbs = [
    {
      url: "./#mobJs-overview",
      title: "mobJs"
    }
  ];
  var mobCoreOverviewBreadCrumbs = [
    {
      url: "./#mobCore-overview",
      title: "mobCore"
    }
  ];
  var mobMotionOverviewBreadCrumbs = [
    {
      url: "./#mobMotion-overview",
      title: "mobMotion"
    }
  ];
  var routes = [
    {
      name: "pageNotFound",
      layout: pageNotFound2,
      props: {}
    },
    {
      name: "onlyDesktop",
      layout: onlyDesktop,
      props: {}
    },
    {
      name: "about",
      layout: layoutAbout,
      templateName: "about",
      props: {}
    },
    {
      name: "canvas-overview",
      layout: layoutLinksPage,
      templateName: PAGE_TEMPLATE_LINKS,
      props: {
        source: "./data/canvas/data.json"
      }
    },
    {
      name: "animatedPatternN0",
      layout: animatedPatternN0,
      templateName: PAGE_TEMPLATE_ANIMATION,
      props: {}
    },
    {
      name: "animatedPatternN1",
      layout: animatedPatternN1,
      templateName: PAGE_TEMPLATE_ANIMATION,
      props: {}
    },
    {
      name: "caterpillarN0",
      layout: caterpillarN0,
      templateName: PAGE_TEMPLATE_ANIMATION,
      props: {}
    },
    {
      name: "caterpillarN1",
      layout: caterpillarN1,
      templateName: PAGE_TEMPLATE_ANIMATION,
      props: {}
    },
    {
      name: "caterpillarN2",
      layout: caterpillarN2,
      templateName: PAGE_TEMPLATE_ANIMATION,
      props: {}
    },
    {
      name: "async-timeline",
      layout: asyncTimeline,
      templateName: PAGE_TEMPLATE_ANIMATION,
      props: {}
    },
    {
      name: "scrollerN0",
      layout: scrollerN0,
      templateName: PAGE_TEMPLATE_ANIMATION,
      props: {}
    },
    {
      name: "scrollerN1",
      layout: scrollerN1,
      templateName: PAGE_TEMPLATE_ANIMATION,
      props: {}
    },
    {
      name: "dynamic-list",
      layout: dynamic_list,
      props: {
        source: "./data/mob-js/general-repeat-test.json",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        title: "( test ) repeat & invalidate",
        section: "mobJs"
      }
    },
    {
      name: "matrioska",
      layout: matrioska_page,
      props: {
        source: "./data/mob-js/matrioska.json",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        title: "( test ) matrioska",
        section: "mobJs"
      }
    },
    {
      name: "home",
      layout: home,
      templateName: "home",
      props: {}
    },
    {
      name: "mobCore-overview",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-core/overview.json",
        title: "mobCore",
        breadCrumbs: [],
        section: "mobCore"
      }
    },
    {
      name: "mobCore-defaults",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-core/defaults.json",
        title: "Defaults",
        breadCrumbs: mobCoreOverviewBreadCrumbs,
        section: "mobCore"
      }
    },
    {
      name: "mobCore-events",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-core/events.json",
        title: "Events",
        breadCrumbs: mobCoreOverviewBreadCrumbs,
        section: "mobCore"
      }
    },
    {
      name: "mobCore-store",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-core/store.json",
        title: "Store",
        breadCrumbs: mobCoreOverviewBreadCrumbs,
        section: "mobCore"
      }
    },
    {
      name: "mobJs-overview",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-js/overview.json",
        title: "mobJs",
        breadCrumbs: [],
        section: "mobJs"
      }
    },
    {
      name: "mobJs-initialization",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-js/initialization.json",
        title: "initialization",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-component",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-js/component.json",
        title: "component",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-routing",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-js/routing.json",
        title: "routing",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-benchmark-invalidate",
      layout: benchMark,
      props: {
        rootComponent: "benchmark-invalidate",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        source: "./data/mob-js/benchmark-invalidate.json",
        title: "( test ) benchmark invalidate",
        section: "mobJs"
      }
    },
    {
      name: "mobJs-benchmark-repeat-no-key",
      layout: benchMark,
      props: {
        rootComponent: "benchmark-repeat-no-key",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        source: "./data/mob-js/benchmark-repeat-without-key.json",
        title: "( test ) benchmark repeat without key",
        section: "mobJs"
      }
    },
    {
      name: "mobJs-benchmark-repeat-key",
      layout: benchMark,
      props: {
        rootComponent: "benchmark-repeat-key",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        source: "./data/mob-js/benchmark-repeat-key.json",
        title: "( test ) benchmark repeat key",
        section: "mobJs"
      }
    },
    {
      name: "mobJs-benchmark-repeat-no-key-nested",
      layout: benchMark,
      props: {
        rootComponent: "benchmark-repeat-key-no-nested",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        source: "./data/mob-js/benchmark-repeat-without-key-nested.json",
        title: "( test ) benchmark repeat nested without key",
        section: "mobJs"
      }
    },
    {
      name: "mobJs-benchmark-repeat-key-nested",
      layout: benchMark,
      props: {
        rootComponent: "benchmark-repeat-key-nested",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        source: "./data/mob-js/benchmark-repeat-key-nested.json",
        title: "( test ) benchmark repeat nested with key",
        section: "mobJs"
      }
    },
    {
      name: "mobJs-benchmark-repeat-key-bind-store",
      layout: benchMark,
      props: {
        rootComponent: "benchmark-repeat-no-key-bind-store",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        source: "./data/mob-js/benchmark-repeat-external.json",
        title: "( test ) benchmark repeat bindStore",
        section: "mobJs"
      }
    },
    {
      name: "mobJs-tick",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-js/tick.json",
        title: "tick",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-utils",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-js/utils.json",
        title: "utils",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-memory-management",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-js/memory-management.json",
        title: "memory management",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-debug",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-js/debug.json",
        title: "debug",
        breadCrumbs: mobJsOverviewBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-onMount",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/on-mount.json",
        title: "onMount",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-getState",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/get-state.json",
        title: "getState",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-setState",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/set-state.json",
        title: "setState",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-updateState",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/update-state.json",
        title: "updateState",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-getProxi",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/get-proxi.json",
        title: "getProxi",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-watch",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/watch.json",
        title: "watch",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-staticProps",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/static-props.json",
        title: "staticProps",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-dataAttribute",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/data-attribute.json",
        title: "dataAttribute",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-bindProps",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/bind-props.json",
        title: "bindProps",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-bindEvents",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/bind-events.json",
        title: "bindEvents",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-delegateEvents",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/delegate-events.json",
        title: "delegateEvents",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-bindtext",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/bind-text.json",
        title: "bindText",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-bindObject",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/bind-object.json",
        title: "bindObject",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-bind-effect",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/bind-effect.json",
        title: "bindEffect",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-methods",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/methods.json",
        title: "add methods",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-useMethodByName",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/use-method-by-name.json",
        title: "useMethodByName",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-useMethodArrayByName",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/use-method-array-by-name.json",
        title: "useMethodArrayByName",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-setStateByName",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/set-state-by-name.json",
        title: "setStateByName",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-updateStateByName",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/update-state-by-name.json",
        title: "updateStateByName",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-refs",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/refs.json",
        title: "refs",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-runtime",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/runtime.json",
        title: "renderComponent",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-repeat",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/repeat.json",
        title: "repeat",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-invalidate",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/invalidate.json",
        title: "invalidate",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-invalidate-vs-repeater",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/invalidate-vs-repeater.json",
        title: "invalidate vs repeater",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-web-component",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/web-component.json",
        title: "webComponent",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-slot",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/slot.json",
        title: "slot",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-unBind",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/unbind.json",
        title: "unBind",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-emit",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/emit.json",
        title: "emit",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-emitAsync",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/emit-async.json",
        title: "emitAsync",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-computed",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/computed.json",
        title: "computed",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-bindStore",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/bind-store.json",
        title: "bindStore",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-removeDom",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/remove-dom.json",
        title: "removeDom",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-remove",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/remove.json",
        title: "remove",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-getChildren",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/get-children.json",
        title: "getChildren",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-freezeProp",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/freeze-prop.json",
        title: "freezeProp",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-unFreezeProp",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/unfreeze-prop.json",
        title: "unFreezeProp",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-getParentId",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/get-parent-id.json",
        title: "getParentId",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-watchParent",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/watch-parent.json",
        title: "watchParent",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-instanceName",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/instance-name.json",
        title: "instanceName",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobJs-class-list",
      templateName: PAGE_TEMPLATE_COMPONENT_MOBJS,
      layout: layoutSidebarLinks,
      props: {
        source: "./data/mob-js/class-list.json",
        title: "classList",
        breadCrumbs: mobJsComponentBreadCrumbs,
        section: "mobJs"
      }
    },
    {
      name: "mobMotion-stagger",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-motion/stagger.json",
        title: "Stagger",
        breadCrumbs: mobMotionOverviewBreadCrumbs,
        section: "mobMotion"
      }
    },
    {
      name: "mobMotion-defaults",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-motion/defaults.json",
        title: "Defaults",
        breadCrumbs: mobMotionOverviewBreadCrumbs,
        section: "mobMotion"
      }
    },
    {
      name: "mobMotion-overview",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-motion/overview.json",
        title: "mobMotion",
        breadCrumbs: [],
        section: "mobMotion"
      }
    },
    {
      name: "mobMotion-parallax",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-motion/parallax.json",
        title: "Parallax",
        breadCrumbs: mobMotionOverviewBreadCrumbs,
        section: "mobMotion"
      }
    },
    {
      name: "mobMotion-sequencer",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-motion/sequencer.json",
        title: "Sequencer",
        breadCrumbs: mobMotionOverviewBreadCrumbs,
        section: "mobMotion"
      }
    },
    {
      name: "mobMotion-scrolltrigger",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-motion/scroll-trigger.json",
        title: "ScrollTrigger",
        breadCrumbs: mobMotionOverviewBreadCrumbs,
        section: "mobMotion"
      }
    },
    {
      name: "mobMotion-sync-timeline",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-motion/sync-timeline.json",
        title: "Synctimeline",
        breadCrumbs: mobMotionOverviewBreadCrumbs,
        section: "mobMotion"
      }
    },
    {
      name: "mobMotion-create-stagger",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-motion/create-stagger.json",
        title: "CreateStagger",
        breadCrumbs: mobMotionOverviewBreadCrumbs,
        section: "mobMotion"
      }
    },
    {
      name: "mobMotion-async-timeline",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-motion/async-timeline.json",
        title: "Asynctimeline",
        breadCrumbs: mobMotionOverviewBreadCrumbs,
        section: "mobMotion"
      }
    },
    {
      name: "mobMotion-tween-spring-lerp",
      layout: layoutSidebarAnchor,
      templateName: PAGE_TEMPLATE_DOCS_DEFAULT,
      props: {
        source: "./data/mob-motion/tween-spring-lerp.json",
        title: "TimeTween Spring Lerp",
        breadCrumbs: mobMotionOverviewBreadCrumbs,
        section: "mobMotion"
      }
    },
    {
      name: "horizontalScroller",
      layout: horizontalScroller,
      templateName: PAGE_TEMPLATE_ANIMATION,
      restoreScroll: false,
      props: {}
    },
    {
      name: "plugin-overview",
      layout: layoutLinksPage,
      templateName: PAGE_TEMPLATE_LINKS,
      props: {
        source: "./data/plugin/data.json"
      }
    },
    {
      name: "move3D-shape1",
      templateName: PAGE_TEMPLATE_ANIMATION,
      layout: move3DRoute,
      props: move3DrouteProps.shape1
    },
    {
      name: "svg-overview",
      layout: layoutLinksPage,
      templateName: PAGE_TEMPLATE_LINKS,
      props: {
        source: "./data/svg/data.json"
      }
    },
    {
      name: "mob-01",
      layout: lettering01,
      templateName: PAGE_TEMPLATE_ANIMATION,
      props: {}
    },
    {
      name: "rdp-01",
      layout: rdp,
      templateName: PAGE_TEMPLATE_ANIMATION,
      props: {}
    }
  ];

  // src/js/utils/scrollbar-with.js
  var setValue = () => {
    const value = window.innerWidth - document.documentElement.clientWidth;
    document.documentElement.style.setProperty(
      "--scrollbar-with",
      `${value}px`
    );
  };
  var getScrollbarWith = () => {
    setValue();
    modules_exports.useResize(() => {
      setValue();
    });
  };

  // src/js/component/common/debug/debug-overlay/constant.js
  var RESET_FILTER_DEBUG = "reset";
  var DEBUG_USE_TREE = "tree";
  var DEBUG_USE_FILTER_COMPONENT = "filter_component";

  // src/js/component/lib/animation/vertical-scroller.js
  var verticalScroller = ({ screen, scroller, scrollbar }) => {
    let instance;
    return {
      init: () => {
        if (instance) return;
        instance = new MobSmoothScroller({
          screen,
          scroller,
          direction: "vertical",
          drag: true,
          scopedEvent: false,
          breakpoint: "desktop",
          onTick: ({ percent }) => {
            scrollbar.value = `${percent}`;
          },
          afterRefresh: ({ shouldScroll }) => {
            scrollbar?.classList.toggle(
              "hide-scrollbar",
              !shouldScroll
            );
          }
        });
        instance.init();
      },
      destroy: () => {
        instance?.destroy();
        instance = null;
      },
      refresh: () => {
        instance?.refresh();
      },
      updateScroller: () => {
        if (!instance) return;
        const scrollerHeight = outerHeight(scroller);
        const screenHeight = outerHeight(screen);
        const scrollBarHeight = outerWidth(scrollbar);
        const thumbWidth = screenHeight / scrollerHeight * scrollBarHeight;
        scrollbar.style.setProperty("--thumb-width", `${thumbWidth}px`);
        instance?.refresh();
      },
      move: (val2) => {
        if (!instance) return;
        instance.move(val2).catch(() => {
        });
      },
      goToTop: () => {
        instance?.set(0);
      }
    };
  };

  // src/js/stores/debug/index.js
  var debugActiveComponentStore = modules_exports.createStore(
    /** @type {MobStoreParams<import('./type').DebugActiveComponentStore>} */
    {
      currentId: () => ({
        value: "",
        type: String
      })
    }
  );

  // src/js/component/common/debug/debug-overlay/debug-component/debug-component.js
  var getClassList = (value) => {
    if (!value) return "";
    return [...value].reduce(
      (previous, current) => `${previous}.${current}`,
      ""
    );
  };
  var getObjectKeys = (methods) => {
    return Object.keys(methods).reduce((previous, current) => {
      return `${previous} ${current},`;
    }, "");
  };
  var getChild = (child) => {
    return Object.entries(child).map(([key, value]) => {
      return renderHtml`<div>
                <strong>${key}:</strong>
                ${value.map((item) => renderHtml`${item}, `).join(".")}
            </div>`;
    }).join("");
  };
  var getFreezeProp = (props) => {
    if (!props) return "";
    return props.map((prop) => `${prop}, `).join("");
  };
  var getStateProps = (states) => {
    return Object.entries(
      /** @type {any[]} */
      states
    ).map(([key, value]) => {
      return renderHtml`<div>
                <strong>${key}:</strong>
                ${JSON.stringify(value)}
            </div>`;
    }).join("");
  };
  var getContent = ({ getState }) => {
    const { id } = getState();
    if (id === RESET_FILTER_DEBUG) return "";
    const item = modules_exports2.componentMap.get(id);
    if (!item) return `component not found`;
    return renderHtml`<div>
        <!-- Basic props -->
        <div><strong>id</strong>: ${id}</div>
        <div><strong>parent id</strong>: ${item.parentId}</div>
        <div>
            <strong>component root</strong>:
            ${item.element.tagName}${getClassList(item.element.classList)}
        </div>
        <div><strong>componentName</strong>: ${item.componentName}</div>
        <div><strong>instance name:</strong>: ${item.instanceName}</div>
        <div><strong>methods:</strong>: ${getObjectKeys(item.methods)}</div>
        <div><strong>refs:</strong>: ${getObjectKeys(item.refs)}</div>
        <div><strong>persistent:</strong>: ${item.persistent}</div>

        <!-- Children -->
        <h3 class="c-debug-component__section-title">Children:</h3>
        <div>${getChild(item?.child ?? {})}</div>

        <!-- Repeater -->
        <h3 class="c-debug-component__section-title">Repeater props:</h3>
        <div>
            <strong>component repeater id</strong>: ${item.componentRepeatId}
        </div>
        <div><strong>repeater state bind</strong>: ${item.repeatPropBind}</div>
        <div>
            <strong>repeater inner wrapper</strong>:
            ${item?.repeaterInnerWrap?.tagName}${getClassList(
      item?.repeaterInnerWrap?.classList
    )}
        </div>
        <div><strong>repeat key</strong>: ${item.key}</div>
        <div>
            <strong>repeat current state</strong>:
            ${JSON.stringify(item.currentRepeaterState?.current)}
        </div>
        <div>
            <strong>repeat current index</strong>:
            ${JSON.stringify(item.currentRepeaterState?.index)}
        </div>

        <!-- State -->
        <h3 class="c-debug-component__section-title">State:</h3>
        <div>
            <strong>Freezed prop:</strong>
            ${getFreezeProp(item?.freezedPros)}
        </div>
        <div>
            <h4 class="c-debug-component__section-subtitle">
                States current values:
            </h4>
            ${getStateProps(item.state.get())}
        </div>
        <div>
            <h4 class="c-debug-component__section-subtitle">
                States current validation:
            </h4>
            ${getStateProps(item.state.getValidation())}
        </div>
    </div>`;
  };
  var initScroller = ({ getRef }) => {
    const { screen, scroller, scrollbar } = getRef();
    scrollbar.addEventListener("input", () => {
      move3(scrollbar.value);
    });
    const methods = verticalScroller({
      screen,
      scroller,
      scrollbar
    });
    const init8 = methods.init;
    const destroy3 = methods.destroy;
    const refresh = methods.refresh;
    const move3 = methods.move;
    const updateScroller2 = methods.updateScroller;
    init8();
    updateScroller2();
    move3(0);
    return {
      destroy: destroy3,
      move: move3,
      refresh,
      updateScroller: updateScroller2
    };
  };
  var DebugComponentFn = ({
    onMount,
    addMethod,
    getState,
    invalidate,
    setRef,
    getRef,
    watch,
    getProxi,
    emit
  }) => {
    const proxi = getProxi();
    addMethod("updateId", (id) => {
      proxi.id = id;
      debugActiveComponentStore.set("currentId", id);
    });
    addMethod("refreshId", () => {
      emit(() => proxi.id);
    });
    let move3;
    onMount(() => {
      const {
        destroy: destroy3,
        updateScroller: updateScroller2,
        move: moveUpdated,
        refresh
      } = initScroller({
        getRef
      });
      move3 = moveUpdated;
      watch(
        () => proxi.id,
        async () => {
          await modules_exports2.tick();
          refresh();
          updateScroller2();
          move3(0);
        }
      );
      return () => {
        destroy3?.();
      };
    });
    return renderHtml`<div class="c-debug-component" ${setRef("screen")}>
        <input
            type="range"
            id="test"
            name="test"
            min="0"
            max="100"
            value="0"
            step=".5"
            ${setRef("scrollbar")}
            class="c-debug-component__scrollbar"
        />
        <div class="c-debug-component__container" ${setRef("scroller")}>
            ${invalidate({
      observe: () => proxi.id,
      render: () => {
        return getContent({ getState });
      }
    })}
        </div>
    </div>`;
  };

  // src/js/component/common/debug/debug-overlay/debug-component/definition.js
  var DebugComponent = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DebugComponent>} */
    {
      tag: "debug-component",
      component: DebugComponentFn,
      state: {
        id: () => ({
          value: RESET_FILTER_DEBUG,
          type: String,
          skipEqual: false
        })
      }
    }
  );

  // src/js/component/common/debug/debug-overlay/debug-filter/head/debug-filter-head.js
  var refreshList = async (testString = "") => {
    await modules_exports2.tick();
    const methods = modules_exports2.useMethodByName(debugFilterListName);
    methods?.refreshList?.({ testString });
  };
  var DebugFilterHeadFn = ({
    onMount,
    setRef,
    getRef,
    delegateEvents
  }) => {
    onMount(() => {
      refreshList();
      return () => {
        getRef()?.input.remove();
      };
    });
    return renderHtml`<div class="c-debug-filter-head">
        <span class="c-debug-filter-head__title">Filter by tag</span>
        <input
            type="text"
            class="c-debug-filter-head__input"
            value=""
            ${setRef("input")}
            ${delegateEvents({
      keydown: (event) => {
        if (event.code.toLowerCase() === "enter") {
          event.preventDefault();
          const testString = (
            /** @type {HTMLInputElement} */
            event.target.value
          );
          refreshList(testString);
        }
      }
    })}
        />
        <button
            class="c-debug-filter-head__button"
            type="button"
            ${delegateEvents({
      click: () => {
        const { input } = getRef();
        const testString = input.value;
        refreshList(testString);
      }
    })}
        >
            find
        </button>
    </div>`;
  };

  // src/js/component/common/debug/debug-overlay/debug-filter/head/definition.js
  var DebugFilterHead = modules_exports2.createComponent(
    /** @type {CreateComponentParams<any>} */
    {
      tag: "debug-filter-head",
      component: DebugFilterHeadFn
    }
  );

  // src/js/component/common/debug/debug-overlay/debug-filter/list/debug-filter-list.js
  var initScroller2 = async ({ getRef }) => {
    await modules_exports2.tick();
    const { screen, scroller, scrollbar } = getRef();
    const methods = verticalScroller({
      screen,
      scroller,
      scrollbar
    });
    const init8 = methods.init;
    const destroy3 = methods.destroy;
    const refresh = methods.refresh;
    const move3 = methods.move;
    const updateScroller2 = methods.updateScroller;
    init8();
    updateScroller2();
    move3(0);
    return {
      destroy: destroy3,
      move: move3,
      refresh,
      updateScroller: updateScroller2
    };
  };
  var getFakeReplacement = (index) => `~${index}`;
  var getDataFiltered = ({ testString }) => {
    const stringParsed = testString.replaceAll("~", "").split(" ").filter((block) => block !== "") ?? "";
    return (() => {
      const result = [];
      for (const item of modules_exports2.componentMap.values()) {
        const condition = stringParsed.every(
          (piece) => item.componentName.includes(piece)
        );
        if (condition) result.push(item);
      }
      return result;
    })().map(({ id, componentName, instanceName }) => ({
      id,
      active: false,
      tag: (() => {
        const stringParseWithPlaceholder = stringParsed.reduce(
          (previous, current, index) => {
            return previous.replaceAll(
              new RegExp(`(?<!~)${current.toLowerCase()}`, "g"),
              `${getFakeReplacement(index)}`
            );
          },
          componentName
        );
        return stringParsed.reduce((previous, current, index) => {
          return previous.replaceAll(
            `${getFakeReplacement(index)}`,
            `<span class="match-string">${current}</span>`
          );
        }, stringParseWithPlaceholder);
      })(),
      name: instanceName
    }));
  };
  var DebugFilterListFn = ({
    onMount,
    setRef,
    getRef,
    addMethod,
    repeat,
    staticProps: staticProps2,
    bindProps,
    bindEffect,
    getProxi,
    computed
  }) => {
    const proxi = getProxi();
    let destroy3 = () => {
    };
    let move3 = () => {
    };
    let refresh = () => {
    };
    let updateScroller2 = () => {
    };
    computed(
      () => proxi.noResult,
      () => {
        return proxi.data.length === 0 && !proxi.isLoading;
      }
    );
    addMethod("refreshList", async ({ testString }) => {
      proxi.isLoading = true;
      await modules_exports2.tick();
      modules_exports.useNextTick(async () => {
        proxi.data = getDataFiltered({ testString });
        await modules_exports2.tick();
        refresh?.();
        updateScroller2?.();
        proxi.isLoading = false;
      });
    });
    onMount(() => {
      const { scrollbar } = getRef();
      scrollbar.addEventListener("input", () => {
        move3(scrollbar.value);
      });
      (async () => {
        ({ destroy: destroy3, move: move3, refresh, updateScroller: updateScroller2 } = await initScroller2({
          getRef
        }));
      })();
      return () => {
        destroy3?.();
        destroy3 = () => {
        };
        refresh = () => {
        };
        updateScroller2 = () => {
        };
        move3 = () => {
        };
      };
    });
    return renderHtml`
        <div class="c-debug-filter-list">
            <div class="c-debug-filter-list__list" ${setRef("screen")}>
                <input
                    type="range"
                    id="test"
                    name="test"
                    min="0"
                    max="100"
                    value="0"
                    step=".5"
                    ${setRef("scrollbar")}
                    class="c-debug-filter-list__scrollbar"
                />
                <span
                    class="c-debug-filter-list__status"
                    ${bindEffect({
      toggleClass: { visible: () => proxi.isLoading }
    })}
                    >Generate list</span
                >
                <span
                    class="c-debug-filter-list__status"
                    ${bindEffect({
      toggleClass: { visible: () => proxi.noResult }
    })}
                    >no result</span
                >
                <div
                    class="c-debug-filter-list__scroller"
                    ${setRef("scroller")}
                >
                    ${repeat({
      observe: () => proxi.data,
      key: "id",
      useSync: true,
      render: ({ sync, current }) => {
        return renderHtml`
                                <debug-filter-list-item
                                    ${staticProps2(
          /** @type {DebugFilterListItem['state']} */
          {
            id: current.value.id,
            name: current.value.name
          }
        )}
                                    ${bindProps(
          /** @returns {ReturnBindProps<DebugFilterListItem>} */
          () => ({
            tag: current.value.tag
          })
        )}
                                    ${sync()}
                                ></debug-filter-list-item>
                            `;
      }
    })}
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/common/debug/debug-overlay/debug-filter/list/item/debug-filter-list-item.js
  var DebugFilterListItemFn = ({
    delegateEvents,
    bindText,
    bindEffect,
    getProxi,
    computed
  }) => {
    const proxi = getProxi();
    computed(
      () => proxi.active,
      () => proxi.id === proxi.currentId
    );
    return renderHtml`
        <div class="c-debug-filter-list-item">
            <span class="c-debug-filter-list-item__id">${proxi.id}</span> |
            <span class="c-debug-filter-list-item__tag"
                >${bindText`${"tag"}`}</span
            >
            |
            <span class="c-debug-filter-list-item__name">${proxi.name}</span>
            <button
                type="button"
                class="c-debug-filter-list-item__expand"
                ${delegateEvents({
      click: () => {
        const methods = modules_exports2.useMethodByName(debugComponentName);
        methods?.updateId(proxi.id);
      }
    })}
            >
                [ > ]
            </button>
            <span
                class="c-debug-tree-item__selected"
                ${bindEffect({
      toggleClass: { active: () => proxi.active }
    })}
            ></span>
        </div>
    `;
  };

  // src/js/component/common/debug/debug-overlay/debug-filter/list/item/definition.js
  var DebugFilterListItem = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DebugFilterListItem>} */
    {
      tag: "debug-filter-list-item",
      component: DebugFilterListItemFn,
      exportState: ["id", "tag", "name"],
      bindStore: debugActiveComponentStore,
      state: {
        id: () => ({
          value: "",
          type: String
        }),
        tag: () => ({
          value: "",
          type: String
        }),
        name: () => ({
          value: "",
          type: String
        }),
        active: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/common/debug/debug-overlay/debug-filter/list/definition.js
  var DebugFilterList = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DebugFilterList>} */
    {
      tag: "debug-filter-list",
      component: DebugFilterListFn,
      state: {
        data: () => ({
          value: [],
          type: Array
        }),
        isLoading: () => ({
          value: true,
          type: Boolean
        }),
        noResult: () => ({
          value: false,
          type: Boolean
        })
      },
      child: [DebugFilterListItem]
    }
  );

  // src/js/component/common/debug/debug-overlay/head/debug-head.js
  var DebugHeadFn = ({ invalidate, getProxi }) => {
    const proxi = getProxi();
    return renderHtml`<div class="c-debug-head">
        <div class="c-debug-head__general">
            ${invalidate({
      observe: () => proxi.active,
      render: () => {
        if (!proxi.active) return "";
        return renderHtml`
                        <div>
                            <strong> Debug activated: </strong>
                            ${modules_exports2.getDebugMode()}
                        </div>
                        <div class="c-debug-head__total">
                            <strong>Number of component</strong>:
                            ${modules_exports2.componentMap.size} ( excluded generated
                            debug )
                        </div>
                        <div class="c-debug-head__repeater">
                            <strong>Active repeater: </strong>:
                            ${modules_exports2.getNumberOfActiveRepeater()}
                        </div>
                        <div class="c-debug-head__invalidate">
                            <strong>Active invalidate: </strong>:
                            ${modules_exports2.getNumberOfActiveInvalidate()}
                        </div>
                        <div class="c-debug-head__invalidate">
                            <strong>Active bindText: </strong>:
                            ${getBindTextParentSize()}
                        </div>
                        <div class="c-debug-head__invalidate">
                            <strong>Active bindObject: </strong>:
                            ${getBindObjectParentSize()}
                        </div>
                    `;
      }
    })}
        </div>
        <div class="c-debug-head__search">
            <div>
                <debug-search></debug-search>
            </div>
        </div>
    </div>`;
  };

  // src/js/component/common/debug/debug-overlay/head/search/debug-search.js
  var updateId = (id = "") => {
    const methods = modules_exports2.useMethodByName(debugComponentName);
    methods?.updateId(id ?? "");
  };
  var DebugSearchFn = ({ setRef, getRef, delegateEvents }) => {
    return renderHtml`<div class="c-debug-search">
        <div>
            <span class="c-debug-search__label">
                <strong>Search by ID:</strong>
            </span>
            <input
                class="c-debug-search__input"
                type="text"
                ${setRef("id_input")}
                ${delegateEvents({
      keydown: (event) => {
        if (event.code.toLowerCase() === "enter") {
          event.preventDefault();
          const id = (
            /** @type {HTMLInputElement} */
            event.target.value
          );
          updateId(id);
        }
      }
    })}
            />
            <button
                class="c-debug-search__button"
                type="button"
                ${delegateEvents({
      click: () => {
        const { id_input } = getRef();
        const id = (
          /** @type {HTMLInputElement} */
          id_input.value
        );
        updateId(id);
      }
    })}
            >
                find
            </button>
        </div>
        <div>
            <span class="c-debug-search__label">
                <strong>Search by InstanceName:</strong>
            </span>
            <input
                class="c-debug-search__input"
                type="text"
                ${setRef("instance_input")}
                ${delegateEvents({
      keydown: (event) => {
        if (event.code.toLowerCase() === "enter") {
          event.preventDefault();
          const instanceName = (
            /** @type {HTMLInputElement} */
            event.target.value
          );
          const id = modules_exports2.getIdByInstanceName(instanceName);
          updateId(id);
        }
      }
    })}
            />
            <button
                class="c-debug-search__button"
                type="button"
                ${delegateEvents({
      click: () => {
        const { instance_input } = getRef();
        const instanceName = instance_input.value;
        const id = modules_exports2.getIdByInstanceName(instanceName);
        updateId(id);
      }
    })}
            >
                find
            </button>
            <div>
                <span class="c-debug-search__label">
                    <strong>Clear:</strong>
                </span>
                <button
                    class="c-debug-search__button"
                    type="button"
                    ${delegateEvents({
      click: () => {
        const { instance_input, id_input } = getRef();
        instance_input.value = "";
        id_input.value = "";
        updateId(RESET_FILTER_DEBUG);
      }
    })}
                >
                    clear
                </button>
            </div>
            <div>
                <span class="c-debug-search__label">
                    <strong>Refresh:</strong>
                </span>
                <button
                    class="c-debug-search__button"
                    type="button"
                    ${delegateEvents({
      click: () => {
        const methods = modules_exports2.useMethodByName(debugComponentName);
        methods?.refreshId();
      }
    })}
                >
                    refresh component
                </button>
            </div>
        </div>
    </div>`;
  };

  // src/js/component/common/debug/debug-overlay/head/search/definition.js
  var DebugSearch = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DebugSearch>} */
    {
      tag: "debug-search",
      component: DebugSearchFn
    }
  );

  // src/js/component/common/debug/debug-overlay/head/definition.js
  var DebugHead = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DebugHead>} */
    {
      tag: "debug-head",
      component: DebugHeadFn,
      exportState: ["active"],
      state: {
        active: () => ({
          value: false,
          type: Boolean
        }),
        shouldUpdate: () => ({
          value: true,
          type: Boolean,
          skipEqual: false
        })
      },
      child: [DebugSearch]
    }
  );

  // src/js/component/common/debug/console-log.js
  var consoleLogDebug = () => {
    modules_exports2.mainStore.debugStore();
    console.log("componentMap", modules_exports2.componentMap);
    console.log("Tree structure:", modules_exports2.getTree());
    console.log("bindEventMap", bindEventMap);
    console.log("currentListValueMap", currentRepeaterValueMap);
    console.log("activeRepeatMap", activeRepeatMap);
    console.log("onMountCallbackMap", onMountCallbackMap);
    console.log("staticPropsMap", staticPropsMap);
    console.log("dynamicPropsMap", bindPropsMap);
    console.log("eventDelegationMap", modules_exports2.eventDelegationMap);
    console.log("tempDelegateEventMap", modules_exports2.tempDelegateEventMap);
    console.log("invalidateIdPlaceHolderMap", invalidateIdPlaceHolderMap);
    console.log("invalidateIdHostMap", invalidateIdHostMap.size);
    console.log("invalidateFunctionMap", invalidateFunctionMap);
    console.log("repeatIdPlaceHolderMap", repeatIdPlaceHolderMap);
    console.log("repeatFunctionMap", repeatFunctionMap);
    console.log("userChildPlaceholderSize", getUserChildPlaceholderSize());
    console.log("slotPlaceholderSize", getSlotPlaceholderSize());
    console.log("bindTextMapSize", getBindTextParentSize());
    console.log("bindTextPlaceholderMapSize", getBindTextPlaceholderSize());
    console.log("instanceMap", instanceMap);
  };

  // src/js/component/common/debug/debug-overlay/debug-overlay.js
  var DebugOverlayFn = ({
    delegateEvents,
    addMethod,
    bindProps,
    invalidate,
    bindEffect,
    getProxi,
    onMount
  }) => {
    const proxi = getProxi();
    addMethod("toggle", () => {
      proxi.active = !proxi.active;
    });
    onMount(() => {
      const unsubScribeBeforeRouterChange = modules_exports2.beforeRouteChange(() => {
        proxi.active = false;
        proxi.listType = DEBUG_USE_TREE;
      });
      return () => {
        unsubScribeBeforeRouterChange();
      };
    });
    return renderHtml`<div
        class="c-debug-overlay"
        ${bindEffect({
      toggleClass: { active: () => proxi.active }
    })}
    >
        <button
            class="c-debug-overlay__background"
            type="button"
            ${delegateEvents({
      click: () => {
        proxi.active = false;
        proxi.listType = DEBUG_USE_TREE;
      }
    })}
        ></button>
        <button
            type="button"
            class="c-debug-overlay__close"
            ${delegateEvents({
      click: () => {
        proxi.active = false;
        proxi.listType = DEBUG_USE_TREE;
      }
    })}
        ></button>
        <div class="c-debug-overlay__grid">
            <button
                type="button"
                class="c-debug-overlay__log"
                ${delegateEvents({
      click: () => {
        consoleLogDebug();
      }
    })}
            >
                console log
            </button>

            <div class="c-debug-overlay__head">
                <debug-head
                    ${bindProps(
      /** @returns {ReturnBindProps<DebugHead>} */
      () => ({
        active: proxi.active
      })
    )}
                ></debug-head>
            </div>
            <div class="c-debug-overlay__list">
                <div class="c-debug-overlay__list__header">
                    <div>
                        ${invalidate({
      observe: [() => proxi.listType, () => proxi.active],
      render: () => {
        if (proxi.listType === DEBUG_USE_TREE && proxi.active)
          return renderHtml`<div
                                        class="c-debug-overlay__list__title"
                                    >
                                        Tree structure
                                    </div>`;
        if (proxi.listType === DEBUG_USE_FILTER_COMPONENT && proxi.active)
          return renderHtml`<debug-filter-head></debug-filter-head>`;
        return "";
      }
    })}
                    </div>

                    <div class="c-debug-overlay__list__ctas">
                        <button
                            type="button"
                            class="c-debug-overlay__list__toggle"
                            ${delegateEvents({
      click: () => {
        proxi.listType = DEBUG_USE_TREE;
      }
    })}
                            ${bindEffect({
      toggleClass: {
        active: () => proxi.listType === DEBUG_USE_TREE
      }
    })}
                        >
                            Tree
                        </button>
                        <button
                            type="button"
                            class="c-debug-overlay__list__toggle"
                            ${delegateEvents({
      click: () => {
        proxi.listType = DEBUG_USE_FILTER_COMPONENT;
      }
    })}
                            ${bindEffect({
      toggleClass: {
        active: () => proxi.listType === DEBUG_USE_FILTER_COMPONENT
      }
    })}
                        >
                            Filter
                        </button>
                    </div>
                </div>
                <div>
                    ${invalidate({
      observe: [() => proxi.listType, () => proxi.active],
      render: () => {
        if (proxi.listType === DEBUG_USE_TREE && proxi.active)
          return renderHtml`
                                    <debug-tree
                                        name="${debugTreeName}"
                                    ></debug-tree>
                                `;
        if (proxi.listType === DEBUG_USE_FILTER_COMPONENT && proxi.active)
          return renderHtml`
                                    <debug-filter-list
                                        name="${debugFilterListName}"
                                    ></debug-filter-list>
                                `;
        return "";
      }
    })}
                </div>
            </div>
            <div class="c-debug-overlay__component">
                <debug-component name="${debugComponentName}"></debug-component>
            </div>
        </div>
    </div>`;
  };

  // src/js/component/common/debug/debug-overlay/tree/recursive-tree.js
  var generateTreeComponents = ({ data, staticProps: staticProps2 }) => {
    return data.map(({ id, componentName, instanceName, children }) => {
      return renderHtml`<debug-tree-item
                ${staticProps2(
        /** @type {import('./item/type').DebugTreeItem['state']} */
        {
          id,
          componentName,
          instanceName,
          children
        }
      )}
            ></debug-tree-item>`;
    }).join("");
  };

  // src/js/component/common/debug/debug-overlay/tree/debug-tree.js
  var initScroller3 = async ({ getRef }) => {
    await modules_exports2.tick();
    const { screen, scroller, scrollbar } = getRef();
    const methods = verticalScroller({
      screen,
      scroller,
      scrollbar
    });
    const destroy3 = methods.destroy;
    const refresh = methods.refresh;
    const move3 = methods.move;
    const updateScroller2 = methods.updateScroller;
    methods.init();
    updateScroller2();
    move3(0);
    return {
      destroy: destroy3,
      refresh,
      move: move3,
      updateScroller: updateScroller2
    };
  };
  var DebugTreeFn = ({
    onMount,
    setState,
    invalidate,
    staticProps: staticProps2,
    setRef,
    getRef,
    addMethod,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    let destroy3 = () => {
    };
    let refresh = () => {
    };
    let updateScroller2 = () => {
    };
    let move3 = () => {
    };
    onMount(() => {
      const { scrollbar } = getRef();
      scrollbar.addEventListener("input", () => {
        move3(scrollbar.value);
      });
      addMethod("refresh", () => {
        refresh?.();
        updateScroller2?.();
      });
      (async () => {
        setState("isLoading", true);
        await modules_exports2.tick();
        destroy3?.();
        setState("data", modules_exports2.getTree());
        ({ destroy: destroy3, move: move3, refresh, updateScroller: updateScroller2 } = await initScroller3({
          getRef
        }));
        setState("isLoading", false);
      })();
      return () => {
        destroy3?.();
        destroy3 = () => {
        };
        refresh = () => {
        };
        updateScroller2 = () => {
        };
        move3 = () => {
        };
      };
    });
    return renderHtml`
        <div class="c-debug-tree">
            <div class="c-debug-tree__list" ${setRef("screen")}>
                <input
                    type="range"
                    id="test"
                    name="test"
                    min="0"
                    max="100"
                    value="0"
                    step=".5"
                    ${setRef("scrollbar")}
                    class="c-debug-tree__scrollbar"
                />
                <span
                    class="c-debug-tree__status"
                    ${bindEffect({
      toggleClass: { visible: () => proxi.isLoading }
    })}
                    >Generate tree</span
                >
                <div class="c-debug-tree__scroller" ${setRef("scroller")}>
                    ${invalidate({
      observe: () => proxi.data,
      render: () => {
        return generateTreeComponents({
          data: proxi.data,
          staticProps: staticProps2
        });
      }
    })}
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/common/debug/debug-overlay/tree/item/debug-tree-item.js
  var getCounter2 = (value) => {
    return value > 0 ? `( ${value} ) ` : "";
  };
  var activeItemChildren = ({ id, value }) => {
    const component = modules_exports2.componentMap.get(id);
    const children = component?.child;
    if (!children) return false;
    const flatChildren = Object.values(children).flat();
    const hasOccurrence = flatChildren.includes(value);
    if (hasOccurrence) return true;
    return flatChildren.some((id2) => activeItemChildren({ id: id2, value }));
  };
  var DebugTreeItemFn = ({
    onMount,
    staticProps: staticProps2,
    getRef,
    setRef,
    delegateEvents,
    watch,
    bindEffect,
    getProxi,
    computed
  }) => {
    const proxi = getProxi();
    const hasChildrenClass = proxi.children.length > 0 ? "has-children" : "";
    computed(
      () => proxi.isActive,
      () => proxi.id === proxi.currentId
    );
    computed(
      () => proxi.hasActiveChildren,
      () => activeItemChildren({
        id: proxi.id,
        value: proxi.currentId
      })
    );
    onMount(() => {
      const { content } = getRef();
      const unsubscribeSlide = MobSlide.subscribe(content);
      MobSlide.reset(content);
      watch(
        () => proxi.isOpen,
        async (isOpen) => {
          const action2 = isOpen ? "down" : "up";
          await MobSlide[action2](content);
          const methods = modules_exports2.useMethodByName(debugTreeName);
          methods?.refresh();
        }
      );
      return () => {
        unsubscribeSlide();
      };
    });
    return renderHtml`<div class="c-debug-tree-item">
        <div
            class="c-debug-tree-item__head ${hasChildrenClass}"
            ${delegateEvents({
      click: () => {
        proxi.isOpen = !proxi.isOpen;
      }
    })}
            ${bindEffect([
      {
        toggleClass: { open: () => proxi.isOpen }
      },
      {
        toggleClass: {
          "has-children-selected": () => proxi.hasActiveChildren
        }
      }
    ])}
        >
            <span class="c-debug-tree-item__id">${proxi.id}</span> |
            <span class="c-debug-tree-item__component"
                >${proxi.componentName}</span
            >
            |
            <span class="c-debug-tree-item__instance"
                >${proxi.instanceName}</span
            >
            <span>${getCounter2(proxi.children.length)}</span>
            <button
                type="button"
                class="c-debug-tree-item__expand"
                ${delegateEvents({
      click: () => {
        const methods = modules_exports2.useMethodByName(debugComponentName);
        methods?.updateId(proxi.id);
      }
    })}
            >
                [ > ]
            </button>
            <span
                class="c-debug-tree-item__selected"
                ${bindEffect({
      toggleClass: { active: () => proxi.isActive }
    })}
            ></span>
        </div>
        <div class="c-debug-tree-item__content" ${setRef("content")}>
            ${generateTreeComponents({ data: proxi.children, staticProps: staticProps2 })}
        </div>
    </div>`;
  };

  // src/js/component/common/debug/debug-overlay/tree/item/definition.js
  var DebugTreeItem = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DebugTreeItem>} */
    {
      tag: "debug-tree-item",
      component: DebugTreeItemFn,
      exportState: ["id", "componentName", "instanceName", "children"],
      bindStore: debugActiveComponentStore,
      state: {
        id: () => ({
          value: "",
          type: String
        }),
        componentName: () => ({
          value: "",
          type: String
        }),
        instanceName: () => ({
          value: "",
          type: String
        }),
        children: () => ({
          value: [],
          type: Array
        }),
        isOpen: () => ({
          value: false,
          type: Boolean
        }),
        isActive: () => ({
          value: false,
          type: Boolean
        }),
        hasActiveChildren: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/common/debug/debug-overlay/tree/definition.js
  var DebugTree = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DebugTree>} */
    {
      tag: "debug-tree",
      component: DebugTreeFn,
      state: {
        data: () => ({
          value: [],
          type: Array
        }),
        isLoading: () => ({
          value: false,
          type: Boolean
        })
      },
      child: [DebugTreeItem]
    }
  );

  // src/js/component/common/debug/debug-overlay/definition.js
  var DebugOverlay = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').DebugOverlay>} */
    {
      tag: "debug-overlay",
      component: DebugOverlayFn,
      state: {
        active: () => ({
          value: false,
          type: Boolean
        }),
        listType: () => ({
          value: DEBUG_USE_TREE,
          type: String
        })
      },
      child: [
        DebugTree,
        DebugComponent,
        DebugHead,
        DebugFilterHead,
        DebugFilterList
      ]
    }
  );

  // src/js/component/common/links-mob-js/links-mobjs.js
  var init7 = () => {
  };
  var destroy2 = () => {
  };
  var move2 = () => {
  };
  var updateScroller = () => {
  };
  var getItems = ({ staticProps: staticProps2, bindProps, proxi }) => {
    return proxi.data.map((item) => {
      const { label, url, isLabel } = item;
      return isLabel ? renderHtml`<p class="c-params-mobjs__label">${label}</p>` : renderHtml`<li>
                      <links-mobjs-button
                          ${staticProps2(
        /** @type {LinksMobJsButton['state']} */
        {
          label,
          url
        }
      )}
                          ${bindProps(() => ({
        active: proxi.activeSection === url
      }))}
                      ></links-mobjs-button>
                  </li>`;
    }).join("");
  };
  var LinksMobJsFn = ({
    staticProps: staticProps2,
    setRef,
    getRef,
    onMount,
    setState,
    bindProps,
    invalidate,
    bindEffect,
    getProxi
  }) => {
    const mainData = getCommonData();
    const proxi = getProxi();
    const templateData = {
      [PAGE_TEMPLATE_COMPONENT_MOBJS]: mainData.sideBarLinks.mobJsComponentParams
    };
    onMount(() => {
      const { screenEl, scrollerEl, scrollbar } = getRef();
      let isActive2 = false;
      scrollbar.addEventListener("input", () => {
        move2?.(scrollbar.value);
      });
      navigationStore.watch("navigationIsOpen", (value) => {
        const { templateName } = modules_exports2.getActiveRoute();
        if (!(templateName in templateData)) return;
        setState("shift", value);
      });
      const unsubscribeRoute = modules_exports2.afterRouteChange(
        async ({ currentTemplate, currentRoute }) => {
          const currentData = templateData?.[currentTemplate] ?? [];
          setState("data", currentData);
          await modules_exports2.tick();
          setState("activeSection", currentRoute);
          if (currentData.length > 0) {
            setState("hide", false);
            if (isActive2) {
              updateScroller();
              return;
            }
            ({ init: init7, destroy: destroy2, move: move2, updateScroller } = verticalScroller(
              {
                screen: screenEl,
                scroller: scrollerEl,
                scrollbar
              }
            ));
            isActive2 = true;
            init7();
            updateScroller();
            move2(0);
          }
          if (currentData.length === 0) {
            setState("hide", true);
            destroy2?.();
            isActive2 = false;
          }
        }
      );
      return () => {
        destroy2?.();
        unsubscribeRoute();
        init7 = () => {
        };
        destroy2 = () => {
        };
        move2 = () => {
        };
        updateScroller = () => {
        };
      };
    });
    return renderHtml`<div
        class="c-params-mobjs"
        ${setRef("screenEl")}
        ${bindEffect({
      toggleClass: {
        hide: () => proxi.hide,
        shift: () => proxi.shift
      }
    })}
    >
        <input
            type="range"
            id="test"
            name="test"
            min="0"
            max="100"
            value="0"
            step=".5"
            ${setRef("scrollbar")}
            class="c-params-mobjs__scrollbar"
        />
        <ul ${setRef("scrollerEl")}>
            ${invalidate({
      observe: () => proxi.data,
      render: () => {
        return getItems({
          staticProps: staticProps2,
          bindProps,
          proxi
        });
      }
    })}
        </ul>
    </div>`;
  };

  // src/js/component/common/links-mob-js/links-mobjs-button.js
  var LinksMobJsButtonFn = ({ getProxi, bindEffect }) => {
    const proxi = getProxi();
    return renderHtml` <a
        href="./#${proxi.url}"
        ${bindEffect({
      toggleClass: { current: () => proxi.active }
    })}
        ><span>${proxi.label}</span></a
    >`;
  };

  // src/js/component/common/links-mob-js/definition.js
  var LinksMobJsButton = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').LinksMobJsButton>} */
    {
      tag: "links-mobjs-button",
      component: LinksMobJsButtonFn,
      exportState: ["label", "url", "active"],
      state: {
        label: () => ({
          value: "",
          type: String
        }),
        url: () => ({
          value: "",
          type: String
        }),
        active: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );
  var LinksMobJs = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').LinksMobJs>} */
    {
      tag: "links-mobjs",
      component: LinksMobJsFn,
      child: [LinksMobJsButton],
      state: {
        data: () => ({
          value: [],
          type: Array
        }),
        activeSection: () => ({
          value: "",
          type: String
        }),
        hide: () => ({
          value: false,
          type: Boolean
        }),
        shift: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/svg/scroll_arrow.svg
  var scroll_arrow_default = '<?xml version="1.0" encoding="UTF-8"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n<svg width="50.51" height="51.18" version="1.1" viewBox="0 0 13.364 13.541" xmlns="http://www.w3.org/2000/svg">\n <g transform="translate(-6.0855 -4.2559)">\n  <path d="m7.5846 9.2554h10.366l-5.1892 7.0421z" color="#000000" stroke-linejoin="round" stroke-width="3" style="-inkscape-stroke:none"/>\n  <path d="m7.584 7.7559a1.5002 1.5002 0 0 0-1.207 2.3887l5.1758 7.041a1.5002 1.5002 0 0 0 2.416 2e-3l5.1895-7.043a1.5002 1.5002 0 0 0-1.207-2.3887zm2.9648 3h4.4316l-2.2188 3.0117z" color="#000000" style="-inkscape-stroke:none"/>\n  <path d="m10.712 5.7557h4.1113v4.4858h-4.1113z" color="#000000" stroke-linejoin="round" stroke-width="3" style="-inkscape-stroke:none"/>\n  <path d="m10.711 4.2559a1.5002 1.5002 0 0 0-1.5 1.5v4.4863a1.5002 1.5002 0 0 0 1.5 1.5h4.1113a1.5002 1.5002 0 0 0 1.5-1.5v-4.4863a1.5002 1.5002 0 0 0-1.5-1.5zm1.5 3h1.1113v1.4863h-1.1113z" color="#000000" style="-inkscape-stroke:none"/>\n </g>\n</svg>\n';

  // src/js/component/common/quick-nav/next-page.js
  var QuickNavFn = ({ getProxi, bindEffect }) => {
    const proxi = getProxi();
    modules_exports2.beforeRouteChange(() => {
      proxi.active = false;
      proxi.nextRoute = "";
      proxi.prevRoute = "";
      proxi.backRoute = "";
      proxi.color = "white";
    });
    return renderHtml`<div
        class="c-quick-nav-container"
        ${bindEffect([
      {
        toggleClass: { active: () => proxi.active }
      },
      {
        toggleClass: {
          "fill-white": () => proxi.color === "white",
          "fill-black": () => proxi.color === "black"
        }
      }
    ])}
    >
        <a
            class="c-quick-nav c-quick-nav--back"
            ${bindEffect({
      toggleClass: { "is-disable": () => !proxi.backRoute },
      toggleAttribute: {
        href: () => {
          const route = proxi.backRoute;
          return route.length > 0 ? route : null;
        }
      }
    })}
            >${scroll_arrow_default}</a
        >
        <a
            class="c-quick-nav c-quick-nav--prev"
            ${bindEffect({
      toggleClass: { "is-disable": () => !proxi.prevRoute },
      toggleAttribute: {
        href: () => {
          const route = proxi.prevRoute;
          return route.length > 0 ? route : null;
        }
      }
    })}
            >${scroll_arrow_default}</a
        >
        <a
            class="c-quick-nav c-quick-nav--next"
            ${bindEffect({
      toggleClass: { "is-disable": () => !proxi.nextRoute },
      toggleAttribute: {
        href: () => {
          const route = proxi.nextRoute;
          return route && route.length > 0 ? route : null;
        }
      }
    })}
            >${scroll_arrow_default}</a
        >
    </div>`;
  };

  // src/js/component/common/quick-nav/definition.js
  var QuickNav = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').QuickNav>} */
    {
      tag: "quick-nav",
      component: QuickNavFn,
      exportState: ["color", "active", "prevRoute", "nextRoute", "backRoute"],
      state: {
        color: () => ({
          value: "white",
          type: String,
          validate: (value) => {
            return ["white", "black"].includes(value);
          }
        }),
        active: () => ({
          value: false,
          type: Boolean
        }),
        backRoute: () => ({
          value: "",
          type: String
        }),
        prevRoute: () => ({
          value: "",
          type: String
        }),
        nextRoute: () => ({
          value: "",
          type: String
        })
      }
    }
  );

  // src/js/component/common/route-loader/route-loader.js
  var RouteLoaderFn = ({ onMount, getProxi, bindEffect }) => {
    const proxi = getProxi();
    onMount(({ element }) => {
      proxi.isDisable = true;
      let tweenOut = tween_exports.createTimeTween({
        data: { opacity: 1, scale: 1 },
        duration: 500
      });
      tweenOut.subscribe(({ opacity, scale }) => {
        element.style.opacity = opacity;
        element.style.transform = `scale(${scale})`;
      });
      const unsubscribeBeforeRouteChange = modules_exports2.beforeRouteChange(() => {
        tweenOut.goTo({ opacity: 1, scale: 1 });
        proxi.isDisable = false;
      });
      const unsubScribeAfterRouteChange = modules_exports2.afterRouteChange(async () => {
        await tweenOut.goTo({ opacity: 0, scale: 0.9 }).catch(() => {
        });
        proxi.isDisable = true;
      });
      return () => {
        tweenOut.destroy();
        tweenOut = null;
        unsubscribeBeforeRouteChange();
        unsubScribeAfterRouteChange();
      };
    });
    return renderHtml`
        <div
            class="c-loader center-viewport"
            ${bindEffect({
      toggleClass: { disable: () => proxi.isDisable }
    })}
        >
            <span class="c-loader__inner"></span>
        </div>
    `;
  };

  // src/js/component/common/route-loader/definition.js
  var RouteLoader = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').RouteLoader>} */
    {
      tag: "route-loader",
      component: RouteLoaderFn,
      state: {
        isLoading: () => ({
          value: false,
          type: Boolean
        }),
        isDisable: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/common/scroll-down-label/scroll-down-label.js
  var ScrollDownLabelFn = ({ getProxi, bindEffect }) => {
    const proxi = getProxi();
    return renderHtml`
        <div
            class="c-scroller-down-label"
            ${bindEffect({
      toggleClass: { active: () => proxi.active }
    })}
        >
            <h1>Scroll down</h1>
            ${scroll_arrow_default}
        </div>
    `;
  };

  // src/js/component/common/scroll-down-label/definition.js
  var ScrollDownLabel = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').ScrollDownLabel>} */
    {
      tag: "scroll-down-label",
      component: ScrollDownLabelFn,
      exportState: ["active"],
      state: {
        active: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/common/test-scss-grid/test-scss-grid.js
  var TestScssGridFn = () => {
    return renderHtml`
        <div class="test-grid">
            <div class="test-grid__grid">
                <span></span><span></span><span></span><span></span><span></span
                ><span></span><span></span><span></span><span></span
                ><span></span><span></span><span></span>
            </div>
            <div class="test-grid__cont"><span>test</span></div>
        </div>
    `;
  };

  // src/js/component/common/test-scss-grid/definition.js
  var TestScssGrid = modules_exports2.createComponent(
    /** @type {CreateComponentParams<any>} */
    {
      tag: "test-scss-grid",
      component: TestScssGridFn
    }
  );

  // src/js/component/layout/footer/footer.js
  var FooterFn = ({ delegateEvents }) => {
    return renderHtml`
        <footer class="l-footer">
            <div class="l-footer__container">
                <footer-nav></footer-nav>
                <div class="l-footer__debug">
                    <debug-button
                        class="c-button-debug"
                        ${delegateEvents({
      click: () => {
        const methods = modules_exports2.useMethodByName(debugOverlayName);
        methods?.toggle();
      }
    })}
                    >
                        Debug App</debug-button
                    >
                    <debug-button
                        class="c-button-console"
                        ${delegateEvents({
      click: () => {
        consoleLogDebug();
      }
    })}
                    >
                        Log
                    </debug-button>
                </div>
            </div>
        </footer>
    `;
  };

  // src/js/component/layout/footer/footer-nav/footer-button.js
  var FooterNavButtonFn = ({ getProxi, bindEffect, computed }) => {
    const proxi = getProxi();
    computed(
      () => proxi.active,
      () => {
        return proxi.section === proxi.activeNavigationSection;
      }
    );
    return renderHtml`
        <button
            type="button"
            class="footer-nav__button"
            ${bindEffect({
      toggleClass: { current: () => proxi.active }
    })}
        >
            ${proxi.label}
        </button>
    `;
  };

  // src/js/component/layout/footer/footer-nav/footer-nav.js
  var getItems2 = ({ delegateEvents, staticProps: staticProps2 }) => {
    const data = getCommonData();
    return data.footer.nav.map(({ label, url, section }) => {
      return renderHtml`<li class="footer-nav__item">
                <footer-nav-button
                    ${delegateEvents({
        click: () => {
          modules_exports2.loadUrl({ url });
          navigationStore.set("navigationIsOpen", false);
        }
      })}
                    ${staticProps2(
        /** @type {import('./type').FooterNavButton['state']} */
        {
          label,
          section
        }
      )}
                ></footer-nav-button>
            </li> `;
    }).join("");
  };
  var FooterNavFn = ({ delegateEvents, staticProps: staticProps2 }) => {
    return renderHtml`
        <ul class="footer-nav">
            ${getItems2({ delegateEvents, staticProps: staticProps2 })}
        </ul>
    `;
  };

  // src/js/component/layout/footer/footer-nav/definition.js
  var FooterNavButton = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').FooterNavButton>} */
    {
      tag: "footer-nav-button",
      component: FooterNavButtonFn,
      exportState: ["label", "section"],
      bindStore: navigationStore,
      state: {
        label: () => ({
          value: "",
          type: String
        }),
        section: () => ({
          value: "",
          type: String
        }),
        active: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );
  var FooterNav = modules_exports2.createComponent({
    tag: "footer-nav",
    component: FooterNavFn,
    child: [FooterNavButton]
  });

  // src/js/component/common/debug/debug-button.js
  var DebugButtonFn = () => {
    return renderHtml`
        <button type="button" class="c-btn-debug">
            <mobjs-slot></mobjs-slot>
        </button>
    `;
  };

  // src/js/component/common/debug/definition.js
  var DebugButton = modules_exports2.createComponent(
    /** @type {CreateComponentParams<any>} */
    {
      tag: "debug-button",
      component: DebugButtonFn
    }
  );

  // src/js/component/layout/footer/definition.js
  var Footer = modules_exports2.createComponent(
    /** @type {CreateComponentParams<any>} */
    {
      tag: "mob-footer",
      component: FooterFn,
      child: [FooterNav, DebugButton]
    }
  );

  // src/js/component/layout/header/header.js
  function titleHandler() {
    modules_exports2.loadUrl({ url: "#home" });
    navigationStore.set("navigationIsOpen", false);
    const mainNavigationMethods = modules_exports2.useMethodByName(mobNavigationName);
    mainNavigationMethods?.closeAllAccordion();
    const navContainerMethods = modules_exports2.useMethodByName(
      mobNavigationContainerName
    );
    navContainerMethods?.scrollTop();
  }
  var HeaderFn = ({
    delegateEvents,
    bindEffect,
    getProxi,
    onMount,
    addMethod
  }) => {
    const proxi = getProxi();
    onMount(({ element }) => {
      addMethod("getHeaderHeight", () => {
        return outerHeight(element);
      });
      setTimeout(() => {
        proxi.isMounted = true;
      }, 500);
    });
    return renderHtml`
        <header class="l-header">
            <div class="l-header__container">
                <div class="l-header__grid">
                    <div class="l-header__toggle">
                        <mob-header-toggle></mob-header-toggle>
                    </div>
                    <button
                        type="button"
                        class="l-header__title"
                        ${delegateEvents({
      click: () => {
        titleHandler();
      }
    })}
                    >
                        <div class="l-header__title-container">
                            <h3
                                ${bindEffect({
      toggleClass: {
        visible: () => proxi.isMounted
      }
    })}
                            >
                                <span>Mob</span>Project
                            </h3>
                            <h5
                                ${bindEffect({
      toggleClass: {
        visible: () => proxi.isMounted
      }
    })}
                            >
                                v 1.0
                            </h5>
                        </div>
                    </button>
                    <div class="l-header__utils">
                        <mob-header-nav></mob-header-nav>
                    </div>
                </div>
            </div>
        </header>
    `;
  };

  // src/svg/icon-github.svg
  var icon_github_default = '<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>\n\n';

  // src/js/component/layout/header/header-nav.js
  var icon = {
    github: icon_github_default
  };
  var onClick = ({ event }) => {
    const button = event.target;
    console.log(button);
    const { url } = (
      /** @type {HTMLButtonElement} */
      button?.dataset ?? ""
    );
    modules_exports2.loadUrl({ url });
    navigationStore.set("navigationIsOpen", false);
  };
  function additems({ delegateEvents }) {
    const header = getCommonData().header;
    const { links } = header;
    return links.map((link) => {
      const { svg, url, internal } = link;
      return renderHtml`<li class="l-header__sidenav__item">
                ${internal ? renderHtml`
                          <button
                              type="button"
                              data-url="${url}"
                              class="l-header__sidenav__link"
                              ${delegateEvents({
        click: (event) => {
          console.log("click");
          onClick({ event });
        }
      })}
                          >
                              ${icon[svg]}
                          </button>
                      ` : renderHtml`
                          <a
                              href="${url}"
                              target="_blank"
                              class="l-header__sidenav__link"
                          >
                              ${icon[svg]}
                          </a>
                      `}
            </li>`;
    }).join("");
  }
  var HeadernavFn = ({ delegateEvents }) => {
    return renderHtml`
        <ul class="l-header__sidenav">
            <li class="l-header__sidenav__item">
                <search-cta></search-cta>
            </li>
            ${additems({ delegateEvents })}
        </ul>
    `;
  };

  // src/js/component/layout/header/header-toggle.js
  var HeaderToggleFn = ({ delegateEvents, bindEffect, getProxi }) => {
    const proxi = getProxi();
    return renderHtml`
        <button
            class="hamburger hamburger--squeeze"
            type="button"
            ${delegateEvents({
      click: () => {
        navigationStore.update(
          "navigationIsOpen",
          (state) => !state
        );
        const isOpen = navigationStore.getProp("navigationIsOpen");
        if (!isOpen) {
          UnFreezeMobPageScroll();
          console.log("unfreeze");
        }
      }
    })}
            ${bindEffect({
      toggleClass: {
        "is-open": () => proxi.navigationIsOpen
      }
    })}
        >
            <div class="hamburger-box">
                <div class="hamburger-inner"></div>
            </div>
        </button>
    `;
  };

  // src/svg/search.svg
  var search_default = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   viewBox="0 0 60.020653 60.002285"\n   x="0px"\n   y="0px"\n   version="1.1"\n   width="60.020653"\n   height="60.002285"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <path d="m 25.488429,6.1344291e-5 a 25.5,25.5 0 1 0 15,46.129999655709 l 12.7,12.7 a 4.0022244,4.0022244 0 0 0 5.66,-5.66 l -12.7,-12.7 A 25.48,25.48 0 0 0 25.488429,6.1344291e-5 Z m 0,42.999999655709 a 17.5,17.5 0 1 1 17.5,-17.5 17.52,17.52 0 0 1 -17.5,17.5 z" />\n</svg>\n';

  // src/js/component/common/search/cta-search/search-cta.js
  var onClick2 = () => {
    const overlayMethods = useMethodByName(searchOverlay);
    overlayMethods?.toggle();
    const headerMethods = useMethodByName(searchOverlayHeader);
    headerMethods?.setInputFocus();
  };
  var SearchCtaFn = ({ delegateEvents }) => {
    return renderHtml`<button
        type="button"
        class="search-cta"
        ${delegateEvents({
      click: () => {
        onClick2();
      }
    })}
    >
        ${search_default}
    </button>`;
  };

  // src/js/component/common/search/cta-search/definition.js
  var Search = modules_exports2.createComponent({
    tag: "search-cta",
    component: SearchCtaFn,
    exportState: [],
    state: {}
  });

  // src/js/component/layout/header/definition.js
  var HeaderNav = modules_exports2.createComponent(
    /** @type {CreateComponentParams<any>} */
    {
      tag: "mob-header-nav",
      component: HeadernavFn,
      child: [Search]
    }
  );
  var HeaderToggle = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').HeaderToggle>} */
    {
      tag: "mob-header-toggle",
      component: HeaderToggleFn,
      bindStore: navigationStore
    }
  );
  var Header = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').Header>} */
    {
      tag: "mob-header",
      component: HeaderFn,
      state: {
        isMounted: () => ({
          value: false,
          type: Boolean
        })
      },
      child: [HeaderNav, HeaderToggle]
    }
  );

  // src/js/component/layout/navigation/animation/nav-scroller.js
  var currentPercent = 0;
  var initNavigationScoller = ({ root: root2 }) => {
    const screenEl = (
      /** @type {HTMLElement} */
      root2.querySelector(".l-navcontainer__wrap")
    );
    const scrollerEl = (
      /** @type {HTMLElement} */
      root2.querySelector(".l-navcontainer__scroll")
    );
    const percentEl = (
      /** @type {HTMLElement} */
      root2.querySelector(".l-navcontainer__percent")
    );
    const setDelay = 200;
    const navScroller = new MobSmoothScroller({
      screen: screenEl,
      scroller: scrollerEl,
      direction: "vertical",
      drag: true,
      scopedEvent: false,
      onUpdate: ({ percent }) => {
        const { navigationIsOpen } = navigationStore.get();
        if (!navigationIsOpen) return;
        currentPercent = Math.round(percent) / 100;
        percentEl.style.transform = `translateZ(0) scaleX(${currentPercent})`;
      }
    });
    navScroller.init();
    navigationStore.watch("activeNavigationSection", (section) => {
      const currentSection = (
        /** @type {HTMLElement} */
        document.querySelector(`[data-sectionname='${section}']`)
      );
      if (!currentSection) return;
      const header = (
        /** @type {HTMLElement} */
        document.querySelector(".l-header")
      );
      const footer = (
        /** @type {HTMLElement} */
        document.querySelector(".l-footer")
      );
      const navHeight = outerHeight(scrollerEl);
      const headerHeight = outerHeight(header);
      const footerHeight = outerHeight(footer);
      const percent = 100 * currentSection.offsetTop / (navHeight - window.innerHeight + headerHeight + footerHeight);
      const maxValue = percent;
      setTimeout(() => {
        const navIsOpen = navigationStore.getProp("navigationIsOpen");
        if (navIsOpen) return;
        navScroller.set(maxValue);
      }, 400);
    });
    navigationStore.watch("navigationIsOpen", (val2) => {
      if (val2) {
        percentEl.style.transform = `translateZ(0) scaleX(${currentPercent})`;
        return;
      }
      percentEl.style.transform = `translateZ(0) scaleX(0)`;
    });
    return {
      scrollNativationToTop: () => {
        setTimeout(() => {
          navScroller.move(0).catch(() => {
          });
          navigationStore.set("activeNavigationSection", "no-section");
          percentEl.style.transform = `translateZ(0) scaleX(0)`;
        }, setDelay);
      },
      refreshScroller: () => {
        navScroller.refresh();
      }
    };
  };

  // src/js/component/layout/navigation/nav-container.js
  function closeNavigation({ main, setState }) {
    setState("isOpen", false);
    modules_exports.useFrame(() => {
      document.body.style.overflow = "";
      main.classList.remove("shift");
    });
  }
  function openNavigation({ main, setState }) {
    const methods = modules_exports2.useMethodByName(mobNavigationContainerName);
    methods?.refresh();
    setState("isOpen", true);
    modules_exports.useFrame(() => {
      document.body.style.overflow = "hidden";
      main.classList.add("shift");
    });
  }
  function addMainHandler({ main }) {
    main.addEventListener("click", () => {
      navigationStore.set("navigationIsOpen", false);
      UnFreezeMobPageScroll();
    });
  }
  var toTopBtnHandler = () => {
    const navContainerMethods = modules_exports2.useMethodByName(
      mobNavigationContainerName
    );
    navContainerMethods?.scrollTop();
    const mainNavigationMethods = modules_exports2.useMethodByName(mobNavigationName);
    mainNavigationMethods?.closeAllAccordion();
    const { navigationIsOpen } = navigationStore.get();
    if (!navigationIsOpen) MobBodyScroll.to(0);
  };
  var NavigationContainerFn = ({
    onMount,
    addMethod,
    setState,
    delegateEvents,
    bindEffect,
    getProxi
  }) => {
    const proxi = getProxi();
    onMount(({ element }) => {
      const main = (
        /** @type {HTMLElement} */
        document.querySelector("main.main")
      );
      navigationStore.watch("navigationIsOpen", (val2) => {
        if (val2 && main) {
          openNavigation({ main, setState });
          return;
        }
        closeNavigation({ main, setState });
      });
      addMainHandler({ main });
      const { scrollNativationToTop, refreshScroller } = initNavigationScoller({
        root: element
      });
      addMethod("scrollTop", scrollNativationToTop);
      addMethod("refresh", refreshScroller);
      return () => {
      };
    });
    return renderHtml`
        <div
            class="l-navcontainer"
            ${bindEffect({
      toggleClass: { active: () => proxi.isOpen }
    })}
        >
            <div class="l-navcontainer__side">
                <div class="l-navcontainer__percent"></div>
                <button
                    class="l-navcontainer__totop"
                    ${delegateEvents({
      click: () => {
        toTopBtnHandler();
      }
    })}
                ></button>
            </div>
            <div class="l-navcontainer__wrap">
                <div class="l-navcontainer__scroll">
                    <mob-navigation
                        name="${mobNavigationName}"
                    ></mob-navigation>
                </div>
            </div>
        </div>
    `;
  };

  // src/js/component/layout/navigation/navigation.js
  function getItems3({ data, staticProps: staticProps2, bindProps, proxi }) {
    return data.map((item, index) => {
      const {
        label,
        url,
        activeId,
        children,
        section,
        sectioName,
        scrollToSection,
        forceChildren
      } = item;
      if (section) {
        return renderHtml`
                    <mob-navigation-label
                        ${staticProps2(
          /** @type {NavigationLabel['state']} */
          {
            label,
            sectioName
          }
        )}
                    ></mob-navigation-label>
                `;
      }
      return children ? renderHtml`
                      <mob-navigation-submenu
                          ${staticProps2(
        /** @type {NavigationSubmenu['state']} */
        {
          headerButton: {
            label,
            url
          },
          children,
          callback: () => proxi.currentAccordionId = index
        }
      )}
                          ${bindProps(
        /** @returns {ReturnBindProps<NavigationSubmenu>} */
        () => ({
          isOpen: proxi.currentAccordionId === index
        })
      )}
                      >
                      </mob-navigation-submenu>
                  ` : renderHtml`
                      <li class="l-navigation__item">
                          <mob-navigation-button
                              ${staticProps2(
        /** @type {NavigationButton['state']} */
        {
          label,
          url,
          scrollToSection: scrollToSection ?? "no-scroll",
          activeId: activeId ?? -1,
          forceChildren: forceChildren ?? []
        }
      )}
                          ></mob-navigation-button>
                      </li>
                  `;
    }).join("");
  }
  var NavigationFn = ({
    staticProps: staticProps2,
    setState,
    bindProps,
    addMethod,
    getProxi
  }) => {
    const proxi = getProxi();
    const { navigation: data } = getCommonData();
    addMethod("closeAllAccordion", ({ fireCallback = true } = {}) => {
      setState("currentAccordionId", -1, { emit: fireCallback });
    });
    return renderHtml`
        <nav class="l-navigation">
            <ul class="l-navigation__list">
                ${getItems3({
      data,
      staticProps: staticProps2,
      bindProps,
      proxi
    })}
            </ul>
        </nav>
    `;
  };

  // src/js/component/layout/navigation/navigation-button.js
  var NavigationButtonFn = ({
    setState,
    getState,
    delegateEvents,
    getProxi,
    bindEffect
  }) => {
    const proxi = getProxi();
    const {
      label,
      url,
      arrowClass,
      subMenuClass,
      fireRoute,
      callback: callback2,
      scrollToSection,
      activeId,
      forceChildren
    } = getState();
    modules_exports2.afterRouteChange(({ currentRoute }) => {
      modules_exports.useFrame(() => {
        const urlParsed = url.split("?");
        const hash = urlParsed?.[0] ?? "";
        const activeParams = modules_exports2.getActiveParams();
        const paramsMatch = activeId === -1 || activeParams?.["activeId"] === `${activeId}`;
        const isActiveRoute = currentRoute === hash && paramsMatch;
        const forceChildrenMatch = forceChildren.includes(currentRoute);
        setState("isCurrent", isActiveRoute || forceChildrenMatch);
        if (isActiveRoute && fireRoute) {
          callback2();
          navigationStore.set("activeNavigationSection", scrollToSection);
        }
      });
    });
    return renderHtml`
        <button
            type="button"
            class="l-navigation__link  ${arrowClass} ${subMenuClass}"
            ${delegateEvents({
      click: () => {
        callback2();
        if (!fireRoute) return;
        modules_exports2.loadUrl({ url });
        navigationStore.set("navigationIsOpen", false);
      }
    })}
            ${bindEffect({
      toggleClass: {
        active: () => proxi.isOpen,
        current: () => proxi.isCurrent
      }
    })}
        >
            ${label}
        </button>
    `;
  };

  // src/js/component/layout/navigation/navigation-label.js
  var NavigationLabelFn = ({ bindEffect, getProxi }) => {
    const proxi = getProxi();
    return renderHtml`
        <div
            class="l-navigation__label"
            data-sectionname="${proxi.sectioName}"
            ${bindEffect({
      toggleClass: {
        active: () => proxi.sectioName === proxi.activeNavigationSection
      }
    })}
        >
            ${proxi.label}
        </div>
    `;
  };

  // src/js/component/layout/navigation/navigation-submenu.js
  function getSubmenu({ proxi, staticProps: staticProps2 }) {
    return proxi.children.map((child) => {
      const { label, url, scrollToSection, activeId } = child;
      return renderHtml`
                <li class="l-navigation__submenu__item">
                    <mob-navigation-button
                        ${staticProps2(
        /** @type {NavigationButton['state']} */
        {
          callback: proxi.callback,
          label,
          url,
          subMenuClass: "l-navigation__link--submenu",
          scrollToSection,
          activeId: activeId ?? -1
        }
      )}
                    ></mob-navigation-button>
                </li>
            `;
    }).join("");
  }
  var NavigationSubmenuFn = ({
    onMount,
    staticProps: staticProps2,
    bindProps,
    watch,
    setRef,
    getRef,
    getProxi
  }) => {
    const proxi = getProxi();
    const { label, url, activeId } = proxi.headerButton;
    onMount(() => {
      const { content } = getRef();
      MobSlide.subscribe(content);
      MobSlide.reset(content);
      watch(
        () => proxi.isOpen,
        async (isOpen) => {
          const action2 = isOpen ? "down" : "up";
          await MobSlide[action2](content);
          const navContainerMethods = modules_exports2.useMethodByName(
            mobNavigationContainerName
          );
          navContainerMethods?.refresh();
          if (isOpen) return;
          const mainNavigationMethods = modules_exports2.useMethodByName(mobNavigationName);
          mainNavigationMethods?.closeAllAccordion({
            fireCallback: false
          });
        },
        { immediate: true }
      );
      return () => {
      };
    });
    return renderHtml`
        <li class="l-navigation__item has-child">
            <mob-navigation-button
                ${staticProps2(
      /** @type {NavigationButton['state']} */
      {
        label,
        url,
        arrowClass: "l-navigation__link--arrow",
        fireRoute: false,
        activeId: activeId ?? -1,
        callback: () => {
          proxi.isOpen = !proxi.isOpen;
          if (proxi.isOpen) proxi.callback();
        }
      }
    )}
                ${bindProps(
      /** @returns {ReturnBindProps<NavigationButton>} */
      () => ({
        isOpen: proxi.isOpen
      })
    )}
            ></mob-navigation-button>
            <ul class="l-navigation__submenu" ${setRef("content")}>
                ${getSubmenu({ proxi, staticProps: staticProps2 })}
            </ul>
        </li>
    `;
  };

  // src/js/component/layout/navigation/definition.js
  var NavigationButton = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').NavigationButton>} */
    {
      tag: "mob-navigation-button",
      component: NavigationButtonFn,
      exportState: [
        "label",
        "url",
        "arrowClass",
        "subMenuClass",
        "fireRoute",
        "callback",
        "isOpen",
        "scrollToSection",
        "activeId",
        "forceChildren"
      ],
      state: {
        label: () => ({
          value: "",
          type: String
        }),
        url: () => ({
          value: "",
          type: String
        }),
        activeId: () => ({
          value: -1,
          type: Number
        }),
        scrollToSection: () => ({
          value: "",
          type: String
        }),
        arrowClass: () => ({
          value: "",
          type: String
        }),
        subMenuClass: () => ({
          value: "",
          type: String
        }),
        fireRoute: () => ({
          value: true,
          type: Boolean
        }),
        callback: () => ({
          value: () => {
          },
          type: Function
        }),
        isOpen: () => ({
          value: false,
          type: Boolean
        }),
        isCurrent: () => ({
          value: false,
          type: Boolean
        }),
        forceChildren: () => ({
          value: [],
          type: Array
        })
      }
    }
  );
  var NavigationLabel = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').NavigationLabel>} */
    {
      tag: "mob-navigation-label",
      component: NavigationLabelFn,
      exportState: ["label", "sectioName"],
      bindStore: navigationStore,
      state: {
        label: () => ({
          value: "",
          type: String
        }),
        sectioName: () => ({
          value: "",
          type: String
        })
      }
    }
  );
  var NavigationSubmenu = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').NavigationSubmenu>} */
    {
      tag: "mob-navigation-submenu",
      component: NavigationSubmenuFn,
      exportState: ["children", "headerButton", "isOpen", "callback"],
      state: {
        callback: () => ({
          value: () => {
          },
          type: Function
        }),
        headerButton: () => ({
          value: {},
          type: "Any"
        }),
        children: () => ({
          value: [],
          type: Array
        }),
        isOpen: () => ({
          value: false,
          type: Boolean
        })
      },
      child: [NavigationButton]
    }
  );
  var Navigation = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').Navigation>} */
    {
      tag: "mob-navigation",
      component: NavigationFn,
      exportState: ["currentAccordionId"],
      state: {
        currentAccordionId: () => ({
          value: -1,
          type: Number,
          skipEqual: false
        })
      },
      child: [NavigationLabel, NavigationSubmenu, NavigationButton]
    }
  );
  var NavigationContainer = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').NavigationContainer>} */
    {
      tag: "mob-navigation-container",
      component: NavigationContainerFn,
      child: [Navigation],
      state: {
        isOpen: () => ({
          value: false,
          type: Boolean
        })
      }
    }
  );

  // src/js/component/common/search/search-overlay/search-overlay.js
  var closeOverlay = ({ proxi }) => {
    proxi.active = false;
    const headerMethods = useMethodByName(searchOverlayHeader);
    headerMethods?.closeSuggestion();
  };
  var shouldCloseSuggestion = ({ currentTarget }) => {
    if (!currentTarget) return;
    const headerMethods = useMethodByName(searchOverlayHeader);
    headerMethods?.shouldCloseSuggestion(currentTarget);
  };
  var SearchOverlayFn = ({
    getProxi,
    delegateEvents,
    bindEffect,
    addMethod,
    bindObject,
    staticProps: staticProps2
  }) => {
    const proxi = getProxi();
    addMethod("toggle", () => {
      proxi.active = !proxi.active;
    });
    return renderHtml`<div
        class="search-overlay"
        ${bindEffect({
      toggleClass: {
        active: () => proxi.active
      }
    })}
    >
        <button
            class="search-overlay__background"
            type="button"
            ${delegateEvents({
      click: () => {
        closeOverlay({ proxi });
      }
    })}
        ></button>
        <button
            type="button"
            class="search-overlay__close"
            ${delegateEvents({
      click: () => {
        closeOverlay({ proxi });
      }
    })}
        ></button>

        <!-- Main content -->
        <div
            class="search-overlay__grid"
            ${delegateEvents({
      click: (event) => {
        shouldCloseSuggestion({
          currentTarget: (
            /** @type {HTMLElement} */
            event.currentTarget
          )
        });
      }
    })}
        >
            <!-- Title -->
            <h2 class="search-overlay__title">Search</h2>

            <!-- Header -->
            <div class="search-overlay__header">
                <search-overlay-header
                    name="${searchOverlayHeader}"
                ></search-overlay-header>
            </div>
            <div class="search-overlay__current-search">
                <p>
                    ${bindObject`search for: <strong>${() => proxi.currentSearch}</strong>`}
                </p>
            </div>

            <!-- List -->
            <div class="search-overlay__list">
                <search-overlay-list
                    ${staticProps2(
      /** @type {import('./list/type').SearchOverlayList['state']} */
      {
        updatePrentSearchKey: (value) => {
          proxi.currentSearch = value;
        }
      }
    )}
                    name="${searchOverlayList}"
                ></search-overlay-list>
            </div>
        </div>
    </div>`;
  };

  // src/js/component/common/search/search-overlay/header/header.js
  var sendSearch = async ({ currentSearch }) => {
    const listMethods = useMethodByName(searchOverlayList);
    listMethods?.update(currentSearch);
  };
  var sendToList = ({ getRef }) => {
    const { search_input } = getRef();
    const currentSearch = (
      /** @type {HTMLInputElement} */
      search_input.value
    );
    sendSearch({ currentSearch });
  };
  var sendReset = ({ getRef, proxi }) => {
    const listMethods = useMethodByName(searchOverlayList);
    listMethods?.reset();
    const { search_input } = getRef();
    search_input.value = "";
    proxi.suggestionListData = [];
  };
  var getFakeReplacement2 = (index) => `~${index}`;
  var filterSuggestion = ({ currentSearch, proxi }) => {
    const mainData = getCommonData();
    const searchSuggestionKey = mainData.suggestion;
    if (currentSearch.length === 0) proxi.suggestionListData = [];
    const inputSearchLastWord = currentSearch.split(" ").slice(-1).join("");
    const stringParsed = inputSearchLastWord.replaceAll("~", "").split(" ").filter((block) => block !== "") ?? "";
    proxi.suggestionListData = (searchSuggestionKey.filter(({ word }) => {
      return stringParsed.some(
        (piece) => word.toLowerCase().includes(piece.toLowerCase())
      );
    }) ?? []).map(({ word }) => {
      return {
        word,
        wordHiglight: (() => {
          const stringParseWithPlaceholder = stringParsed.reduce(
            (previous, current, index) => {
              return previous.toLowerCase().replaceAll(
                new RegExp(
                  `(?<!~)${current.toLowerCase()}`,
                  "g"
                ),
                `${getFakeReplacement2(index)}`
              );
            },
            word
          );
          return stringParsed.reduce((previous, current, index) => {
            return previous.replaceAll(
              `${getFakeReplacement2(index)}`,
              `<span class="match-string">${current}</span>`
            );
          }, stringParseWithPlaceholder);
        })()
      };
    });
  };
  var SearchOverlayHeaderFn = ({
    delegateEvents,
    getRef,
    setRef,
    getProxi,
    bindProps,
    addMethod,
    onMount,
    computed,
    bindEffect
  }) => {
    const proxi = getProxi();
    computed(
      () => proxi.suggestionListActive,
      () => proxi.suggestionListData.length > 0
    );
    onMount(() => {
      const { search_input, suggestionElement } = getRef();
      addMethod("updateCurrentSearchFromSuggestion", (value) => {
        const currentValue = search_input.value;
        const currentValueSplitted = currentValue.split(" ");
        const newSearchValue = currentValueSplitted.length === 0 ? value : (() => {
          const currentValueLessLast = currentValueSplitted.slice(0, -1).join(" ");
          return `${currentValueLessLast} ${value}`;
        })();
        search_input.value = newSearchValue.trimStart();
        proxi.suggestionListData = [];
        search_input.focus();
      });
      addMethod("shouldCloseSuggestion", (element) => {
        if (suggestionElement !== element && !suggestionElement.contains(element))
          proxi.suggestionListData = [];
      });
      addMethod("closeSuggestion", () => {
        proxi.suggestionListData = [];
      });
      addMethod("setInputFocus", async () => {
        setTimeout(() => {
          search_input.focus();
        }, 300);
      });
    });
    return renderHtml`<div class="search-overlay-header">
        <div class="search-overlay-header__input-container">
            <input
                type="text"
                class="search-overlay-header__input"
                ${setRef("search_input")}
                ${delegateEvents({
      keyup: modules_exports.useDebounce(
        (event) => {
          if (event.code.toLowerCase() === "enter") {
            event.preventDefault();
            sendToList({ getRef, proxi });
            proxi.suggestionListData = [];
            return;
          }
          if (event.code.toLowerCase() === "escape") {
            event.preventDefault();
            proxi.suggestionListData = [];
            return;
          }
          const currentSearch = (
            /** @type {HTMLInputElement} */
            event.target.value
          );
          filterSuggestion({ currentSearch, proxi });
        },
        60
      )
    })}
            />
            <div
                class="search-overlay-header__suggestion-container"
                ${setRef("suggestionElement")}
                ${bindEffect({
      toggleClass: {
        active: () => proxi.suggestionListActive
      }
    })}
            >
                <search-overlay-suggestion
                    ${bindProps(
      /** @returns {ReturnBindProps<import('./suggestion/type').SearchOverlaySuggestion>} */
      () => ({
        list: proxi.suggestionListData
      })
    )}
                ></search-overlay-suggestion>
            </div>
        </div>

        <!-- Submit -->
        <button
            type="button"
            class="search-overlay-header__button"
            ${delegateEvents({
      click: () => {
        sendToList({ getRef, proxi });
      },
      keydown: (event) => {
        if (event.code.toLowerCase() === "enter") {
          sendToList({ getRef, proxi });
        }
      }
    })}
        >
            submit
        </button>

        <!-- Reset -->
        <button
            type="button"
            class="search-overlay-header__button"
            ${delegateEvents({
      click: () => {
        sendReset({ getRef, proxi });
      },
      keydown: (event) => {
        if (event.code.toLowerCase() === "enter") {
          sendReset({ getRef, proxi });
        }
      }
    })}
        >
            reset
        </button>
    </div>`;
  };

  // src/js/component/common/search/search-overlay/header/suggestion/suggestion.js
  var sendWord = (word) => {
    const headerMethods = useMethodByName(searchOverlayHeader);
    headerMethods?.updateCurrentSearchFromSuggestion(word);
  };
  var onEsc = () => {
    const headerMethods = useMethodByName(searchOverlayHeader);
    headerMethods?.closeSuggestion();
  };
  var onKeyDown = ({ code, word }) => {
    if (code.toLowerCase() === "enter") {
      sendWord(word);
      return;
    }
    if (code.toLowerCase() === "escape") {
      onEsc();
      return;
    }
  };
  var SearchOverlaySuggestionFn = ({
    getProxi,
    repeat,
    bindObject,
    delegateEvents
  }) => {
    const proxi = getProxi();
    return renderHtml`<div>
        <div class="search-overlay-suggestion">
            <ul class="search-overlay-suggestion__list">
                ${repeat({
      observe: () => proxi.list,
      key: "word",
      render: ({ current }) => {
        return renderHtml`
                            <li class="search-overlay-suggestion__item">
                                <button
                                    type="button"
                                    class="search-overlay-suggestion__button"
                                    ${delegateEvents({
          click: () => {
            sendWord(current.value.word);
          },
          keydown: (event) => {
            event.preventDefault();
            onKeyDown({
              code: event.code,
              word: current.value.word
            });
          }
        })}
                                >
                                    ${bindObject`${() => current.value.wordHiglight}`}
                                </button>
                            </li>
                        `;
      }
    })}
            </ul>
        </div>
    </div>`;
  };

  // src/js/component/common/search/search-overlay/header/suggestion/definition.js
  var SearchOverlaySuggestion = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').SearchOverlaySuggestion>} */
    {
      tag: "search-overlay-suggestion",
      component: SearchOverlaySuggestionFn,
      exportState: ["list"],
      state: {
        list: () => ({
          value: [],
          type: Array
        })
      }
    }
  );

  // src/js/component/common/search/search-overlay/header/definition.js
  var SearchOverlayHeader = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').SearchOverlayHeader>} */
    {
      tag: "search-overlay-header",
      component: SearchOverlayHeaderFn,
      exportState: [],
      state: {
        suggestionListActive: () => ({
          value: false,
          type: Boolean
        }),
        suggestionListData: () => ({
          value: [],
          type: Array
        })
      },
      child: [SearchOverlaySuggestion]
    }
  );

  // src/js/component/common/search/search-overlay/list/fetch-data.js
  var executeFetch = async ({
    source,
    uri,
    title,
    section,
    breadCrumbs
  }) => {
    const response = await fetch(source);
    if (!response.ok) {
      console.warn(`${source} not found`);
      return {
        success: false,
        data: [{ component: "", props: {} }],
        uri,
        title,
        section,
        breadCrumbs: []
      };
    }
    const data = await response.json();
    return {
      success: true,
      data: data.data,
      uri,
      title,
      section,
      breadCrumbs
    };
  };
  var validComponent = /* @__PURE__ */ new Set(["mob-title", "mob-paragraph", "mob-list"]);
  var componentWithContent = /* @__PURE__ */ new Set(["mob-title", "mob-paragraph"]);
  var listComponent = /* @__PURE__ */ new Set(["mob-list"]);
  var fetchSearchResult = async ({ currentSearch = "" }) => {
    const pageList = routes.filter(({ props }) => {
      return props?.source && props?.title;
    }).map(({ name, props }) => {
      return {
        fn: executeFetch({
          source: props.source ?? "",
          uri: name ?? "uri not forud",
          title: props.title ?? "title not found",
          section: props.section ?? "title not found",
          breadCrumbs: props.breadCrumbs ?? []
        })
      };
    });
    const result = await Promise.all(pageList.map(({ fn }) => fn));
    const initialState = [];
    const resultParsed = result.filter(({ success }) => success).map(({ data, uri, title, section, breadCrumbs }) => {
      const dataParsed = data.reduce((previous, current) => {
        if (!current) return previous;
        const { component } = current;
        if (!component) return previous;
        const isHTMLContent = current.component === "html-content";
        if (!isHTMLContent) {
          return [...previous, current];
        }
        if (!current?.props?.data) return previous;
        return [...previous, current.props.data];
      }, initialState);
      const filterDataByComponent = dataParsed.flat().filter(({ component }) => {
        return validComponent.has(component);
      });
      const filterDataByContent = filterDataByComponent.flatMap(
        (item) => {
          if (componentWithContent.has(item?.component)) {
            return item.content;
          }
          if (listComponent.has(item?.component)) {
            if (item?.props?.links) {
              return item.props.items.map(({ label }) => label);
            }
            return item.props.items;
          }
          return item;
        }
      );
      return {
        uri,
        title,
        section,
        breadCrumbs,
        data: filterDataByContent
      };
    });
    const currentSearchSplitted = currentSearch.split(" ");
    const searchResult = resultParsed.filter((item) => {
      const dataJoined = item.data.join(" ");
      return currentSearchSplitted.every((word) => {
        return dataJoined.toLowerCase().includes(word.toLowerCase());
      });
    }).toSorted((first) => {
      if (first.title.toLowerCase().includes(currentSearch.toLowerCase()))
        return -1;
      return 1;
    }).map(({ title, uri, section, breadCrumbs, data }) => {
      const count = data.join("").toLowerCase().split(currentSearch.toLowerCase());
      const breadCrumbsParsed = breadCrumbs.length > 0 ? breadCrumbs.reduce((previous, current, index) => {
        const slash = index > 0 ? "/" : "";
        return `${previous}${slash}${current.title}`;
      }, "") : title;
      return {
        title,
        uri,
        section,
        breadCrumbs: breadCrumbsParsed,
        count: count?.length ?? 0
      };
    });
    return searchResult;
  };

  // src/js/component/common/search/search-overlay/list/list.js
  var loadPage = ({ uri }) => {
    modules_exports2.loadUrl({ url: uri });
    const searchMethods = useMethodByName(searchOverlay);
    searchMethods?.toggle();
  };
  var initScroller4 = ({ getRef }) => {
    const { screen, scroller, scrollbar } = getRef();
    scrollbar.addEventListener("input", () => {
      move3(scrollbar.value);
    });
    const methods = verticalScroller({
      screen,
      scroller,
      scrollbar
    });
    const init8 = methods.init;
    const destroy3 = methods.destroy;
    const refresh = methods.refresh;
    const move3 = methods.move;
    const updateScroller2 = methods.updateScroller;
    init8();
    updateScroller2();
    move3(0);
    return {
      destroy: destroy3,
      move: move3,
      refresh,
      updateScroller: updateScroller2
    };
  };
  var SearchOverlayListFn = ({
    getProxi,
    repeat,
    bindObject,
    setRef,
    getRef,
    onMount,
    watch,
    addMethod,
    delegateEvents,
    bindEffect,
    invalidate
  }) => {
    const proxi = getProxi();
    addMethod("update", async (currentSearch) => {
      if (proxi.loading) return;
      proxi.loading = true;
      proxi.noResult = false;
      proxi.list = await fetchSearchResult({ currentSearch });
      proxi.loading = false;
      proxi.noResult = proxi.list.length === 0;
      proxi.updatePrentSearchKey(currentSearch);
    });
    addMethod("reset", () => {
      proxi.updatePrentSearchKey("");
      proxi.list = [];
    });
    let move3;
    onMount(() => {
      const {
        destroy: destroy3,
        updateScroller: updateScroller2,
        move: moveUpdated,
        refresh
      } = initScroller4({
        getRef
      });
      move3 = moveUpdated;
      watch(
        () => proxi.list,
        async () => {
          await modules_exports2.tick();
          refresh();
          updateScroller2();
          move3(0);
        }
      );
      return () => {
        destroy3?.();
      };
    });
    return renderHtml`<div class="search-overlay-list" ${setRef("screen")}>
        <span
            class="search-overlay-list__loading"
            ${bindEffect({
      toggleClass: {
        active: () => proxi.loading
      }
    })}
            >fetch data</span
        >
        <input
            type="range"
            id="test"
            name="test"
            min="0"
            max="100"
            value="0"
            step=".5"
            ${setRef("scrollbar")}
            class="search-overlay-list__scrollbar"
        />

        <!-- no result -->
        <div>
            ${invalidate({
      observe: () => proxi.noResult,
      render: () => {
        return proxi.noResult ? renderHtml`
                              <ul class="search-overlay-list__ul">
                                  <li class="search-overlay-list__item">
                                      <div class="search-overlay-list__section">
                                          <p><strong>no result</strong></p>
                                      </div>
                                  </li>
                              </ul>
                          ` : "";
      }
    })}
        </div>

        <!-- result list -->
        <ul class="search-overlay-list__ul" ${setRef("scroller")}>
            ${repeat({
      observe: () => proxi.list,
      render: ({ current }) => {
        return renderHtml`
                        <li
                            class="search-overlay-list__item"
                            ${bindEffect({
          toggleClass: {
            current: () => proxi.activeRoute.route === current.value.uri
          }
        })}
                        >
                            <button
                                type="button"
                                class="search-overlay-list__button"
                                ${delegateEvents({
          click: () => {
            loadPage({ uri: current.value.uri });
          }
        })}
                            >
                                <div class="search-overlay-list__section">
                                    <p>
                                        ${bindObject`<strong>${() => current.value.breadCrumbs}</strong> (${() => current.value.count})`}
                                    </p>
                                </div>
                                <div class="search-overlay-list__title">
                                    <h6>
                                        ${bindObject`${() => current.value.title}`}
                                    </h6>
                                </div>
                            </button>
                        </li>
                    `;
      }
    })}
        </ul>
    </div>`;
  };

  // src/js/component/common/search/search-overlay/list/definition.js
  var SearchOverlayList = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').SearchOverlayList>} */
    {
      tag: "search-overlay-list",
      component: SearchOverlayListFn,
      exportState: ["updatePrentSearchKey"],
      bindStore: modules_exports2.mainStore,
      state: {
        list: () => ({
          value: [],
          type: Array
        }),
        loading: () => ({
          value: false,
          type: Boolean
        }),
        noResult: () => ({
          value: false,
          type: Boolean
        }),
        updatePrentSearchKey: () => ({
          value: () => {
          },
          type: Function
        })
      }
    }
  );

  // src/js/component/common/search/search-overlay/definition.js
  var SearchOverlay = modules_exports2.createComponent(
    /** @type {CreateComponentParams<import('./type').SearchOverlay>} */
    {
      tag: "search-overlay",
      component: SearchOverlayFn,
      exportState: [],
      state: {
        active: () => ({
          value: false,
          type: Boolean
        }),
        currentSearch: () => ({
          value: "",
          type: String
        })
      },
      child: [SearchOverlayHeader, SearchOverlayList]
    }
  );

  // src/js/wrapper/index.js
  modules_exports2.useComponent([
    Header,
    NavigationContainer,
    Footer,
    QuickNav,
    RouteLoader,
    ScrollDownLabel,
    LinksMobJs,
    DebugOverlay,
    TestScssGrid,
    SearchOverlay
  ]);
  var wrapper = async () => {
    const useScssTestGrid = false;
    return renderHtml`
        ${useScssTestGrid ? "<test-scss-grid></test-scss-grid>" : ""}
        <debug-overlay name="${debugOverlayName}"></debug-overlay>
        <mob-header name="${headerName}"></mob-header>
        <mob-navigation-container
            name="${mobNavigationContainerName}"
        ></mob-navigation-container>
        <main class="main">
            <div class="container">
                <div class="inner-wrap">
                    <div id="content"></div>
                </div>
            </div>
        </main>
        <mob-footer> </mob-footer>
        <quick-nav name="${quickNavName}"></quick-nav>
        <route-loader></route-loader>
        <scroll-down-label name="${scrollDownLabelName}"></scroll-down-label>
        <links-mobjs></links-mobjs>
        <search-overlay name="${searchOverlay}"></search-overlay>
    `;
  };

  // src/js/main.js
  var shouldRedirect = () => {
    return (
      /** @type {boolean} */
      core_exports.mq("max", "desktop")
    );
  };
  var redirectOnResize = () => {
    modules_exports.useResize(() => {
      if (!shouldRedirect()) return;
      modules_exports2.loadUrl({ url: "onlyDesktop" });
    });
  };
  var jsMainLoader = document.body.querySelector(".js-main-loader");
  var jsMainLoaderBackground = document.body.querySelector(
    ".js-main-loader-background"
  );
  var loaderTween = tween_exports.createTimeTween({
    data: { opacity: 1, scale: 1 },
    duration: 1e3
  });
  if (jsMainLoader && jsMainLoaderBackground) {
    [jsMainLoader, jsMainLoaderBackground].forEach((item) => {
      loaderTween?.subscribe(({ opacity, scale }) => {
        item.style.opacity = opacity;
        item.style.transform = `scale(${scale})`;
      });
    });
  }
  var initApp = async () => {
    await loadData();
    modules_exports2.inizializeApp({
      rootId: "#root",
      contentId: "#content",
      wrapper,
      routes,
      index: "home",
      pageNotFound: "pageNotFound",
      beforePageTransition: beforePageTransition2,
      pageTransition: pageTransition2,
      afterInit: async () => {
        await loaderTween.goTo({ opacity: 0, scale: 0.9 });
        loaderTween.destroy();
        loaderTween = null;
        jsMainLoader?.remove();
        jsMainLoaderBackground?.remove();
        jsMainLoader = null;
        jsMainLoaderBackground = null;
        getScrollbarWith();
        redirectOnResize();
      },
      redirect: ({ route }) => {
        return shouldRedirect() ? "onlyDesktop" : route;
      },
      restoreScroll: true,
      componentDefaultProps: {
        scoped: false,
        maxParseIteration: 1e4,
        debug: false
      }
    });
  };
  modules_exports.useLoad(() => {
    setBrowserClass();
    core_exports.setDefault({
      deferredNextTick: true
    });
    initApp();
    usePageScroll();
  });
})();
//# sourceMappingURL=main.js.map
