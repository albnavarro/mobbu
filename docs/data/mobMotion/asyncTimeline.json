{
    "data": [
        {
            "component": "mob-spacer",
            "props": {
                "style": "small",
                "id": "start",
                "label": "Overview"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h1",
                "isBold": true
            },
            "content": "Async timeline"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Async timeline is a promise manager., it allows you to coordinate tween, lerp and spring, it can manage single tweens or groups of tweens. Manages loops and allows you to use custom functions between different tweens."
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "Params:"
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineSchema.d.ts",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 6
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimeline.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 8
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h5"
            },
            "content": "repeat:"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Determines the number of loops to run.</br>Number -1 means that the timeline will run in an infinite loop."
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h5"
            },
            "content": "yoyo:"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Reverse the direction each time the timeline ends.<br/>The current/arrival/destination values of each tween will be reversed according to the timeline."
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h5"
            },
            "content": "freeMode:"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": " By default when a play or a playReverse is performed a `set method` is executed on each tween using the `initial values` (play) or the `final values` (playReverse) to make each tween start from a 'neutral' position regardless of its value current. Sets are not saved in the timeline but are `temporary`. If the `freeMode` property is set to `true` a sets are not executed so that multiple timelines can control the same tweens always starting from the current value of each tween.<br/> `The default is false`. "
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h5"
            },
            "content": "autoSet:"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "If `autoSet` is set to true for each tween a `set method` corresponding to the `beginning` and `end` of the same timeline will be created. The newly created methods will be `permanently` added to the start and ends of the timeline. As these sets are permanent unlike the default behavior (with freeMode = false) during a repeat the timeline will always restart from the initial (or final) value. "
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "code_example",
                "label": "code&nbsp;example"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "code example"
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineExample.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 73
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "override",
                "label": "tween&nbsp;params&nbsp;and&nbsp;override"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "tween params and override"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "The parameters relating to each instance will be used, if necessary, according to the following scheme, in addition there is the delay parameter expressed in milliseconds."
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncOverride.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 14
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "set",
                "label": "Set"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h2"
            },
            "content": "Methods"
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "Set"
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineSet.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 1
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "goto",
                "label": "goTo"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "goTo"
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineGoTo.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 6
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "goFrom",
                "label": "goFrom"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "goFrom"
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineGoFrom.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 3
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "goFromTo",
                "label": "goFromTo"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "goFromTo"
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineGoFromTo.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 13
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "add",
                "label": "add/addAsync"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "add/addAsync"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "It is possible to use both synchronous and asynchronous custom functions within the timeline. Both functions will be executed only when the promise has been resolved ( tween ). This allows you to execute functions exactly after the previous one or before the next one without any risk of even minimal overlap."
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h5"
            },
            "content": "addAsync params:"
        },
        {
            "component": "mob-list",
            "props": {
                "style": "medium",
                "items": [
                    "<span class='quote'>resolve</span>: the resolve function",
                    "<span class='quote'>loop</span>: current loop counter",
                    "<span class='quote'>direction</span>: current direction 'forward | backward'"
                ]
            }
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineAdd.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 33
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "sync",
                "label": "sync"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "sync"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Synchronize the current values of one tween with another. Cannot be used within a group."
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineSync.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 18
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "createGroup",
                "label": "create/closeGroup"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "create/closeGroup"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Manages multiple instances in parallel.<br/> The waitComplete parameter allows you to decide whether the group is resolved when the last tween is resolved ( promiseAll) or when the first is resolved ( promiseRace )."
        },
        {
            "component": "mob-list",
            "props": {
                "style": "medium",
                "items": [
                    "<span class='quote'>true</span>: promiseAll",
                    "<span class='quote'>false</span>: promiseRace"
                ]
            }
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Within a group each instance will still be able to use the delay property."
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineGroup.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 27
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "suspend",
                "label": "suspend"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "suspend"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Put the timeline on hold, through the resume() method, the timeline will restart. As with add/addAsync remove will only be executed when the previous tween is completely finished."
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineSuspend.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 16
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "label",
                "label": "label"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "label"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Adds a label at a specific point in the timeline, the label will then be used by the playFrom(label) or playFromReverse(label) method"
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineLabel.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 9
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "settween",
                "label": "setTween"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "setTween"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Since asyncTimeline does not reason with time, it may happen that using the playFrom(label) method some tweens with a delay applied are not immediately aligned to the starting point specified by the label. To overcome this (but it can also be useful in other cases) the setTween method allows you to align the desired tweens to a label after which we can, for example, start from the same label:"
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineSetTween.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 5
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "play",
                "label": "play/playRevese/stop"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "play/playReverse/stop"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "play, play reverse and stop of the timeline. The play() and playReverse() methods will return a promise when the timeline is completed."
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "The stop() method has as its parameter the possibility of clearing the stagger cache if subscribeCache has been used (by default it is true).<br/> If disabled at the stop event the staggers will finish their path by aligning with the first element."
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelinePlay.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 14
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "playFrom",
                "label": "playFrom/playFromReverse"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "playFrom/playFromReverse"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Like the play() / playReverse() method but a label will be used as the starting point."
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelinePlayFrom.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 9
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "pause/resume",
                "label": "pause/resume"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "pause/resume"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Pauses and unpauses a timeline. the resume() method is also used for a timeline that has been put into pause status via the suspend method."
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelinePause.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 9
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "reverseNext",
                "label": "reverseNext"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "reverseNext"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Reverses the timeline as soon as the current promise/tween is finished."
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineNext.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 20
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "onLoopEnd",
                "label": "onLoopEnd/onComplete"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "onLoopEnd/onComplete"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "There are two methods, onLoopEnd and onComplete."
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Both events will return an unsubscribe function."
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h4"
            },
            "content": "onLoopEnd params:"
        },
        {
            "component": "mob-list",
            "props": {
                "style": "medium",
                "items": [
                    "<span class='quote'>loop</span>: current loop counter",
                    "<span class='quote'>direction</span>: current direction 'forward | backward'"
                ]
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "small"
            }
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineEvents.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 9
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "destroy",
                "label": "destroy"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "destroy"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Destroy function.<br/>The destroy function will also destroy all the tweens that have been used, and it is advisable to also cancel the references to the individual tweens."
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineDestroy.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 8
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium",
                "id": "utils",
                "label": "Utils"
            }
        },
        {
            "component": "mob-title",
            "props": {
                "tag": "h3"
            },
            "content": "Utils"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "isPaused/isSuspended/getDirection"
        },
        {
            "component": "mob-paragraph",
            "props": {
                "style": "medium"
            },
            "content": "Utilities to check the status of the timeline:"
        },
        {
            "component": "mob-snippet",
            "props": {
                "source": "./snippets/mobMotion/asyncTimelineUtils.js",
                "isFull": true,
                "hasOverflow": false,
                "hasBorder": true,
                "numLines": 3
            }
        },
        {
            "component": "mob-spacer",
            "props": {
                "style": "medium"
            }
        }
    ]
}
